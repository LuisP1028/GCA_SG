<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Part II: Searching // Study Guide</title>
<style>
    /* 
       --- STYLE CONFIGURATION --- 
    */
    :root {
        --bg-color: #000000;
        --text-color: #00ff41;
        --accent-color: #00ff41;
        --dim-color: #003b00;
        --border-color: #00ff41;
        --font-main: 'Courier New', Courier, monospace;
        --font-header: 'Arial Black', Impact, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: var(--font-main);
        line-height: 1.5;
        overflow-x: hidden;
    }

    .dither-layer {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        z-index: -1;
        background-image: radial-gradient(circle, #003b00 1px, transparent 1px);
        background-size: 4px 4px;
        opacity: 0.4;
    }

    .scanlines {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(to bottom, rgba(0, 255, 65, 0), rgba(0, 255, 65, 0) 50%, rgba(0, 20, 0, 0.2) 50%, rgba(0, 20, 0, 0.2));
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 9999;
    }

    .container {
        max-width: 900px;
        width: 100%;
        margin: 0 auto;
        padding: 40px 20px;
        border-left: 2px dashed var(--dim-color);
        border-right: 2px dashed var(--dim-color);
        background-color: rgba(0, 10, 0, 0.9);
        min-height: 100vh;
    }

    h1 {
        font-family: var(--font-header);
        text-transform: uppercase;
        font-size: 2.5rem;
        border-bottom: 5px solid var(--accent-color);
        margin-bottom: 40px;
        color: var(--accent-color);
        text-align: center;
    }

    strong { color: var(--accent-color); text-decoration: underline; }
    em { font-style: normal; color: #50c878; border-bottom: 1px dotted var(--dim-color); }

    /* ACCORDION STYLES */
    details.section {
        margin-bottom: 15px;
        border: 1px solid var(--dim-color);
        background: #050505;
    }

    details.section > summary {
        font-family: var(--font-main);
        font-weight: bold;
        padding: 12px;
        background: #0a0a0a;
        color: var(--text-color);
        cursor: pointer;
        list-style: none;
        border-bottom: 1px solid transparent;
        text-transform: uppercase;
        font-size: 1.1rem;
    }

    details.section > summary:hover { background: var(--dim-color); color: var(--accent-color); }
    details.section[open] > summary {
        border-bottom: 1px solid var(--dim-color);
        background: #0f0f0f;
        color: var(--accent-color);
        text-shadow: 0px 0px 5px var(--accent-color);
    }

    .section-content { padding: 20px; }

    .subsection {
        margin-bottom: 25px;
        border-left: 4px solid var(--dim-color);
        padding-left: 15px;
    }

    .subsection-title {
        background: var(--dim-color);
        color: var(--accent-color);
        padding: 2px 6px;
        font-weight: bold;
        text-transform: uppercase;
        display: inline-block;
        margin-bottom: 10px;
        font-size: 0.9rem;
    }

    p { margin-bottom: 12px; margin-top: 0; text-align: justify; }
    ul { padding-left: 20px; margin-bottom: 15px; }
    li { margin-bottom: 5px; }

    .code-block {
        background: #020a02;
        border: 1px dashed var(--dim-color);
        padding: 10px;
        margin: 10px 0;
        font-family: 'Courier New', monospace;
        color: var(--accent-color);
        overflow-x: auto;
        white-space: pre-wrap;
    }
</style>
</head>
<body>

<div class="dither-layer"></div>
<div class="scanlines"></div>

<div class="container">
    <h1>Part II: Searching</h1>

    <div class="part-content">
        
        <details class="section">
            <summary>1. Binary Search</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <div class="subsection-title">Searching Basics</div>
                    <p>Custom types require user-defined Comparators.</p>
                    <p>"Comparable" simply means you have written a specific rule (a function) that tells the computer exactly how to decide which of two objects comes first.</p>
                    <p>Transitivity = Logical Consistency</p>
                </div>

                <div class="subsection">
                    <div class="subsection-title">
                        Search a Sorted Array for the First Occurrence of ‚Äòk‚Äô
                        <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Searching/binary_search_for_k.html'; document.querySelector('.retro-viewport').classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                    <div class="subsection-content">
                        <p>Standard binary search returns the moment it finds k. This version keeps going left to ensure it found the first k, not just any k.</p>
                        <p><strong>Initialize:</strong> Set bounds to cover the entire array. Set result = ‚àíùüè (indicating failure).</p>
                        <p><strong>Loop:</strong> While the window remains valid (left ‚â§ right): ‚Ä¢ Calculate the middle index: mid = (left + right) // ùüê</p>
                        <p><strong>Decision Logic:</strong></p>
                        <ul>
                            <li><strong>Case A (ùêÄ[ùê¶ùê¢ùêù] > ùê§):</strong> The first occurrence must lie to the left. Discard the right half ‚Üí right = mid ‚àí ùüè</li>
                            <li><strong>Case B (ùêÄ[ùê¶ùê¢ùêù] < ùê§):</strong> The first occurrence must lie to the right. Discard the left half ‚Üí left = mid + ùüè</li>
                            <li><strong>Case C (ùêÄ[ùê¶ùê¢ùêù] = ùê§):</strong> (The key difference from standard binary search) ‚Ä¢ We have found an occurrence of ùê§ ‚Ä¢ Update result = mid (this is the best candidate found so far) ‚Ä¢ <strong>CRITICAL:</strong> Do not stop here. Aggressively prune the right side: right = mid ‚àí ùüè (We continue searching leftward to find any earlier occurrence). Store mid in result. By forcing the search left, any future match is guaranteed to be earlier, so we simply overwrite the old value.</li>
                        </ul>
                    </div>
                </div>
                    <p>Standard binary search returns the moment it finds k. This version keeps going left to ensure it found the first k, not just any k.</p>
                    <ul>
                        <li>Initialize: Set bounds to cover the entire array. Set result = ‚àíùüè (indicating failure).</li>
                        <li>Loop: While the window remains valid (left ‚â§ right): ‚Ä¢ Calculate the middle index: mid = (left + right) // ùüê</li>
                        <li>Decision Logic:
                            <ul>
                                <li>Case A (ùêÄ[ùê¶ùê¢ùêù] > ùê§): The first occurrence must lie to the left. Discard the right half ‚Üí right = mid ‚àí ùüè</li>
                                <li>Case B (ùêÄ[ùê¶ùê¢ùêù] < ùê§): The first occurrence must lie to the right. Discard the left half ‚Üí left = mid + ùüè</li>
                                <li>Case C (ùêÄ[ùê¶ùê¢ùêù] = ùê§): (The key difference from standard binary search) ‚Ä¢ We have found an occurrence of ùê§ ‚Ä¢ Update result = mid (this is the best candidate found so far) ‚Ä¢ CRITICAL: Do not stop here. Aggressively prune the right side: right = mid ‚àí ùüè (We continue searching leftward to find any earlier occurrence)</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="subsection">
                    <div class="subsection-title">
                        SEARCH SORTED ARRAY FOR ENTRY EQUAL TO ITS INDEX
                        <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Searching/Fixed_Point.html'; document.querySelector('.retro-viewport').classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                    <p><strong>Rephrasing and Definition</strong><br>
                    The problem asks you to find a "fixed point" in an array: a specific location (index) where the number stored there (value) is identical to the location number itself.</p>
                    <p><strong>Algorithm Adaptation</strong>: 
                    The adaptation is simple: Compare A[mid] to the index mid itself, by taking the difference as [Value ‚àí Index].</p>
                    <p>Mid is the index (the slot number or address, e.g., 5).<br>
                    A[mid] is the value stored inside that slot (e.g., 7).</p>
                    <p><strong>THE HOW</strong></p>
                    <ol>
                        <li><strong>Initialization:</strong> Define the bounds of your Search Space. Initialize two pointers, left to 0 and right to the last index of the array (**len(ùêÄ)** ‚àí 1).</li>
                        <li><strong>Bisection Loop:</strong> Enter a loop that continues as long as the search space is valid (i.e., left ‚â§ right). Inside, calculate the mid index: (**left** + right) // 2.</li>
                        <li><strong>Transformation (The Logic Core):</strong> Instead of comparing ùêÄ[mid] directly to a target, use the Difference = Value ‚àí Index.
                        <br>By subtracting the index, we transform the question to: ‚ÄúDoes value minus index equal zero?‚Äù</li>
                        <li><strong>Evaluation and Reduction:</strong> Check the state of difference:
                            <ul>
                                <li>Case 1 (Match): If difference == 0, then ùêÄ[mid] == mid. You have found the entry. Return mid.</li>
                                <li>Case 2 (Overshoot) If the value is already bigger than the index, it will stay bigger everywhere to the right. The index can never catch up, so we discard the right side.</li>
                                <li>Case 3 (Undershoot) If the value is currently too small, it was also too small everywhere to the left. The value could not have equaled the index earlier, so we discard the left side.</li>
                            </ul>
                        </li>
                        <li><strong>Termination:</strong> If the loop concludes without Case 1 ever being true, no such index exists. Return ‚àí1.</li>
                    </ol>
                </div>

                <div class="subsection">
                    <div class="subsection-title">
                        SEARCHING CYCLICALLY SORTED ARRAYS
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Searching/cyclically_sorted.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                    <p>Instead of testing relationship between midpoint and target, test the relationship between the midpoint value and the rightmost boundary value.</p>
                    <p>Divide and Conquer principle. Because the array is partially sorted, we can look at the middle element and the last element to determine which half of the array contains the anomaly</p>
                    <p><strong>THE HOW</strong></p>
                    <p><strong>Step 1: Initialize Boundaries</strong><br>
                    We begin by establishing the Search Space. We set two pointers:
                    <br>‚Ä¢ left = The start of the array (0) 
                    <br>‚Ä¢ right = The last index of the array (len(A) - 1) </p>
                    <p><strong>Step 2: The Loop Condition</strong><br>
                    We initiate a while loop that runs as long as left < right.
                    <br>‚Ä¢ Note: We use < instead of <= because we are not looking for a specific target that might be missing. We are looking for a boundary that definitely exists. When left equals right, we have converged on the single answer.</p>
                    <p><strong>Step 3: Calculate Midpoint</strong><br>
                    Inside the loop, we calculate mid: mid = (left + right) // 2
                    <br>‚Ä¢ This uses integer division to find the center index.</p>
                    <p><strong>Step 4: The Comparison Logic (The Invariant Check)</strong><br>
                    We compare A[mid] with A[right].</p>
                    <p><strong>Case A: The "Broken" Sequence</strong>
                    <br>‚Ä¢ Condition: if A[mid] > A[right]
                    <br>‚Ä¢ Deduction: Normal sorting dictates that values increase from left to right. If the middle value is larger than the rightmost value, the array is not sorted in this section. The "cyclic drop" (the reset from max to min) must occur somewhere after mid.
                    <br>‚Ä¢ Action: left = mid + 1
                    <br>‚Ä¢ Ontological Consequence: We strictly exclude mid and everything to its left. The minimum is definitely in the range [mid + 1, right].</p>
                    <p><strong>Case B: The "Sorted" Sequence</strong>
                    <br>‚Ä¢ Condition: else (implying A[mid] < A[right])
                    <br>‚Ä¢ Note on Distinctness: Since elements are distinct, A[mid] == A[right] is impossible.
                    <br>‚Ä¢ Deduction: If the middle is smaller than the right, the path from mid to right is ascending normally. Therefore, the "drop" cannot be in the right half. However, mid itself could be the minimum (e.g., [... 10, 20, 30]).
                    <br>‚Ä¢ Action: right = mid
                    <br>‚Ä¢ Ontological Consequence: We discard the right half (mid + 1 to right). We keep mid in the search space because it is a candidate for the minimum.</p>
                    <p><strong>Step 5: Termination and Return</strong><br>
                    The loop continues to halve the interval until left meets right.
                    <br>‚Ä¢ When the loop breaks, the Search Space has size 1.
                    <br>‚Ä¢ By the logic of the loop invariant, this single remaining index points to the smallest element.
                    <br>‚Ä¢ Return: left</p>
                </div>

            </div>
        </details>

        <details class="section">
            <summary>2. Generalized Search</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <div class="subsection-title">
                        SEARCHING 2D SORTED ARRAYS
                        <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Searching/2D_sorted_array_search.html'; document.querySelector('.retro-viewport').classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                    <p>A 2D array is sorted if it‚Äôs columns and rows are nondecreasing</p>
                    <p><strong>Why checking the top-left A[0][0] value fails:</strong> It provides no information gain.<br>
                    Since it is the smallest value in the matrix, finding that your target is larger offers no direction.</p>
                    <p><strong>Why checking the top right A[0][n-1]value works:</strong> It is an extremal case, providing valuable information.<br>
                    This corner is the perfect pivot: it is the largest number in the top row but the smallest in the last column.</p>
                    <ul>
                        <li>If your target is smaller than this pivot, it cannot be in this column (move left).</li>
                        <li>If the target is larger, it cannot be in this row (move down).</li>
                        <li>This property guarantees you eliminate a row or column with every comparison.</li>
                    </ul>
                    <p><strong>THE HOW: MANHATTAN WALKING</strong></p>
                    <p><strong>Step 1: Initialize the Search Space</strong><br>
                    We begin by setting our Pivot at the Top-Right corner of the matrix (Row 0, Last Column).
                    <br>‚Ä¢ Why here? This corner represents an Extremal Case. It is the largest value in the first row but the smallest value in the last column. This dual property is essential for Pruning.</p>
                    <p><strong>Step 2: The Search Loop</strong><br>
                    We enter a loop that continues only while our pivot remains inside the matrix boundaries. In each iteration, we compare the target x with the current element to make a decision.</p>
                    <p><strong>Step 3: The Decision Logic</strong><br>
                    We perform a three-way comparison to Eliminate parts of the grid:</p>
                    <ol>
                        <li><strong>Case: Match Found</strong>
                        <br>‚Ä¢ If the current element equals x, we have found the target.
                        <br>‚Ä¢ Action: Return True.</li>
                        <li><strong>Case: Target is Smaller (Prune the Column)</strong>
                        <br>‚Ä¢ Condition: x is smaller than the current element.
                        <br>‚Ä¢ Logic: Due to Column Sortedness, values only increase as you go down, meaning x cannot exist anywhere in this column.
                        <br>‚Ä¢ Action: Eliminate the column by moving the pivot Left.</li>
                        <li><strong>Case: Target is Larger (Prune the Row)</strong>
                        <br>‚Ä¢ Condition: x is larger than the current element.
                        <br>‚Ä¢ Logic: Due to Row Sortedness, values only decrease as you go left. Since the current element is the largest in the current row segment, x cannot exist anywhere in this row.
                        <br>‚Ä¢ Action: Eliminate the row by moving the pivot Down.</li>
                    </ol>
                    <p><strong>Step 4: Termination</strong><br>
                    If the loop finishes (meaning the pivot moved off the left edge or below the bottom edge) without finding a match, the Search Space is exhausted.
                    <br>‚Ä¢ Action: Return False.</p>
                </div>

                <div class="subsection">
                    <div class="subsection-title">
                        FIND MIN/MAX SIMULTANEOUSLY
                        <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Searching/min_max_simult.html'; document.querySelector('.retro-viewport').classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                    <p><strong>The Core Idea</strong><br>
                    <p> Instead of looking at numbers one by one, you look at them in pairs (two at a time).
                    <br>1. First, compare the two new numbers against each other.
                    <br>2. Take the larger one (the "winner") and compare it only against the global maximum.
                    <br>3. Take the smaller one (the "loser") and compare it only against the global minimum.<br>
                    For 2 numbers, that is only 3 questions. Over a long list, this saves a huge amount of work.</p>
                    <p><strong> Handing Odd Sized Arrays</strong>
                    <p> We must compare this final element against both global bounds.</p> 
                    <br>‚Ä¢ Check Max: Is 4 > Global Max (5)? No.
                    <br>‚Ä¢ Check Min: Is 4 < Global Min (1)? No.</p>
                    
                </div>

                <div class="subsection">
                    <div class="subsection-title">
                        FIND THE K-TH RANKED LARGEST ELEMENT
                        <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Searching/k_largest_element.html'; document.querySelector('.retro-viewport').classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                    <p><strong>THE HOW:</strong></p>
                    <p>To find the k-th ranked largest element, don't sort the whole list. Pick a pivot, partition so smaller elements go left, larger go right. The pivot lands in its final position. If it's at index k-1, we're done. Otherwise, discard the unwanted half and repeat.</p>

                    <p><strong>SIMPLIFIED HOW:</strong></p>
                    <ol>
                        <li>Define the beginning and end of the array</li>
                        <li>Randomly pick a pivot value</li>
                        <li>Move all values larger than the pivot to the left of the pivot, and move the pivot to the right end of the array, to not accidentally swap it.</li>
                        <li>Move the pivot back to the front of the new index, where all values larger than it are to the left of</li>
                        <li>Compare the pivot to the target. If found, you're done. if Pivot < Target, go Left. If Pivot > Target, go Right.</li>
                    </ol>
                </div>

            </div>
        </details>

        <details class="section">
            <summary>3. Indexing & Hashing</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <div class="subsection-title">
                        FIND MISSING IP ADDRESS
                        <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Searching/missing_IP.html'; document.querySelector('.retro-viewport').classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                        <div>
                            <p><strong>Step 1: Divide the Search Space</strong><br>
                            Create an array of 65,536 counters to partition the search space. Since the top 16 bits of an IP evaluate to a number between 0 and 65,535, we use that number as the direct array index. Each slot acts as a bucket to count how many IPs share that specific prefix.</p>
                        
                            <p><strong>Step 2: Count the Prefixes</strong><br>
                            Stream the file. Use the top 16 bits of each IP as an array index and increment that slot's counter to tally the group's population.</p>
                        
                            <p><strong>Step 3: Locate the Candidate Bucket</strong><br>
                            Scan the array. A full group has exactly 65,536 IPs. Find a slot with a count lower than this; the missing IP is hiding in that specific prefix range.</p>
                        
                            <p><strong>Step 4: Prepare the Checklist</strong><br>
                            Clear memory and allocate a bit vector with 65,536 positions. Each bit represents a possible "Local Number" (Suffix) within our target "Area Code" (Prefix). Initialize all bits to zero.</p>
                        
                            <p><strong>Step 5: Reading the suffix</strong><br>
                            Stream the original file from the hard drive. For each IP, check the "Area Code" (Prefix). If it matches our target group, look at the "Local Number" (Suffix). Use that number to find the corresponding spot on your Bit Vector checklist and mark it as present (set to 1). You are strictly crossing off every number that exists in the file for that specific group.</p>
                        
                            <p><strong>Step 6: Identify and Reconstruct</strong><br>
                            Scan the bit vector. The bit remaining at '0' reveals the specific missing Suffix. Combine that with your known Candidate Prefix to yield the exact missing IP address.</p>
                        </div>

            </div>
        </details>

    </div>
</div>

</body>
</html>