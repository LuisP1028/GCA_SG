<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Greedy Interval Scheduling // Ditherpunk</title>
    <style>
        :root {
            --bg-color: #000000;
            --phos-color: #33ff33;
            --phos-dim: #1a801a;
            --font-stack: 'Courier New', Courier, monospace;
            
            /* Responsive spacing */
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            color: var(--phos-color);
            font-family: var(--font-stack);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* CRT Overlay Effects */
        .crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 6px 100%;
            box-shadow: inset 0 0 5vmax rgba(0,0,0,0.9);
        }

        .crt-glow {
            text-shadow: 0 0 0.3rem var(--phos-color);
        }

        /* Main Layout */
        #visualization-container {
            flex-grow: 1; /* Takes all available space */
            position: relative;
            width: 95%; /* Responsive width */
            max-width: 1600px; /* Cap width on ultrawide */
            margin: var(--spacing-md) auto;
            border: 2px solid var(--phos-color);
            box-sizing: border-box;
            min-height: 200px; /* Prevent collapse on tiny screens */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Control Panel / Terminal */
        #terminal {
            /* Responsive Height */
            height: auto;
            min-height: 150px;
            max-height: 35vh; /* Don't take more than 35% of screen height */
            
            width: 95%;
            max-width: 1600px;
            margin: 0 auto var(--spacing-md) auto;
            
            border: 1px solid var(--phos-dim);
            padding: var(--spacing-sm);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            
            background: #050505;
            box-sizing: border-box;
            font-size: clamp(0.8rem, 2vw, 1rem); 
        }

        #log-window {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: var(--spacing-sm);
            border-bottom: 1px dashed var(--phos-dim);
            padding-bottom: 5px;
            font-family: var(--font-stack);
            white-space: pre-wrap;
            /* Scrollbar styling for webkit */
            scrollbar-width: thin;
            scrollbar-color: var(--phos-dim) var(--bg-color);
        }

        #log-window::-webkit-scrollbar { width: 8px; }
        #log-window::-webkit-scrollbar-thumb { background: var(--phos-dim); }

        .log-entry { margin-bottom: 0.25rem; line-height: 1.2; }
        .log-entry::before { content: ">> "; color: var(--phos-dim); }

        #controls {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on mobile */
            gap: var(--spacing-md);
            align-items: center;
            padding-top: var(--spacing-sm);
        }

        button {
            flex: 1 1 auto; /* Grow to fill space on mobile */
            background: transparent;
            border: 2px solid var(--phos-color);
            color: var(--phos-color);
            font-family: var(--font-stack);
            font-size: clamp(0.8rem, 1.5vw, 1.2rem);
            padding: 0.5rem 1rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 5px var(--phos-color);
            transition: all 0.1s;
            white-space: nowrap;
        }

        button:hover {
            background: var(--phos-color);
            color: var(--bg-color);
        }

        button:active {
            transform: translateY(2px);
        }

        .status-pill {
            margin-left: auto;
            border: 1px solid var(--phos-color);
            padding: 0.25rem 0.75rem;
            font-size: clamp(0.7rem, 1.2vw, 0.9rem);
            white-space: nowrap;
        }

        /* Mobile Adjustments */
        @media (max-width: 600px) {
            #controls { gap: 10px; }
            .status-pill { width: 100%; text-align: center; margin-top: 5px; }
            #terminal { min-height: 200px; }
        }
    </style>
</head>
<body>

    <div class="crt-overlay"></div>

    <div id="visualization-container" class="crt-glow">
        <canvas id="mainCanvas"></canvas>
    </div>

    <div id="terminal" class="crt-glow">
        <div id="log-window">Initializing system...<br>Awaiting input...</div>
        <div id="controls">
            <button id="btn-run">[ RUN ]</button>
            <button id="btn-speed">[ SPEED: SLOW ]</button>
            <div class="status-pill" id="visit-counter">VISITS: 0</div>
        </div>
    </div>

<script>
/**
 * DITHERPUNK INTERVAL SCHEDULING VISUALIZATION - RESPONSIVE
 */

// --- CONFIGURATION ---
const COLOR_BG = '#000000';
const COLOR_FG = '#33ff33';

// --- STATE MANAGEMENT ---
const STATE = {
    IDLE: 0,
    SORTING: 1,
    SCANNING: 2,
    DROPPING_LASER: 3,
    CHECKING_OVERLAP: 4,
    FINISHED: 5
};

let appState = STATE.IDLE;
let intervals = [];
let visits = []; 
let scanIndex = 0; 
let activeInterval = null; 
let lastVisitX = -1;
let animationSpeed = 1; 
let lastFrameTime = 0;
let logicTimer = 0;

// Canvas & Context
const container = document.getElementById('visualization-container');
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// DOM Elements
const logWindow = document.getElementById('log-window');
const btnRun = document.getElementById('btn-run');
const btnSpeed = document.getElementById('btn-speed');
const visitDisplay = document.getElementById('visit-counter');

// Layout Metrics (Calculated on Resize)
let layout = {
    width: 0,
    height: 0,
    paddingX: 0,
    paddingY: 0,
    chartW: 0,
    chartH: 0,
    fontSize: 10,
    dpr: 1
};

// --- PATTERN GENERATION (Dithering) ---
// Note: Patterns need to be recreated if DPR changes significantly, 
// but strictly speaking for this style, low-res patterns scaled up look fine/better.
function createPattern(type) {
    const patCanvas = document.createElement('canvas');
    const patCtx = patCanvas.getContext('2d');
    
    if (type === 'noise') {
        patCanvas.width = 4;
        patCanvas.height = 4;
        patCtx.fillStyle = COLOR_BG;
        patCtx.fillRect(0,0,4,4);
        patCtx.fillStyle = COLOR_FG;
        patCtx.fillRect(0, 0, 1, 1);
        patCtx.fillRect(2, 2, 1, 1);
        patCtx.fillRect(3, 1, 1, 1);
    } 
    else if (type === 'hatch') {
        patCanvas.width = 8;
        patCanvas.height = 8;
        patCtx.fillStyle = COLOR_BG;
        patCtx.fillRect(0,0,8,8);
        patCtx.strokeStyle = COLOR_FG;
        patCtx.lineWidth = 1;
        patCtx.beginPath();
        patCtx.moveTo(0, 8);
        patCtx.lineTo(8, 0);
        patCtx.stroke();
    }
    else if (type === 'solid') {
        patCanvas.width = 2;
        patCanvas.height = 2;
        patCtx.fillStyle = COLOR_FG;
        patCtx.fillRect(0,0,2,2);
    }
    else if (type === 'grid') {
        patCanvas.width = 20;
        patCanvas.height = 20;
        patCtx.fillStyle = '#0a2a0a'; 
        patCtx.fillRect(0,0,20,1);
        patCtx.fillRect(0,0,1,20);
    }

    return ctx.createPattern(patCanvas, 'repeat');
}

const patterns = {
    noise: createPattern('noise'),
    hatch: createPattern('hatch'),
    solid: createPattern('solid'),
    bg: createPattern('grid')
};

// --- DATA STRUCTURES ---

class Interval {
    constructor(id, start, end) {
        this.id = id;
        this.start = start; // 0-100 scale
        this.end = end;     // 0-100 scale
        this.status = 'PENDING';
        this.yPos = 0; 
        this.targetY = 0;
    }
}

// --- LOGIC FUNCTIONS ---

function log(msg) {
    const div = document.createElement('div');
    div.className = 'log-entry';
    div.innerText = msg;
    logWindow.appendChild(div);
    // Smooth scroll
    logWindow.scrollTo({ top: logWindow.scrollHeight, behavior: 'smooth' });
}

function generateData() {
    intervals = [];
    visits = [];
    lastVisitX = -1;
    visitDisplay.innerText = "VISITS: 0";
    
    // Calculate density based on screen height
    // On small screens, fewer tasks so it's not a blur
    const count = window.innerHeight < 600 ? 8 : 14;

    for(let i=0; i<count; i++) {
        let s = Math.random() * 80;
        let length = 5 + Math.random() * 15;
        let e = Math.min(s + length, 100);
        let interval = new Interval(i, s, e);
        interval.yPos = i / count;
        interval.targetY = interval.yPos;
        intervals.push(interval);
    }
    log(`Generated ${count} tasks.`);
}

function startSort() {
    appState = STATE.SORTING;
    log("SORTING: Right Endpoint (Asc)...");
    intervals.sort((a, b) => a.end - b.end);
    intervals.forEach((inv, index) => {
        inv.targetY = index / intervals.length;
    });
}

function checkNext() {
    let found = false;
    for(let i=0; i<intervals.length; i++) {
        if(intervals[i].status === 'PENDING') {
            activeInterval = intervals[i];
            activeInterval.status = 'ACTIVE';
            scanIndex = i;
            appState = STATE.DROPPING_LASER;
            // Shortened log for mobile readability
            log(`SCAN: ID ${activeInterval.id} ends soonest.`);
            found = true;
            break;
        }
    }
    
    if(!found) {
        appState = STATE.FINISHED;
        log("OPTIMAL SOLUTION FOUND.");
        btnRun.innerText = "[ RESTART ]";
    }
}

function performVisit() {
    let visitTime = activeInterval.end;
    visits.push(visitTime);
    lastVisitX = visitTime;
    
    visitDisplay.innerText = `VISITS: ${visits.length}`;
    log(`GREEDY: Visit at time ${visitTime.toFixed(1)}`);
    
    appState = STATE.CHECKING_OVERLAP;
}

function checkOverlaps() {
    let newlyCovered = 0;
    intervals.forEach(inv => {
        if(inv.status === 'PENDING' || inv.status === 'ACTIVE') {
            if(inv.start <= lastVisitX) {
                inv.status = 'COVERED';
                newlyCovered++;
            }
        }
    });
    
    log(`RESULT: Covered ${newlyCovered} tasks.`);
    activeInterval = null;
    appState = STATE.SCANNING;
}

// --- RENDER LOOP ---

function draw() {
    // Use Pre-calculated layout metrics
    const w = layout.width;
    const h = layout.height;
    
    // 1. Clear & Background
    ctx.fillStyle = COLOR_BG;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = patterns.bg;
    ctx.fillRect(0,0,w,h);

    // 2. Draw Axis
    // Use responsive padding
    const startX = layout.paddingX;
    const endX = w - layout.paddingX;
    const axisY = h - layout.paddingY;
    
    ctx.strokeStyle = COLOR_FG;
    ctx.lineWidth = Math.max(2, w * 0.002); // Dynamic thickness
    ctx.beginPath();
    ctx.moveTo(startX, axisY);
    ctx.lineTo(endX, axisY); 
    ctx.stroke();

    // 3. Draw Visits
    const dashSize = Math.max(3, w * 0.005);
    ctx.setLineDash([dashSize, dashSize]);
    ctx.lineWidth = Math.max(1, w * 0.001);
    ctx.strokeStyle = COLOR_FG;

    const pinSize = Math.max(4, w * 0.006);

    visits.forEach(vx => {
        let xPos = startX + (vx / 100) * layout.chartW;
        ctx.beginPath();
        ctx.moveTo(xPos, layout.paddingY);
        ctx.lineTo(xPos, axisY);
        ctx.stroke();
        
        ctx.fillStyle = COLOR_FG;
        ctx.fillRect(xPos - (pinSize/2), layout.paddingY - (pinSize/2), pinSize, pinSize);
    });
    
    ctx.setLineDash([]); // Reset

    // 4. Draw Intervals
    const barHeight = (layout.chartH / intervals.length) * 0.6;
    
    intervals.forEach(inv => {
        // Animation Interpolation
        let diff = inv.targetY - inv.yPos;
        if(Math.abs(diff) > 0.001) inv.yPos += diff * 0.1; 
        else inv.yPos = inv.targetY;

        let x = startX + (inv.start / 100) * layout.chartW;
        let width = ((inv.end - inv.start) / 100) * layout.chartW;
        let y = layout.paddingY + (inv.yPos * layout.chartH);
        
        if (inv.status === 'COVERED') {
            ctx.fillStyle = patterns.hatch;
            ctx.strokeStyle = '#1a801a';
        } else if (inv.status === 'ACTIVE') {
            ctx.fillStyle = (Date.now() % 500 < 250) ? patterns.solid : patterns.noise;
            ctx.strokeStyle = COLOR_FG;
        } else {
            ctx.fillStyle = patterns.noise;
            ctx.strokeStyle = COLOR_FG;
        }

        ctx.fillRect(x, y, width, barHeight);
        ctx.strokeRect(x, y, width, barHeight);

        // Label (Only if enough space)
        if(layout.width > 400) {
            ctx.fillStyle = COLOR_FG;
            ctx.font = `${layout.fontSize}px monospace`;
            ctx.fillText(inv.id, x - (layout.fontSize * 1.5), y + barHeight/2 + (layout.fontSize * 0.3));
        }
    });

    // 5. Laser Beam
    if(appState === STATE.DROPPING_LASER || appState === STATE.CHECKING_OVERLAP) {
        if(activeInterval) {
            let laserX = startX + (activeInterval.end / 100) * layout.chartW;
            ctx.strokeStyle = COLOR_FG;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(laserX, layout.paddingY);
            ctx.lineTo(laserX, axisY);
            ctx.stroke();
            
            // Text placement adjustment
            ctx.font = `${layout.fontSize}px monospace`;
            ctx.fillText("SCANNING", laserX + 5, axisY - 5);
        }
    }
}

function update(dt) {
    logicTimer += dt;
    const threshold = 1000 / animationSpeed;

    if (logicTimer > threshold) {
        logicTimer = 0;
        switch (appState) {
            case STATE.SORTING:
                let isSettled = intervals.every(i => Math.abs(i.targetY - i.yPos) < 0.01);
                if(isSettled) {
                    appState = STATE.SCANNING;
                    log("Sort complete.");
                }
                break;
            case STATE.SCANNING: checkNext(); break;
            case STATE.DROPPING_LASER: performVisit(); break;
            case STATE.CHECKING_OVERLAP: checkOverlaps(); break;
        }
    }
}

function loop(timestamp) {
    let dt = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    update(dt);
    draw();
    requestAnimationFrame(loop);
}

// --- INTERACTION & RESIZING ---

function resize() {
    // 1. Get container dimensions
    const rect = container.getBoundingClientRect();
    
    // 2. Handle High DPI (Retina)
    const dpr = window.devicePixelRatio || 1;
    
    // 3. Set actual canvas size (resolution)
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    
    // 4. Scale context
    ctx.scale(dpr, dpr);
    
    // 5. Update Layout calculations (Logical pixels)
    layout.dpr = dpr;
    layout.width = rect.width;
    layout.height = rect.height;
    
    // Dynamic Padding based on percentage, clamped
    layout.paddingX = Math.max(30, rect.width * 0.05); 
    layout.paddingY = Math.max(20, rect.height * 0.05);
    
    layout.chartW = layout.width - (layout.paddingX * 2);
    // Reserve space for axis at bottom
    layout.chartH = layout.height - (layout.paddingY * 2) - 20; 
    
    // Dynamic Font Size
    layout.fontSize = Math.max(10, Math.min(14, rect.width * 0.015));
}

// Debounce resize to prevent flicker on mobile scroll/orientation change
let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(resize, 100);
});

btnRun.addEventListener('click', () => {
    if(appState === STATE.FINISHED || appState === STATE.IDLE) {
        generateData();
        startSort();
        btnRun.innerText = "[ RESTART ]";
    } else {
        generateData();
        startSort();
    }
});

btnSpeed.addEventListener('click', () => {
    if(animationSpeed === 1) {
        animationSpeed = 4;
        btnSpeed.innerText = "[ SPEED: FAST ]";
    } else {
        animationSpeed = 1;
        btnSpeed.innerText = "[ SPEED: SLOW ]";
    }
});

// Init
resize();
generateData();
log("System Ready.");
requestAnimationFrame(loop);

</script>
</body>
</html>