<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GREEDY_SORT_VISUALIZER // V.1.1</title>
    <style>
        :root {
            --bg: #000000;
            --fg: #00FF00;
            --dim: #005500;
            --crt-line: rgba(18, 16, 16, 0);
            --crt-scan: rgba(0, 0, 0, 0.25);
            
            /* Responsive spacing */
            --spacing-sm: clamp(0.5rem, 1vw, 1rem);
            --spacing-md: clamp(1rem, 2vw, 2rem);
            
            /* Typography */
            --font-base: 'Courier New', Courier, monospace;
            --text-sm: clamp(0.75rem, 1.5vw, 0.9rem);
            --text-md: clamp(0.9rem, 2vw, 1.2rem);
            --text-lg: clamp(1.2rem, 4vw, 2rem);
        }

        *, *::before, *::after {
            box-sizing: border_box;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font-base);
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            user-select: none;
            
            /* Modern Grid Layout */
            display: grid;
            grid-template-rows: auto 1fr minmax(100px, 20vh);
            grid-template-areas: 
                "header"
                "main"
                "footer";
        }

        /* CRT Scanline Effect Overlay */
        body::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                var(--crt-line) 50%, 
                var(--crt-scan) 50%
            ), linear-gradient(
                90deg, 
                rgba(255, 0, 0, 0.06), 
                rgba(0, 255, 0, 0.02), 
                rgba(0, 0, 255, 0.06)
            );
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
            z-index: 999;
        }

        header {
            grid-area: header;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) var(--spacing-md);
            border-bottom: 2px solid var(--fg);
            z-index: 10;
        }

        h1 {
            font-size: var(--text-lg);
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        button {
            background: var(--bg);
            color: var(--fg);
            border: 2px solid var(--fg);
            padding: 0.5em 1em;
            font-family: inherit;
            font-weight: bold;
            font-size: var(--text-md);
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 4px 4px 0px var(--fg);
            transition: transform 0.1s, box-shadow 0.1s;
            white-space: nowrap;
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px var(--fg);
        }

        button:disabled {
            border-color: var(--dim);
            color: var(--dim);
            box-shadow: none;
            cursor: not-allowed;
        }

        main {
            grid-area: main;
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        footer {
            grid-area: footer;
            border-top: 2px solid var(--fg);
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: var(--text-sm);
            overflow-y: auto;
            background-color: var(--bg);
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .log-entry {
            margin-bottom: 0.25rem;
            word-wrap: break-word;
        }
        .log-highlight {
            font-weight: bold;
            text-decoration: underline;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg); border-left: 1px solid var(--dim); }
        ::-webkit-scrollbar-thumb { background: var(--fg); }
        
        @media (max-width: 480px) {
            header {
                flex-direction: column;
                gap: 1rem;
                align-items: flex-start;
            }
            button {
                width: 100%;
                text-align: center;
            }
        }
    </style>
</head>
<body>

    <header>
        <h1>Min_Wait_Algo</h1>
        <button id="runBtn">Run Simulation</button>
    </header>

    <main id="canvas-container">
        <canvas id="simCanvas"></canvas>
    </main>

    <footer id="consoleLog">
        <div class="log-entry">> SYSTEM READY.</div>
        <div class="log-entry">> WAITING FOR INPUT...</div>
    </footer>

<script>
/**
 * DITHERPUNK VISUALIZER // V1.1 (Responsive)
 * Logic: Greedy Algorithm (Minimizing Total Waiting Time)
 * Style: 1-bit Green/Black
 */

// --- CONFIGURATION ---
const COLORS = {
    bg: '#000000',
    fg: '#00FF00',
    dim: '#005500'
};
const TASK_COUNT = 6;
const ANIMATION_SPEED = 1.5;

// --- STATE MANAGEMENT ---
let canvas, ctx;
let width, height; // Logical dimensions (CSS pixels)
let dpr; // Device Pixel Ratio
let tasks = [];
let ghosts = [];
let isRunning = false;
let accumulator = 0;
let ditherPattern;

// Scalable Metrics
let metrics = {
    fontSize: 16,
    padding: 20,
    gap: 10,
    baseline: 0,
    lineWidth: 2
};

// --- DOM ELEMENTS ---
const runBtn = document.getElementById('runBtn');
const logContainer = document.getElementById('consoleLog');
const container = document.getElementById('canvas-container');

// --- INITIALIZATION ---

function init() {
    canvas = document.getElementById('simCanvas');
    ctx = canvas.getContext('2d', { alpha: false });
    
    // Resize Observer handles all screen changes
    const resizeObserver = new ResizeObserver(() => handleResize());
    resizeObserver.observe(container);
    
    // Initial Setup
    createDitherPattern();
    handleResize(); // Triggers initial setup
    
    runBtn.addEventListener('click', startSimulation);
}

function createDitherPattern() {
    const patCanvas = document.createElement('canvas');
    patCanvas.width = 4;
    patCanvas.height = 4;
    const pCtx = patCanvas.getContext('2d');
    
    pCtx.fillStyle = COLORS.bg;
    pCtx.fillRect(0,0,4,4);
    pCtx.fillStyle = COLORS.fg;
    pCtx.fillRect(0,0,2,2);
    pCtx.fillRect(2,2,2,2);
    
    ditherPattern = ctx.createPattern(patCanvas, 'repeat');
}

/**
 * Handles seamless resizing by scaling coordinate systems
 * preserving the relative positions of animations.
 */
function handleResize() {
    const oldWidth = width;
    const oldHeight = height;

    // Get new CSS dimensions
    width = container.clientWidth;
    height = container.clientHeight;
    dpr = window.devicePixelRatio || 1;

    // Update canvas internal resolution
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Recalculate Metrics based on new size
    const minDim = Math.min(width, height);
    metrics.fontSize = Math.max(12, minDim * 0.025); // ~2.5% of min dimension
    metrics.padding = width * 0.05; // 5% side padding
    metrics.gap = Math.max(2, width * 0.015); // Dynamic gap
    metrics.baseline = height * 0.4;
    metrics.lineWidth = Math.max(1, minDim * 0.003);

    // Re-create pattern on resize
    createDitherPattern();

    // If objects exist, rescale their coordinates
    if (oldWidth && oldHeight && (tasks.length > 0 || ghosts.length > 0)) {
        const scaleX = width / oldWidth;
        const scaleY = height / oldHeight;

        tasks.forEach(t => t.rescale(scaleX, scaleY));
        ghosts.forEach(g => g.rescale(scaleX, scaleY));
    } else if (!isRunning && tasks.length === 0) {
        // Initial idle state, re-log if significant change
        // log("VIEWPORT UPDATED: " + width + "x" + height);
    }

    drawFrame();
}

function log(msg, highlight = false) {
    const div = document.createElement('div');
    div.className = 'log-entry';
    div.innerHTML = `> ${msg}`;
    if(highlight) div.classList.add('log-highlight');
    logContainer.appendChild(div);
    logContainer.scrollTop = logContainer.scrollHeight;
}

// --- CORE CLASSES ---

class Task {
    constructor(val, index, total) {
        this.value = val;
        this.id = Math.random().toString(36).substr(2, 5);
        this.isHighlight = false;
        
        // Initial Geometry calculation
        this.calculateGeometry(index, total);
        
        this.x = this.targetX;
        this.y = (height * 0.4) - this.h;
    }

    calculateGeometry(index, total) {
        // Defines the ideal layout logic
        const availableWidth = width - (metrics.padding * 2);
        const blockWidth = (availableWidth / total) - metrics.gap;
        const maxBarHeight = height * 0.3;

        this.w = blockWidth;
        // Height proportional to value (max value ~15)
        this.h = (this.value / 15) * maxBarHeight + (height * 0.05); 
        this.targetX = metrics.padding + index * (blockWidth + metrics.gap);
    }

    // Called during resize to map old pixel coords to new
    rescale(sx, sy) {
        this.x *= sx;
        this.y *= sy;
        this.w *= sx;
        this.h *= sy;
        this.targetX *= sx;
    }

    draw(ctx) {
        ctx.lineWidth = metrics.lineWidth;
        
        // Outline
        ctx.strokeStyle = COLORS.fg;
        ctx.strokeRect(this.x, this.y, this.w, this.h);
        
        // Fill
        if (this.isHighlight) {
            ctx.fillStyle = COLORS.fg;
            ctx.fillRect(this.x, this.y, this.w, this.h);
            
            // Text Color Inverted
            ctx.fillStyle = COLORS.bg;
            ctx.font = `bold ${metrics.fontSize}px Courier New`;
            ctx.textAlign = 'center';
            // Adjust text Y based on font size
            ctx.fillText(this.value, this.x + this.w/2, this.y + this.h/2 + (metrics.fontSize/3));
        } else {
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(this.x, this.y, this.w, this.h);
            
            // Text Color Normal
            ctx.fillStyle = COLORS.fg;
            ctx.font = `bold ${metrics.fontSize}px Courier New`;
            ctx.textAlign = 'center';
            ctx.fillText(this.value, this.x + this.w/2, this.y + this.h/2 + (metrics.fontSize/3));
        }
    }
}

class Ghost {
    constructor(parentTask, targetX, targetY) {
        this.x = parentTask.x;
        this.y = parentTask.y;
        this.w = parentTask.w;
        this.h = parentTask.h;
        this.targetX = targetX;
        this.targetY = targetY;
        this.arrived = false;
    }
    
    update() {
        if (this.arrived) return;
        
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        
        this.x += dx * 0.1 * ANIMATION_SPEED;
        this.y += dy * 0.1 * ANIMATION_SPEED;
        
        // Check arrival (using dynamic threshold based on width)
        if (Math.abs(dx) < 1 && Math.abs(dy) < 1) {
            this.x = this.targetX;
            this.y = this.targetY;
            this.arrived = true;
        }
    }

    rescale(sx, sy) {
        this.x *= sx;
        this.y *= sy;
        this.w *= sx;
        this.h *= sy;
        this.targetX *= sx;
        this.targetY *= sy;
    }

    draw(ctx) {
        ctx.save();
        ctx.fillStyle = ditherPattern;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        
        ctx.strokeStyle = COLORS.fg;
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 4]); // Dashed line
        ctx.strokeRect(this.x, this.y, this.w, this.h);
        ctx.restore();
    }
}

// --- LOGIC & ANIMATION CONTROL ---

async function startSimulation() {
    if (isRunning) return;
    isRunning = true;
    runBtn.disabled = true;
    accumulator = 0;
    logContainer.innerHTML = '';
    ghosts = [];
    
    // 1. GENERATE
    log("INITIALIZING TASK QUEUE...");
    tasks = [];
    let values = [];
    for(let i=0; i<TASK_COUNT; i++) {
        values.push(Math.floor(Math.random() * 10) + 2);
    }
    
    // Create Initial Tasks
    values.forEach((v, i) => tasks.push(new Task(v, i, TASK_COUNT)));
    drawFrame();
    await wait(800);

    // 2. SORT
    log("EXECUTING GREEDY SORT (ASCENDING)...", true);
    
    // Logic: Sort array to find new order
    tasks.sort((a,b) => a.value - b.value);
    
    // Re-calculate target slots based on sorted indices
    // We re-run the layout logic, but only apply it to targetX
    const availableWidth = width - (metrics.padding * 2);
    const blockWidth = (availableWidth / TASK_COUNT) - metrics.gap;

    tasks.forEach((t, i) => {
        t.targetX = metrics.padding + i * (blockWidth + metrics.gap);
    });

    await animateMovement();
    log("SORT COMPLETE. O(N log N).");
    await wait(500);

    // 3. CALCULATION & PROJECTION
    log("INITIATING WAIT_TIME PROJECTION...", true);
    
    // Start stacking ghosts below the timeline
    // Baseline + some margin
    const stackStartY = metrics.baseline + (height * 0.05); 

    for (let i = 0; i < tasks.length; i++) {
        let task = tasks[i];
        task.isHighlight = true;
        drawFrame();
        
        let remaining = tasks.length - 1 - i;
        
        if (remaining > 0) {
            log(`Task [${task.value}]: Delays ${remaining} subsequent tasks.`);
            
            let currentGhosts = [];
            
            for (let j = 1; j <= remaining; j++) {
                let targetTaskIndex = i + j;
                let targetTask = tasks[targetTaskIndex];
                
                // Determine Stack Height dynamically
                // Count how many ghosts target this specific task's X slot
                let existingStackCount = ghosts.filter(g => Math.abs(g.targetX - targetTask.targetX) < (blockWidth/2)).length;
                
                let targetY = stackStartY + (existingStackCount * (task.h + (height * 0.01))); 
                
                let g = new Ghost(task, targetTask.targetX, targetY);
                ghosts.push(g);
                currentGhosts.push(g);
            }
            
            await animateGhosts(currentGhosts);
            
            let contribution = task.value * remaining;
            accumulator += contribution;
            log(`> WAIT TIME INCREASE: +${contribution}`);
            
        } else {
            log(`Task [${task.value}] is last. Zero impact.`);
        }
        
        task.isHighlight = false;
        await wait(250);
    }

    log("SIMULATION COMPLETE.", true);
    log(`MIN TOTAL WAIT: ${accumulator}`);
    isRunning = false;
    runBtn.disabled = false;
    drawFrame();
}

// --- ANIMATION HELPERS ---

function animateMovement() {
    return new Promise(resolve => {
        function loop() {
            let moving = false;
            tasks.forEach(t => {
                let dx = t.targetX - t.x;
                // Proportional speed
                t.x += dx * 0.15 * ANIMATION_SPEED;
                
                // Dynamic snap threshold
                if(Math.abs(dx) > width * 0.001) moving = true;
                else t.x = t.targetX;
            });
            
            drawFrame();
            if(moving) requestAnimationFrame(loop);
            else resolve();
        }
        loop();
    });
}

function animateGhosts(activeGhosts) {
    return new Promise(resolve => {
        function loop() {
            let moving = false;
            activeGhosts.forEach(g => {
                g.update();
                if(!g.arrived) moving = true;
            });
            
            drawFrame();
            if(moving) requestAnimationFrame(loop);
            else resolve();
        }
        loop();
    });
}

function drawFrame() {
    if(!ctx) return;

    // Clear Screen
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, width, height);
    
    // Draw Accumulator (Background Watermark)
    ctx.save();
    // Font size relative to width (approx 20vw equivalent)
    ctx.font = `bold ${width * 0.2}px Courier New`;
    ctx.fillStyle = '#001a00'; 
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(accumulator, width/2, height/2 + (height*0.1));
    ctx.restore();

    // Draw Timeline Line
    ctx.beginPath();
    ctx.strokeStyle = COLORS.dim;
    ctx.lineWidth = Math.max(2, metrics.lineWidth * 2);
    ctx.moveTo(0, metrics.baseline);
    ctx.lineTo(width, metrics.baseline);
    ctx.stroke();

    // Draw Objects
    ghosts.forEach(g => g.draw(ctx));
    tasks.forEach(t => t.draw(ctx));
    
    // Draw Label Footer inside Canvas
    ctx.fillStyle = COLORS.fg;
    ctx.font = `${metrics.fontSize * 1.2}px Courier New`;
    ctx.textAlign = 'right';
    const margin = metrics.fontSize;
    ctx.fillText(`TOTAL_WAIT: ${accumulator}`, width - margin, height - margin);
}

function wait(ms) {
    return new Promise(r => setTimeout(r, ms));
}

// Start
init();

</script>
</body>
</html>