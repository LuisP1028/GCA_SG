<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BOYER-MOORE: BATTLE OF ATTRITION</title>
    <style>
        :root {
            --bg-color: #050505;
            --fg-color: #00FF41;
            --dim-color: #003b0f;
            
            /* Responsive Typography */
            --font-xs: clamp(0.7rem, 1.5vw, 0.9rem);
            --font-sm: clamp(0.8rem, 2vw, 1rem);
            --font-md: clamp(1rem, 3vw, 1.5rem);
            --font-lg: clamp(1.2rem, 4vw, 2rem);
            
            --spacing: clamp(10px, 2vw, 20px);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            color: var(--fg-color);
            user-select: none;
            -webkit-user-select: none;
        }

        /* UI Overlay - Using Grid for layout structure */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: grid;
            grid-template-rows: auto 1fr auto;
            padding: 0;
        }

        .header {
            padding: var(--spacing);
            background: linear-gradient(180deg, rgba(5,5,5,0.95) 0%, rgba(5,5,5,0) 100%);
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing);
        }

        .title-block h1 {
            margin: 0;
            font-size: var(--font-lg);
            line-height: 1;
        }
        .title-block small {
            font-size: var(--font-xs);
            opacity: 0.7;
            display: block;
            margin-top: 5px;
        }

        .controls {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--fg-color);
            padding: calc(var(--spacing) / 2);
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        button {
            background: var(--fg-color);
            color: var(--bg-color);
            border: none;
            font-family: inherit;
            font-weight: bold;
            font-size: var(--font-sm);
            padding: 0.5em 1em;
            cursor: pointer;
            text-transform: uppercase;
            white-space: nowrap;
        }

        button:hover {
            background: #fff;
        }

        button:active {
            transform: translateY(2px);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: var(--font-sm);
        }

        input[type="range"] {
            -webkit-appearance: none;
            background: var(--dim-color);
            height: 4px;
            width: 100px;
            max-width: 20vw;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--fg-color);
            cursor: pointer;
        }

        .footer {
            padding: var(--spacing);
            text-align: right;
            opacity: 0.8;
            background: linear-gradient(0deg, rgba(5,5,5,0.95) 0%, rgba(5,5,5,0) 100%);
        }

        #status-readout {
            font-size: var(--font-sm);
            text-shadow: 0 0 5px var(--dim-color);
        }

        /* CRT Overlay Effects */
        #crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 6px 100%;
            opacity: 0.6;
        }
        
        #scanline {
            width: 100%;
            height: 100px;
            z-index: 21;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(0, 255, 65, 0.1) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1;
            position: absolute;
            bottom: 100%;
            animation: scanline 10s linear infinite;
            pointer-events: none;
        }

        @keyframes scanline {
            0% { bottom: 100%; }
            100% { bottom: -100px; }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Mobile Adjustments */
        @media (max-width: 600px) {
            .header {
                flex-direction: column;
                align-items: flex-start;
            }
            .controls {
                width: 100%;
                justify-content: space-between;
                box-sizing: border-box;
            }
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="header">
            <div class="title-block">
                <h1>BOYER-MOORE</h1>
                <small>VOTING_ALGORITHM // VISUALIZER_v1.1</small>
            </div>
            <div class="controls">
                <div class="slider-container">
                    <label>SPEED</label>
                    <input type="range" id="speedSlider" min="1" max="10" value="3">
                </div>
                <button id="resetBtn">RESET</button>
            </div>
        </div>
        <!-- Spacer -->
        <div></div> 
        <div class="footer">
            <div id="status-readout">SYSTEM_READY</div>
        </div>
    </div>

    <div id="crt-overlay"></div>
    <div id="scanline"></div>
    <canvas id="mainCanvas"></canvas>

<script>
/**
 * 1-BIT DITHERPUNK VISUALIZATION ENGINE
 * V.1.1 Responsive Update
 */

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const speedSlider = document.getElementById('speedSlider');
const resetBtn = document.getElementById('resetBtn');
const statusReadout = document.getElementById('status-readout');

// --- CONSTANTS & CONFIG ---
const COLORS = {
    BG: '#050505',
    FG: '#00FF41',
    DIM: '#005515',
};

const SHAPES = {
    SQUARE: 0,
    TRIANGLE: 1,
    CIRCLE: 2
};

// Data Generation
const STREAM_LENGTH = 16;
const MAJORITY_SHAPE = SHAPES.SQUARE;

// Animation States
const STATE = {
    SPAWN: 0,
    MOVE_TO_FOCUS: 1,
    CHECK_ZERO: 2,
    MOVE_TO_COMPARE: 3,
    COMPARE_ANIM: 4,
    RESOLVE_MATCH: 5,
    RESOLVE_MISMATCH: 6,
    GRAVEYARD_FALL: 7,
    FINISHED: 8
};

// Global Simulation State
let sim = {
    stream: [],
    candidate: null,
    count: 0,
    processedCount: 0,
    activeItem: null,
    particles: [],
    graveyard: [],
    phase: STATE.SPAWN,
    timer: 0,
    speedMult: 1,
    message: "SYSTEM INITIALIZED",
    history: []
};

// --- RESPONSIVE METRICS ---
// Instead of hardcoded pixels, we calculate metrics based on window size
let metrics = {
    w: 0, // Canvas logical width
    h: 0, // Canvas logical height
    u: 0, // Base Unit (1% of min dimension)
    shapeSize: 0,
    fontSize: 0,
    stroke: 0,
    zones: {}
};

function resize() {
    // 1. Handle High DPI (Retina) Displays
    const dpr = window.devicePixelRatio || 1;
    const cssWidth = window.innerWidth;
    const cssHeight = window.innerHeight;
    
    canvas.width = cssWidth * dpr;
    canvas.height = cssHeight * dpr;
    
    // Scale context to match
    ctx.scale(dpr, dpr);

    // 2. Update Logical Metrics
    metrics.w = cssWidth;
    metrics.h = cssHeight;
    // Define a "Unit" based on the smaller dimension to fit mobile or desktop
    metrics.u = Math.min(cssWidth, cssHeight) / 100;

    // 3. Set derived sizes
    metrics.shapeSize = metrics.u * 5; // Shapes are 5% of screen min-dim
    metrics.fontSize = Math.max(12, metrics.u * 2); 
    metrics.stroke = Math.max(1, metrics.u * 0.25);

    // 4. Define Layout Zones
    metrics.zones = {
        STREAM: { y: 0, h: cssHeight * 0.2 },
        ARENA: { y: cssHeight * 0.2, h: cssHeight * 0.6 },
        GRAVEYARD: { y: cssHeight * 0.8, h: cssHeight * 0.2 },
        
        // Coordinates for key actors
        PODIUM: { x: cssWidth * 0.25, y: cssHeight * 0.55 },
        INTERACTION: { x: cssWidth * 0.5, y: cssHeight * 0.4 },
        STACK: { x: cssWidth * 0.75, y: cssHeight * 0.55 }
    };

    // If active, update position of waiting stream items to match new width
    if (sim.stream.length > 0) {
        sim.stream.forEach((item, i) => {
            if (item.state === 'waiting') {
                // Keep them offscreen or in relative position
                item.x = metrics.w + (i * (metrics.w * 0.08));
                item.y = metrics.zones.STREAM.h / 2;
            }
        });
    }
}

window.addEventListener('resize', resize);
// Initial trigger
resize();

// --- UTILITIES ---

function generateStream() {
    let arr = [];
    for (let i = 0; i < STREAM_LENGTH; i++) {
        if (i % 2 === 0 || Math.random() > 0.6) {
            arr.push(MAJORITY_SHAPE);
        } else {
            arr.push(Math.random() > 0.5 ? SHAPES.TRIANGLE : SHAPES.CIRCLE);
        }
    }
    return arr;
}

function createPattern(color1, color2) {
    const pCanvas = document.createElement('canvas');
    pCanvas.width = 4;
    pCanvas.height = 4;
    const pCtx = pCanvas.getContext('2d');
    pCtx.fillStyle = color1;
    pCtx.fillRect(0,0,4,4);
    pCtx.fillStyle = color2;
    pCtx.fillRect(0,0,2,2);
    pCtx.fillRect(2,2,2,2);
    return ctx.createPattern(pCanvas, 'repeat');
}

let PATTERN_DIM, PATTERN_SOLID;

// --- DRAWING FUNCTIONS ---

function drawShape(type, x, y, size, isFilled = true, color = COLORS.FG) {
    // Regenerate patterns if context was reset (rare but possible on some browsers on resize)
    if(!PATTERN_DIM) {
        PATTERN_DIM = createPattern(COLORS.BG, COLORS.DIM);
        PATTERN_SOLID = COLORS.FG;
    }

    ctx.strokeStyle = color;
    ctx.lineWidth = metrics.stroke;
    ctx.fillStyle = isFilled ? PATTERN_SOLID : PATTERN_DIM;
    
    ctx.beginPath();
    const half = size / 2;
    if (type === SHAPES.SQUARE) {
        ctx.rect(x - half, y - half, size, size);
    } else if (type === SHAPES.CIRCLE) {
        ctx.arc(x, y, half, 0, Math.PI * 2);
    } else if (type === SHAPES.TRIANGLE) {
        // Equilateral calculation for visual balance
        const h = size * (Math.sqrt(3)/2);
        ctx.moveTo(x, y - h/2);
        ctx.lineTo(x + half, y + h/2);
        ctx.lineTo(x - half, y + h/2);
        ctx.closePath();
    }
    
    if (isFilled) ctx.fill();
    ctx.stroke();
}

function drawBlock(x, y, w, h, filled) {
    ctx.fillStyle = filled ? COLORS.FG : COLORS.BG;
    ctx.strokeStyle = COLORS.FG;
    ctx.lineWidth = metrics.stroke;
    ctx.fillRect(x, y, w, h);
    ctx.strokeRect(x, y, w, h);
    
    if(filled) {
        const border = metrics.stroke * 2;
        ctx.fillStyle = COLORS.BG;
        ctx.fillRect(x + border, y + border, w - (border*2), h - (border*2));
        ctx.fillStyle = PATTERN_DIM; 
        ctx.fillRect(x + border*1.5, y + border*1.5, w - (border*3), h - (border*3));
    }
}

function spawnExplosion(x, y) {
    for(let i=0; i<15; i++) {
        sim.particles.push({
            x: x, 
            y: y,
            vx: (Math.random() - 0.5) * metrics.u * 1.5,
            vy: (Math.random() - 0.5) * metrics.u * 1.5,
            life: 1.0,
            size: Math.random() * (metrics.u * 0.8) + (metrics.u * 0.2)
        });
    }
}

// --- LOGIC & ANIMATION ---

function initSim() {
    // Regenerate patterns just in case
    PATTERN_DIM = createPattern(COLORS.BG, COLORS.DIM);
    PATTERN_SOLID = COLORS.FG;

    sim.stream = generateStream().map((type, i) => ({
        id: i,
        type: type,
        x: metrics.w + (i * (metrics.w * 0.08)), 
        y: metrics.zones.STREAM.h / 2,
        state: 'waiting'
    }));
    
    sim.candidate = null;
    sim.count = 0;
    sim.processedCount = 0;
    sim.activeItem = null;
    sim.history = [];
    sim.graveyard = [];
    sim.particles = [];
    sim.phase = STATE.SPAWN;
    sim.message = "INITIALIZING STREAM...";
    
    statusReadout.innerText = "SYSTEM_READY";
}

function update() {
    const speed = parseFloat(speedSlider.value);
    sim.speedMult = speed;
    sim.timer += 1 * sim.speedMult;

    // Dynamic threshold for "arrival" checks based on screen size
    const snapDist = metrics.u * 0.5; 

    switch (sim.phase) {
        case STATE.SPAWN:
            if (sim.processedCount >= STREAM_LENGTH) {
                sim.phase = STATE.FINISHED;
                return;
            }
            
            sim.activeItem = sim.stream[sim.processedCount];
            sim.activeItem.state = 'active';
            sim.activeItem.targetX = metrics.zones.INTERACTION.x;
            sim.activeItem.targetY = metrics.zones.INTERACTION.y;
            sim.phase = STATE.MOVE_TO_FOCUS;
            sim.message = `FETCHING ELEMENT ${sim.processedCount}`;
            break;

        case STATE.MOVE_TO_FOCUS:
            const dx = sim.activeItem.targetX - sim.activeItem.x;
            const dy = sim.activeItem.targetY - sim.activeItem.y;
            
            // Percentage based movement
            sim.activeItem.x += dx * 0.1 * sim.speedMult;
            sim.activeItem.y += dy * 0.1 * sim.speedMult;
            
            // Move stream
            sim.stream.forEach(item => {
                if (item.state === 'waiting') {
                    // Move relative to width
                    item.x -= (metrics.w * 0.08) * 0.05 * sim.speedMult;
                }
            });

            if (Math.abs(dx) < snapDist && Math.abs(dy) < snapDist) {
                sim.phase = STATE.CHECK_ZERO;
                sim.timer = 0;
            }
            break;

        case STATE.CHECK_ZERO:
            if (sim.timer < 20) break;
            
            if (sim.count === 0) {
                sim.message = "COUNT ZERO -> NEW CANDIDATE";
                sim.candidate = { type: sim.activeItem.type };
                sim.activeItem.targetX = metrics.zones.PODIUM.x;
                sim.activeItem.targetY = metrics.zones.PODIUM.y - (metrics.shapeSize * 1.5);
                
                const pdx = sim.activeItem.targetX - sim.activeItem.x;
                const pdy = sim.activeItem.targetY - sim.activeItem.y;
                sim.activeItem.x += pdx * 0.1 * sim.speedMult;
                sim.activeItem.y += pdy * 0.1 * sim.speedMult;

                if (Math.abs(pdx) < snapDist) {
                    sim.count = 1;
                    sim.history.push({ type: sim.activeItem.type });
                    sim.processedCount++;
                    sim.activeItem = null;
                    sim.phase = STATE.SPAWN;
                }
            } else {
                sim.phase = STATE.MOVE_TO_COMPARE;
            }
            break;

        case STATE.MOVE_TO_COMPARE:
            sim.message = "COMPARING WITH CANDIDATE";
            // Position next to Podium
            const cx = metrics.zones.PODIUM.x + (metrics.shapeSize * 2);
            const cy = metrics.zones.PODIUM.y;
            
            sim.activeItem.x += (cx - sim.activeItem.x) * 0.1 * sim.speedMult;
            sim.activeItem.y += (cy - sim.activeItem.y) * 0.1 * sim.speedMult;
            
            if (Math.abs(cx - sim.activeItem.x) < snapDist) {
                sim.phase = STATE.COMPARE_ANIM;
                sim.timer = 0;
            }
            break;

        case STATE.COMPARE_ANIM:
            if (sim.timer < 30) break;
            
            if (sim.activeItem.type === sim.candidate.type) {
                sim.phase = STATE.RESOLVE_MATCH;
                sim.message = "MATCH -> REINFORCE (+1)";
            } else {
                sim.phase = STATE.RESOLVE_MISMATCH;
                sim.message = "MISMATCH -> ELIMINATE (-1)";
            }
            break;

        case STATE.RESOLVE_MATCH:
            const sx = metrics.zones.STACK.x;
            const sy = metrics.zones.STACK.y - (sim.history.length * (metrics.shapeSize * 0.6));
            
            sim.activeItem.x += (sx - sim.activeItem.x) * 0.15 * sim.speedMult;
            sim.activeItem.y += (sy - sim.activeItem.y) * 0.15 * sim.speedMult;
            
            if (Math.abs(sx - sim.activeItem.x) < snapDist && Math.abs(sy - sim.activeItem.y) < snapDist) {
                sim.count++;
                sim.history.push({ type: sim.candidate.type });
                sim.processedCount++;
                sim.activeItem = null;
                sim.phase = STATE.SPAWN;
            }
            break;

        case STATE.RESOLVE_MISMATCH:
            // Clash point
            const attackX = (metrics.zones.PODIUM.x + metrics.zones.STACK.x) / 2;
            const attackY = metrics.zones.PODIUM.y - (metrics.shapeSize * 1.5);
            
            sim.activeItem.x += (attackX - sim.activeItem.x) * 0.2 * sim.speedMult;
            sim.activeItem.y += (attackY - sim.activeItem.y) * 0.2 * sim.speedMult;
            
            if (Math.abs(attackX - sim.activeItem.x) < (snapDist * 2)) {
                spawnExplosion(attackX, attackY);
                sim.count--;
                const deadStackItem = sim.history.pop();
                
                // Graveyard push
                sim.graveyard.push({ ...sim.activeItem, x: attackX, y: attackY, r: Math.random() });
                if(deadStackItem) {
                    sim.graveyard.push({ ...deadStackItem, x: attackX + metrics.u, y: attackY, r: Math.random() });
                }
                
                sim.activeItem = null;
                sim.processedCount++;
                sim.phase = STATE.GRAVEYARD_FALL;
                sim.timer = 0;
            }
            break;

        case STATE.GRAVEYARD_FALL:
            sim.graveyard.forEach(g => {
                if (g.y < metrics.zones.GRAVEYARD.y + Math.random() * metrics.u * 10) {
                    g.y += metrics.u * 0.5 * sim.speedMult;
                    g.x += Math.sin(g.y * 0.1) * (metrics.u * 0.2);
                }
            });
            if (sim.timer > 20) {
                sim.phase = STATE.SPAWN;
            }
            break;

        case STATE.FINISHED:
            sim.message = "STREAM COMPLETE. SURVIVOR FOUND.";
            break;
    }

    // Particles
    for (let i = sim.particles.length - 1; i >= 0; i--) {
        let p = sim.particles[i];
        p.x += p.vx * sim.speedMult;
        p.y += p.vy * sim.speedMult;
        p.life -= 0.02 * sim.speedMult;
        if (p.life <= 0) sim.particles.splice(i, 1);
    }

    statusReadout.innerText = `PHASE: ${getPhaseName(sim.phase)} // MSG: ${sim.message}`;
}

function getPhaseName(p) {
    return Object.keys(STATE).find(key => STATE[key] === p);
}

function render() {
    if(!ctx || metrics.w === 0) return;

    // Clear
    ctx.fillStyle = COLORS.BG;
    ctx.fillRect(0, 0, metrics.w, metrics.h);

    // Draw Grid Zones
    ctx.strokeStyle = COLORS.DIM;
    ctx.lineWidth = metrics.stroke;
    ctx.setLineDash([metrics.u, metrics.u]);
    
    ctx.beginPath();
    ctx.moveTo(0, metrics.zones.ARENA.y);
    ctx.lineTo(metrics.w, metrics.zones.ARENA.y);
    ctx.moveTo(0, metrics.zones.GRAVEYARD.y);
    ctx.lineTo(metrics.w, metrics.zones.GRAVEYARD.y);
    ctx.stroke();
    
    ctx.setLineDash([]);

    // Labels
    ctx.font = `${metrics.fontSize}px 'Courier New'`;
    ctx.fillStyle = COLORS.DIM;
    ctx.fillText("IN_STREAM", metrics.u * 2, metrics.zones.STREAM.h - metrics.u);
    ctx.fillText("ARENA_LOGIC", metrics.u * 2, metrics.zones.ARENA.y + (metrics.u * 3));
    ctx.fillText("DISCARD_PILE", metrics.u * 2, metrics.zones.GRAVEYARD.y + (metrics.u * 3));

    // Draw Stream
    const size = metrics.shapeSize;
    sim.stream.forEach(item => {
        if (item === sim.activeItem) return;
        if (item.id < sim.processedCount) return;
        drawShape(item.type, item.x, item.y, size, true, COLORS.DIM);
    });

    // Draw Podium Base
    const pX = metrics.zones.PODIUM.x;
    const pY = metrics.zones.PODIUM.y;
    ctx.fillStyle = PATTERN_DIM;
    ctx.fillRect(pX - size, pY + (size/2), size * 2, size * 0.2); 
    
    ctx.fillStyle = COLORS.FG;
    ctx.textAlign = "center";
    ctx.fillText("CANDIDATE", pX, pY + size * 1.5);

    if (sim.candidate && sim.count > 0) {
        ctx.save();
        ctx.shadowColor = COLORS.FG;
        ctx.shadowBlur = metrics.u * 2;
        drawShape(sim.candidate.type, pX, pY - (size*0.2), size * 1.5, false, COLORS.FG);
        ctx.restore();
    } else {
        ctx.fillStyle = COLORS.DIM;
        ctx.fillText("NULL", pX, pY);
    }

    // Draw Stack
    const stackBaseX = metrics.zones.STACK.x;
    const stackBaseY = metrics.zones.STACK.y + size * 0.8;
    
    ctx.fillStyle = COLORS.FG;
    ctx.fillText(`COUNT: ${sim.count}`, stackBaseX, stackBaseY + size);

    sim.history.forEach((histItem, idx) => {
        const blockH = size * 0.6;
        const by = stackBaseY - (idx * blockH);
        drawBlock(stackBaseX - size*0.6, by - blockH, size * 1.2, blockH, true);
    });

    // Active Item
    if (sim.activeItem) {
        drawShape(sim.activeItem.type, sim.activeItem.x, sim.activeItem.y, size, true, COLORS.FG);
    }

    // Particles
    sim.particles.forEach(p => {
        ctx.fillStyle = COLORS.FG;
        ctx.fillRect(p.x, p.y, p.size, p.size);
    });

    // Graveyard
    sim.graveyard.forEach(g => {
        ctx.save();
        ctx.translate(g.x, g.y);
        ctx.rotate(g.r);
        ctx.globalAlpha = 0.3;
        drawShape(g.type, 0, 0, size * 0.8, false, COLORS.DIM);
        ctx.restore();
    });
}

function loop() {
    update();
    render();
    requestAnimationFrame(loop);
}

// --- BOOT ---
resetBtn.addEventListener('click', initSim);
initSim();
loop();

</script>
</body>
</html>