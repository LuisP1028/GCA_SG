<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Part III: Sorting // Study Guide</title>
<style>
    /* 
       --- STYLE CONFIGURATION --- 
       (Identical to Main Shell)
    */
    :root {
        --bg-color: #000000;
        --text-color: #00ff41;
        --accent-color: #00ff41;
        --dim-color: #003b00;
        --border-color: #00ff41;
        --font-main: 'Courier New', Courier, monospace;
        --font-header: 'Arial Black', Impact, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: var(--font-main);
        line-height: 1.5;
        overflow-x: hidden;
    }

    .dither-layer {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        z-index: -1;
        background-image: radial-gradient(circle, #003b00 1px, transparent 1px);
        background-size: 4px 4px;
        opacity: 0.4;
    }

    .scanlines {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(to bottom, rgba(0, 255, 65, 0), rgba(0, 255, 65, 0) 50%, rgba(0, 20, 0, 0.2) 50%, rgba(0, 20, 0, 0.2));
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 9999;
    }

    .container {
        max-width: 900px;
        width: 100%;
        margin: 0 auto;
        padding: 40px 20px;
        border-left: 2px dashed var(--dim-color);
        border-right: 2px dashed var(--dim-color);
        background-color: rgba(0, 10, 0, 0.9);
        min-height: 100vh;
    }

    h1 {
        font-family: var(--font-header);
        text-transform: uppercase;
        font-size: 2.5rem;
        border-bottom: 5px solid var(--accent-color);
        margin-bottom: 40px;
        color: var(--accent-color);
        text-align: center;
    }

    strong { color: var(--accent-color); text-decoration: underline; }
    em { font-style: normal; color: #50c878; border-bottom: 1px dotted var(--dim-color); }

    /* ACCORDION STYLES */
    details.section {
        margin-bottom: 15px;
        border: 1px solid var(--dim-color);
        background: #050505;
    }

    details.section > summary {
        font-family: var(--font-main);
        font-weight: bold;
        padding: 12px;
        background: #0a0a0a;
        color: var(--text-color);
        cursor: pointer;
        list-style: none;
        border-bottom: 1px solid transparent;
        text-transform: uppercase;
        font-size: 1.1rem;
    }

    details.section > summary:hover { background: var(--dim-color); color: var(--accent-color); }
    details.section[open] > summary {
        border-bottom: 1px solid var(--dim-color);
        background: #0f0f0f;
        color: var(--accent-color);
        text-shadow: 0px 0px 5px var(--accent-color);
    }

    .section-content { padding: 20px; }

    .subsection {
        margin-bottom: 25px;
        border-left: 4px solid var(--dim-color);
        padding-left: 15px;
    }

    .subsection-title {
        background: var(--dim-color);
        color: var(--accent-color);
        padding: 2px 6px;
        font-weight: bold;
        text-transform: uppercase;
        display: inline-block;
        margin-bottom: 10px;
        font-size: 0.9rem;
    }

    p { margin-bottom: 12px; margin-top: 0; text-align: justify; }
    ul { padding-left: 20px; margin-bottom: 15px; }
    li { margin-bottom: 5px; }

    .code-block {
        background: #020a02;
        border: 1px dashed var(--dim-color);
        padding: 10px;
        margin: 10px 0;
        font-family: 'Courier New', monospace;
        color: var(--accent-color);
        overflow-x: auto;
        white-space: pre-wrap;
    }
</style>
</head>
<body>

<div class="dither-layer"></div>
<div class="scanlines"></div>

<div class="container">
    <h1>Part III: Sorting</h1>

    <!-- MAIN CONTENT BUCKET -->
    <div class="part-content">
        
        <!-- ============================================== -->
        <!-- SECTION 1: PARTITIONING & GROUPING -->
        <!-- ============================================== -->
        <details class="section">
            <summary>1. Partitioning & Grouping</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">
                        Partitioning with Many Duplicates
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/partition_sort_dupes.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p><strong>Goal:</strong> Rearrange the list so that all items sharing the same key sit next to each other (PARTITIONING AND SORTING ARRAYS WITH MANY DUPLICATES).</p>
                    <p><strong>Key Definitions:</strong></p>
                    <ul>
                        <li><strong>Frequency Map:</strong> A data structure mapping a Key to the count of its occurrences.</li>
                        <li><strong>Offset Map:</strong> A map tracking the current write index for each Key group.</li>
                        <li><strong>In-Place Permutation:</strong> Rearranging elements within the original memory allocation, minimizing auxiliary space.</li>
                        <li><strong>Cyclic Sort / Routing:</strong> The logic of identifying where an element belongs, swapping it there, and dealing with the element that was displaced.</li>
                        <li><strong>Interactions between maps and pointers: 
                            The Frequency Map is used once initially to calculate partition sizes. These sums determine the starting indices for the Offset Map.
                            The Offset Map functions as dynamic write pointers. During the routing loop, the algorithm reads the item at the current index and queries the Offset Map to find its correct destination. Upon placing an item (via swap or match), you increment that group's value in the Offset Map. This advances the pointer to the next free slot.</li>
                    </ul>
                    <ol>
                        <li><strong>Step 1: The Frequency Pass (Virtual Sectioning).</strong> Iterate through the array once to build the Frequency Map. Calculate the exact size of every group to virtually "reserve" a block of indices.</li>
                        <li><strong>Step 2: The Offset Initialization (Write Heads).</strong> Convert counts into absolute Start Indices to create the Offset Map. This transforms abstract counts into concrete memory addresses (Write Heads).</li>
                        <li><strong>Step 3: The Routing Loop.</strong> Iterate while the Offset Map is not empty.
                            <ul>
                                <li><strong>Select a Source:</strong> Pick a group from the map and look at its current Write Head index.</li>
                                <li><strong>Inspect the Intruder:</strong> Check the item currently sitting at that index.</li>
                                <li><strong>Match:</strong> If the item belongs there, it is correctly placed. Advance the Pointer immediately.</li>
                                <li><strong>Intruder:</strong> If the item is an intruder, consult the map for its correct home. Swap the intruder to that slot. The item displaced moves to your current index to be processed next.</li>
                                <li><strong>Advancing:</strong> Incrementing a group's index in the Offset Map effectively closes that slot. When a group's subarray is full, remove it from the map.</li>
                            </ul>
                        </li>
                    </ol>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Removing Duplicates In-Place
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/dupe_removal_inplace.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>The goal is to filter an array without allocating new memory using the <strong>Two Pointer Technique</strong>.</p>
                    <ol>
                        <li><strong>Lexicographical Grouping (Sorting):</strong> Transform the array so that elements with identical values form contiguous blocks. This step is mandatory to satisfy the "locality" assumption—duplicates must be neighbors.</li>
                        <li><strong>2 Pointer Initialization:</strong> Initialize a <em>write pointer</em> at index 1. We treat the element at index 0 as the "anchor" (the first unique item is always valid). Initialize a <em>read pointer</em> to iterate through the list.</li>
                        <li><strong>Linear Traversal:</strong> Iterate through the array starting from index 1 using the read pointer.</li>
                        <li><strong>Conditional Overwrite:</strong> Compare the read pointer’s value against the last confirmed unique item (under the write pointer).
                            <ul>
                                <li>If the item is <strong>different</strong>, it is a new unique name. Overwrite <code>A[write]</code> with the read value and increment the write pointer.</li>
                                <li>If the item is the <strong>same</strong>, it is a duplicate. Ignore it (do not increment the write pointer).</li>
                            </ul>
                        </li>
                        <li><strong>Truncation:</strong> After the loop, the valid dataset exists from <code>A[0]</code> to the write index position. Delete the space from the write index to the end of the array to remove the obsolete buffer.</li>
                    </ol>
                </div>

            </div>
        </details>

        <!-- ============================================== -->
        <!-- SECTION 2: INTERVAL MANAGEMENT -->
        <!-- ============================================== -->
        <details class="section">
            <summary>2. Interval Management</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">
                        Union of Intervals (Sort & Sweep)
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/interval_union.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>The computation of the union of intervals is optimized by converting a complex comparison problem into a linear "stream" of events. Instead of comparing every interval against every other interval (which is slow), we arrange them in a specific order so we only have to look at one at a time.</p>
                
                    <p><strong>Standardize:</strong> Convert all inputs into objects that track the numeric value and the "closed/open" status.</p>
                
                    <p><strong>Sort (The Critical Step):</strong> Arrange the intervals chronologically.</p>
                    <ul>
                        <li><strong>Primary Sort:</strong> Sort all intervals by their Left Endpoint value (ascending).</li>
                        <li><strong>Secondary Sort:</strong> If start times are equal, put <em>Closed</em> left endpoints before <em>Open</em> right endpoints. This ensures we catch overlaps immediately.</li>
                    </ul>
                
                    <p><strong>Sweep and Merge:</strong> Once sorted, we perform a single pass (a "sweep") through the list. We maintain one <em>Active Interval</em> and compare it against the <em>Next Interval</em>.</p>
                
                    <p><strong>The Decision Logic:</strong> For every Next Interval in the list, we check its relationship to the Active Interval:</p>
                    <ul>
                        <li><strong>Gap:</strong> If the next interval starts strictly after current interval ends, the chain is broken. Save Active to your results. Next becomes the new Active.</li>
                        <li><strong>Merge:</strong> If they touch or overlap, absorb Next. Extend the current interval's right endpoint to whichever value is higher (new interval, or old). If the values are equal, keep the Closed endpoint to ensure the number is included.</li>
                    </ul>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Merging Intervals (Event Based)
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/interval_merge.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                
                    <p style="font-size: 0.9em; color: #666; margin-bottom: 1em;">
                        <strong>Concepts:</strong> Disjoint (non-overlapping), Union (combining sets), Closed Interval (inclusive endpoints <code>[a,b]</code>), Total Ordering (sorted data).
                    </p>
                
                    <p><strong>Phase 1: Skip Non-Overlapping (Left)</strong></p>
                    <p>Iterate through the existing intervals.</p>
                    <ul>
                        <li><strong>Logic:</strong> If the current interval’s right endpoint is strictly less than the <code>new_interval</code>'s left endpoint, they do not touch.</li>
                        <li><strong>Action:</strong> Append the current interval to the result list unchanged.</li>
                        <li><strong>Status:</strong> We are to the "left" of the insertion zone.</li>
                    </ul>
                
                    <p><strong>Phase 2: Merge Overlapping (The Buffer)</strong></p>
                    <ul>
                        <li><strong>Logic:</strong> If the current interval starts before the new one ends, they overlap.</li>
                        <li><strong>Action:</strong> Do not append yet. Instead, mutate the <code>new_interval</code> to represent the Union of itself and the current interval.
                            <br><code>New Left = min(new_interval.left, current.left)</code>
                            <br><code>New Right = max(new_interval.right, current.right)</code>
                        </li>
                        <li><strong>Note:</strong> <code>new_interval</code> is held in a temporary variable until it is done growing.</li>
                    </ul>
                
                    <p><strong>Phase 3: Finalize (Flush)</strong></p>
                    <p>Once the loop encounters an interval that starts after the <code>new_interval</code> ends, the <code>new_interval</code> has stopped growing.</p>
                    <ul>
                        <li><strong>Action:</strong>
                            <ul>
                                <li>Append the accumulated <code>new_interval</code>.</li>
                                <li>Append the remainder.</li>
                            </ul>
                        </li>
                        <li><strong>Final Output:</strong> A sorted, disjoint array of intervals representing the union.</li>
                    </ul>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Interval Overlap / Concurrency
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/max_concurrency.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>The goal is to find the maximum number of events that overlap at any single moment (peak concurrency).</p>
                    <p><strong>The How:</strong></p>
                    <ul>
                        <li><strong>Identify Key Moments:</strong> For each event (which has a start and end time), mark two crucial points in time: its start and its end. Think of these as "events begin" and "events end" markers.</li>
                        <li><strong>Create a Timeline of Markers:</strong> Collect all these start and end markers from all events.</li>
                        <li><strong>Order the Markers:</strong> Sort these markers chronologically.</li>
                        <li><strong>Handle Simultaneous Events [Tie Breaker]:</strong> Process the start of Event B <em>before</em> the end of Event A. This ensures we correctly count both events as overlapping at that precise moment for our maximum count.</li>
                        <li><strong>Sweep through Time:</strong> Track simultaneous events with a variable. Track how many events are currently active as you loop; go up by 1 for every 'Start' and down by 1 for every 'End' you encounter.</li>
                        <li><strong>Track the Peak:</strong> As we sweep and update the counter, we also keep a separate record of the highest value the counter ever reached.</li>
                    </ul>
                    <p><strong>The Result:</strong> The highest value this counter ever attained is the answer. It represents the peak number of events that were simultaneously active at any single point in time.</p>
                </div>

            </div>
        </details>

        <!-- ============================================== -->
        <!-- SECTION 3: MERGING & CONSTRUCTIVE -->
        <!-- ============================================== -->
        <details class="section">
            <summary>3. Merging & Constructive</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">
                        Merge Two Sorted Arrays
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'merge_sorted_arr.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p><strong>Strategy:</strong> Three Pointers (Tail A, Tail B, Write).</p>
                    <p><strong>The Trick:</strong> Start filling from the <strong>back</strong> (end of the buffer) to avoid shifting. Compare <code>A[tail]</code> vs <code>B[tail]</code>, place the larger one at <code>A[write]</code>, and decrement pointers.</p>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Set Intersection
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/intersection.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>Find common elements of two sorted arrays.</p>
                    <p><strong>Simultaneous Traversal:</strong></p>
                    <ul>
                        <li><strong>Match:</strong> Check for duplicates (is it same as last added?). If unique, add to result. Increment BOTH pointers.</li>
                        <li><strong>Mismatch:</strong> Increment the pointer of the <em>smaller</em> value to catch up.</li>
                    </ul>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Smallest Nonconstructible Value
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/smallest_impossible_val.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                        <button class="eye-btn" style="border-color: orange; color: orange;" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/GAP.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>Find the smallest positive integer that cannot be formed as the sum of a subset.</p>
                    <ol>
                        <li><strong

        <!-- ============================================== -->
        <!-- SECTION 4: SORTING THEORY -->
        <!-- ============================================== -->
        <details class="section">
            <summary>4. Sorting Theory</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">Concepts</span>
                    <p><strong>Stable Sorting:</strong> Preserves the relative order of elements with equal keys.</p>
                    <p><strong>Radix Sort:</strong> Sorts integers by processing individual digits into buckets. Often linear time.</p>
                    <p><strong>Heap Basics:</strong> Max-heap gives O(log n) access to largest item. Useful for priority queues.</p>
                </div>

            </div>
        </details>

    </div>
</div>

</body>
</html>