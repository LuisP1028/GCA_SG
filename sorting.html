<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Part III: Sorting // Study Guide</title>
<style>
    /* 
       --- STYLE CONFIGURATION --- 
       (Identical to Main Shell)
    */
    :root {
        --bg-color: #000000;
        --text-color: #00ff41;
        --accent-color: #00ff41;
        --dim-color: #003b00;
        --border-color: #00ff41;
        --font-main: 'Courier New', Courier, monospace;
        --font-header: 'Arial Black', Impact, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: var(--font-main);
        line-height: 1.5;
        overflow-x: hidden;
    }

    .dither-layer {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        z-index: -1;
        background-image: radial-gradient(circle, #003b00 1px, transparent 1px);
        background-size: 4px 4px;
        opacity: 0.4;
    }

    .scanlines {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(to bottom, rgba(0, 255, 65, 0), rgba(0, 255, 65, 0) 50%, rgba(0, 20, 0, 0.2) 50%, rgba(0, 20, 0, 0.2));
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 9999;
    }

    .container {
        max-width: 900px;
        width: 100%;
        margin: 0 auto;
        padding: 40px 20px;
        border-left: 2px dashed var(--dim-color);
        border-right: 2px dashed var(--dim-color);
        background-color: rgba(0, 10, 0, 0.9);
        min-height: 100vh;
    }

    h1 {
        font-family: var(--font-header);
        text-transform: uppercase;
        font-size: 2.5rem;
        border-bottom: 5px solid var(--accent-color);
        margin-bottom: 40px;
        color: var(--accent-color);
        text-align: center;
    }

    strong { color: var(--accent-color); text-decoration: underline; }
    em { font-style: normal; color: #50c878; border-bottom: 1px dotted var(--dim-color); }

    /* ACCORDION STYLES */
    details.section {
        margin-bottom: 15px;
        border: 1px solid var(--dim-color);
        background: #050505;
    }

    details.section > summary {
        font-family: var(--font-main);
        font-weight: bold;
        padding: 12px;
        background: #0a0a0a;
        color: var(--text-color);
        cursor: pointer;
        list-style: none;
        border-bottom: 1px solid transparent;
        text-transform: uppercase;
        font-size: 1.1rem;
    }

    details.section > summary:hover { background: var(--dim-color); color: var(--accent-color); }
    details.section[open] > summary {
        border-bottom: 1px solid var(--dim-color);
        background: #0f0f0f;
        color: var(--accent-color);
        text-shadow: 0px 0px 5px var(--accent-color);
    }

    .section-content { padding: 20px; }

    .subsection {
        margin-bottom: 25px;
        border-left: 4px solid var(--dim-color);
        padding-left: 15px;
    }

    .subsection-title {
        background: var(--dim-color);
        color: var(--accent-color);
        padding: 2px 6px;
        font-weight: bold;
        text-transform: uppercase;
        display: inline-block;
        margin-bottom: 10px;
        font-size: 0.9rem;
    }

    p { margin-bottom: 12px; margin-top: 0; text-align: justify; }
    ul { padding-left: 20px; margin-bottom: 15px; }
    li { margin-bottom: 5px; }

    .code-block {
        background: #020a02;
        border: 1px dashed var(--dim-color);
        padding: 10px;
        margin: 10px 0;
        font-family: 'Courier New', monospace;
        color: var(--accent-color);
        overflow-x: auto;
        white-space: pre-wrap;
    }
</style>
</head>
<body>

<div class="dither-layer"></div>
<div class="scanlines"></div>

<div class="container">
    <h1>Part III: Sorting</h1>

    <!-- MAIN CONTENT BUCKET -->
    <div class="part-content">
        
        <!-- ============================================== -->
        <!-- SECTION 1: PARTITIONING & GROUPING -->
        <!-- ============================================== -->
        <details class="section">
            <summary>1. Partitioning & Grouping</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">
                        Partitioning with Many Duplicates
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/partition_sort_dupes.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p><strong>Goal:</strong> Rearrange the list so that all items sharing the same key sit next to each other.</p>
                    <p><strong>Key Definitions:</strong></p>
                    <ul>
                        <li><strong>Frequency Map:</strong> A data structure mapping a Key to the count of its occurrences.</li>
                        <li><strong>Offset Map:</strong> A map tracking the current write index for each Key group.</li>
                        <li><strong>In-Place Permutation:</strong> Rearranging elements within the original memory allocation, minimizing auxiliary space.</li>
                        <li><strong>Cyclic Sort / Routing:</strong> The logic of identifying where an element belongs, swapping it there, and dealing with the element that was displaced.</li>
                        <li><strong>Interactions between maps and pointers: 
                            The Frequency Map is used once initially to calculate partition sizes. These sums determine the starting indices for the Offset Map.
                            The Offset Map functions as dynamic write pointers. During the routing loop, the algorithm reads the item at the current index and queries the Offset Map to find its correct destination. Upon placing an item (via swap or match), you increment that group's value in the Offset Map. This advances the pointer to the next free slot.</li>
                    </ul>
                    <ol>
                        <li><strong>Step 1: The Frequency Counter.</strong> Iterate through the array once to build the Frequency Map. Calculate the exact size of every group to virtually "reserve"a partition.</li>
                        <li><strong>Step 2: The Offset Map</strong> Convert counts into absolute Start Indices to create starting indices for each partition, giving write heads context.</li>
                        <li><strong>Step 3: The Routing Loop.</strong> Iterate while the Offset Map is not empty.
                            <ul>
                                <li><strong>Select a Source:</strong> Pick a group from the map and look at its current Write Head index.</li>
                                <li><strong>Inspect the Intruder:</strong> Check the item currently sitting at that index.</li>
                                <li><strong>Match:</strong> If the item belongs there, it is correctly placed. Advance the Pointer immediately.</li>
                                <li><strong>Intruder:</strong> If the item is an intruder, consult the map for its correct home. Swap the intruder to that slot. The item displaced moves to your current index to be processed next.</li>
                                <li><strong>Advancing:</strong> Incrementing a group's index in the Offset Map effectively closes that slot. When a group's subarray is full, remove it from the map.</li>
                            </ul>
                        </li>
                    </ol>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Removing Duplicates In-Place
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/dupe_removal_inplace.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>The goal is to filter an array without allocating new memory using the <strong>Two Pointer Technique</strong>.</p>
                    <ol>
                        <li><strong>Lexicographical Grouping (Sorting):</strong> Transform the array so that it's lexicographically sorted.</li>
                        <li><strong>2 Pointer Initialization:</strong> Initialize a <em>write pointer</em> at index 1. We treat the element at index 0 as the "anchor" (the first unique item is always valid). Initialize a <em>read pointer</em> to iterate through the list.</li>
                        <li><strong>Linear Traversal:</strong> Iterate through the array.</li>
                        <li><strong>Conditional Overwrite:</strong> Compare the read pointer’s value against the last confirmed unique item (under the write pointer).
                            <ul>
                                <li>If the item is <strong>different</strong>, it is a new unique name. Overwrite <code>A[write]</code> with the read value and increment the write pointer.</li>
                                <li>If the item is the <strong>same</strong>, it is a duplicate. Ignore it (do not increment the write pointer).</li>
                            </ul>
                        </li>
                        <li><strong>Truncation:</strong> After the loop, the valid dataset exists from <code>A[0]</code> to the write index position. Delete the space from the write index to the end of the array to remove the obsolete buffer.</li>
                    </ol>
                </div>

            </div>
        </details>

        <!-- ============================================== -->
        <!-- SECTION 2: INTERVAL MANAGEMENT -->
        <!-- ============================================== -->
        <details class="section">
            <summary>2. Interval Management</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">
                        Union of Intervals (Sort & Sweep)
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/interval_union.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>The computation of the union of intervals is optimized by converting a complex comparison problem into a linear "stream" of events. Instead of comparing every interval against every other interval (which is slow), we arrange them in a specific order so we only have to look at one at a time.</p>
                
                    <p><strong>Standardize:</strong> Convert all inputs into objects that track the numeric value and the "closed/open" status.</p>
                
                    <p><strong>Sort (The Critical Step):</strong> Arrange the intervals chronologically.</p>
                    <ul>
                        <li><strong>Primary Sort:</strong> Sort all intervals by their Left Endpoint value (ascending).</li>
                        <li><strong>Secondary Sort:</strong> If start times are equal, put <em>Closed</em> left endpoints before <em>Open</em> right endpoints. This ensures we catch overlaps immediately.</li>
                    </ul>
                
                    <p><strong>Sweep and Merge:</strong> Once sorted, we perform a single pass (a "sweep") through the list. We maintain one <em>Active Interval</em> and compare it against the <em>Next Interval</em>.</p>
                
                    <p><strong>The Decision Logic:</strong> For every Next Interval in the list, we check its relationship to the Active Interval:</p>
                    <ul>
                        <li><strong>Gap:</strong> If the next interval starts strictly after current interval ends, the chain is broken. Save Active to your results. Next becomes the new Active.</li>
                        <li><strong>Merge:</strong> If they touch or overlap, absorb Next. Extend the current interval's right endpoint to whichever value is higher (new interval, or old). If the values are equal, keep the Closed endpoint to ensure the number is included.</li>
                    </ul>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Inserting Intervals (Merging)
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/interval_merge.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                
                    
                    
                </div>
                
                    <p><strong>Phase 1: Skip Non-Overlapping (Left)</strong></p>
                    <p>Iterate through the existing intervals.</p>
                    <ul>
                        <li><strong>Logic:</strong> If the current interval’s right endpoint is strictly less than the <code>new_interval</code>'s left endpoint, they do not touch.</li>
                        <li><strong>Action:</strong> Append the current interval to the result list unchanged.</li>
                        <li><strong>Status:</strong> We are to the "left" of the insertion zone.</li>
                    </ul>
                
                    <p><strong>Phase 2: Merge Overlapping (The Buffer)</strong></p>
                    <ul>
                        <li><strong>Logic:</strong> If the current interval starts before the new one ends, they overlap.</li>
                        <li><strong>Action:</strong> Do not append yet. Instead, mutate the <code>new_interval</code> to represent the Union of itself and the current interval.
                            <br><code>New Left = min(new_interval.left, current.left)</code>
                            <br><code>New Right = max(new_interval.right, current.right)</code>
                        </li>
                        <li><strong>Note:</strong> <code>new_interval</code> is held in a temporary variable until it is done growing.</li>
                    </ul>
                
                    <p><strong>Phase 3: Finalize (Flush)</strong></p>
                    <p>Once the loop encounters an interval that starts after the <code>new_interval</code> ends, the <code>new_interval</code> has stopped growing.</p>
                    <ul>
                        <li><strong>Action:</strong>
                            <ul>
                                <li>Append the accumulated <code>new_interval</code>.</li>
                                <li>Append the remainder.</li>
                            </ul>
                        </li>
                        <li><strong>Final Output:</strong> A sorted, disjoint array of intervals representing the union.</li>
                    </ul>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Interval Overlap / Concurrency
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/max_concurrency.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>The goal is to find the maximum number of events that overlap at any single moment (peak concurrency).</p>
                    <p><strong>The How:</strong></p>
                    <ul>
                        <li><strong>Identify Key Moments:</strong> For each event (which has a start and end time), mark two crucial points in time: its start and its end. Think of these as "events begin" and "events end" markers.</li>
                        <li><strong>Create a Timeline of Markers:</strong> Collect all these start and end markers from all events.</li>
                        <li><strong>Order the Markers:</strong> Sort these markers chronologically.</li>
                        <li><strong>Handle Simultaneous Events [Tie Breaker]:</strong>  If one event starts exactly when another ends, handle the "Start" first. This pushes your counter up before it goes down, ensuring you count both events as active at that specific moment so you don't miss the peak overlap.</li>
                        <li><strong>Sweep through Time:</strong> Walk through your sorted list of time markers from beginning to end. Keep a running tally of active events: add 1 for every "Start" marker you hit and subtract 1 for every "End" marker. This running total shows exactly how many events are happening at any given time.</li>
                        <li><strong>Track the Peak:</strong> As we sweep and update the counter, we also keep a separate record of the highest value the counter ever reached.</li>
                    </ul>
                    <p><strong>The Result:</strong> The highest value this counter ever attained is the answer. It represents the peak number of events that were simultaneously active at any single point in time.</p>
                </div>
            </div>
        </details>

        <!-- ============================================== -->
        <!-- SECTION 3: MERGING & CONSTRUCTIVE -->
        <!-- ============================================== -->
        <details class="section">
            <summary>3. Merging & Constructive</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">
                        Merge Two Sorted Arrays
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/merge_sorted_arr.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p><strong>Strategy:</strong> Three Pointers (Tail A, Tail B, Write).</p>
                    <p><strong>The Trick:</strong> Start filling from the <strong>back</strong> (end of the buffer) to avoid shifting. Compare <code>A[tail]</code> vs <code>B[tail]</code>, place the larger one at <code>A[write]</code>, and decrement pointers.</p>
                    
                    <p style="opacity: 0.8; font-size: 0.9em;">
                        <em><strong>Naive Way (Bad):</strong> Start from the beginning, insert each B element into the right spot in A → lots of shifting → very slow (O(m×n) worst case).</em>
                    </p>
                
                    <h5>The Setup (Arrays and Pointers)</h5>          
               
                    <h5>The How</h5>
                    <ul>
                        <li><strong>Pointer a (Host Tail):</strong> Marks the largest valid number currently inside the Host array.</li>
                        <li><strong>Pointer b (Donor Tail):</strong> Marks the largest number inside the Donor array.</li>
                        <li><strong>Pointer write (The Target):</strong> Marks the final empty slot at the end of the buffer.</li>
                    </ul>
                    
                    <p><strong>The Workflow:</strong></p>
                    <ol>
                        <li><strong>The Comparison:</strong> Evaluate the values at <code>Pointer a</code> and <code>Pointer b</code>. Ask: "Which value is the Global Maximum?"</li>
                        <li><strong>The Placement:</strong> Copy that winner into the target slot at <code>Pointer write</code>.</li>
                        <li>
                            <strong>The Decrement:</strong>
                            <ul>
                                <li>Shift <code>Pointer write</code> one index to the left (preparing the next slot).</li>
                                <li>Shift the winner's pointer (either <code>a</code> or <code>b</code>) one index to the left (moving to the next data point).</li>
                            </ul>
                        </li>
                        <li><strong>Iteration:</strong> Continue this cycle until the Donor array is fully integrated.</li>
                    </ol>
                    
                    <p>
                        <strong>Aerospace Example:</strong> Combining sorted telemetry/time-series data from multiple onboard sensors (flight data recorders, avionics, satellite payloads) for post-flight analysis or real-time health monitoring. Used in flight control systems to merge sorted event queues from redundant sources, ensuring stable & predictable ordering in safety-critical avionics software.
                    </p>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Set Intersection
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/intersection.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>Find common elements of two sorted arrays while filtering out duplicates.</p>
                    
                    <p><strong>Algorithm Steps:</strong></p>
                    <ul>
                        <li><strong>Initialization:</strong> Define two index iterators, <code>i</code> and <code>j</code>, setting both to 0 to reference the start of arrays A and B. Create an empty list for the result.</li>
                        <li><strong>Simultaneous Traversal:</strong> Enter a loop that continues only while both <code>i</code> and <code>j</code> are within the bounds of their respective arrays.</li>
                        <li><strong>Comparison Logic:</strong> In each iteration, compare <code>A[i]</code> and <code>B[j]</code>:
                            <ul>
                                <li><strong>Match (A[i] == B[j]):</strong> Verify if this is a new value (duplicate detection). If unique, append to result. <em>Increment both pointers.</em></li>
                                <li><strong>A[i] &lt; B[j]:</strong> <code>A[i]</code> cannot be in the intersection. Eliminate it by incrementing <code>i</code>.</li>
                                <li><strong>A[i] &gt; B[j]:</strong> <code>B[j]</code> cannot be in the intersection. Eliminate it by incrementing <code>j</code>.</li>
                            </ul>
                        </li>
                        <li><strong>Termination:</strong> When one array is exhausted, return the result. Remaining elements in the non-exhausted array are irrelevant.</li>
                    </ul>
                
                    <p><strong>Duplicate Detection Scenarios:</strong></p>
                    <ul>
                        <li><strong>Scenario 1 (A: 3,3; B: 3,9):</strong> The duplicate check is not strictly used. First 3s match and advance. The second 3 in A is smaller than 9, so it is discarded via standard traversal logic.</li>
                        <li><strong>Scenario 2 (A: 3,3; B: 3,3):</strong> The duplicate check is vital. First 3s match and advance. Second 3s match again; the check sees the value is identical to the previously added one and skips it, ensuring the value appears only once.</li>
                    </ul>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Smallest Nonconstructible Value
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/smallest_impossible_val.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                        <button class="eye-btn" style="border-color: orange; color: orange;" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'sorting/GAP.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>Find the smallest positive integer that cannot be formed as the sum of a subset.</p>
                    <ol>
                        <li><strong>Sort the Input:</strong> Sort the array in ascending order. This ensures we expand our range of constructible values efficiently from the bottom up.</li>
                        <li><strong>Initialize the Invariant:</strong> Set <code>max_constructible</code> to 0. This variable tracks the largest value ensuring continuous values in the range <code>[0, V]</code> are constructible without gaps.</li>
                        <li><strong>Gapping & Expanding:</strong> Iterate through the sorted numbers (let's call the current number <code>i</code>):
                            <ul>
                                <li><strong>Gapping:</strong> If <code>i > max_constructible + 1</code>, we have found a gap. The next number we need (max + 1) cannot be formed.</li>
                                <li><strong>Expanding:</strong> If <code>i &le; max_constructible + 1</code>, update <code>max_constructible</code> to <code>max_constructible + i</code>, extending the continuous range.</li>
                            </ul>
                        </li>
                        <li><strong>Result:</strong> The answer is <code>max_constructible + 1</code>.</li>
                    </ol>
                    <p><em>Use Case: Infrastructure resource allocation (e.g., cutting stock). It helps optimize limited discrete resources to cover continuous ranges of demand sizes efficiently, minimizing gaps or waste.</em></p>
                </div>

        <!-- ============================================== -->
        <!-- SECTION 4: SORTING THEORY -->
        <!-- ============================================== -->
        <details class="section">
            <summary>4. Sorting Theory</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">Concepts</span>
                    <p><strong>Stable Sorting:</strong> Preserves the relative order of elements with equal keys.</p>
                    <p><strong>Radix Sort:</strong> Sorts integers by processing individual digits into buckets. Often linear time.</p>
                    <p><strong>Heap Basics:</strong> Max-heap gives O(log n) access to largest item. Useful for priority queues.</p>
                </div>

            </div>
        </details>

    </div>
</div>

</body>
</html>