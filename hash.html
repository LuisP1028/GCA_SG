<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Part II: Hash Operations // Study Guide</title>
<style>
    /* 
       --- STYLE CONFIGURATION --- 
       (Identical to Main Shell)
    */
    :root {
        --bg-color: #000000;
        --text-color: #00ff41;
        --accent-color: #00ff41;
        --dim-color: #003b00;
        --border-color: #00ff41;
        --font-main: 'Courier New', Courier, monospace;
        --font-header: 'Arial Black', Impact, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: var(--font-main);
        line-height: 1.5;
        overflow-x: hidden;
    }

    .dither-layer {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        z-index: -1;
        background-image: radial-gradient(circle, #003b00 1px, transparent 1px);
        background-size: 4px 4px;
        opacity: 0.4;
    }

    .scanlines {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(to bottom, rgba(0, 255, 65, 0), rgba(0, 255, 65, 0) 50%, rgba(0, 20, 0, 0.2) 50%, rgba(0, 20, 0, 0.2));
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 9999;
    }

    .container {
        max-width: 900px;
        width: 100%;
        margin: 0 auto;
        padding: 40px 20px;
        border-left: 2px dashed var(--dim-color);
        border-right: 2px dashed var(--dim-color);
        background-color: rgba(0, 10, 0, 0.9);
        min-height: 100vh;
    }

    h1 {
        font-family: var(--font-header);
        text-transform: uppercase;
        font-size: 2.5rem;
        border-bottom: 5px solid var(--accent-color);
        margin-bottom: 40px;
        color: var(--accent-color);
        text-align: center;
    }

    strong { color: var(--accent-color); text-decoration: underline; }
    em { font-style: normal; color: #50c878; border-bottom: 1px dotted var(--dim-color); }

    /* ACCORDION STYLES */
    details.section {
        margin-bottom: 15px;
        border: 1px solid var(--dim-color);
        background: #050505;
    }

    details.section > summary {
        font-family: var(--font-main);
        font-weight: bold;
        padding: 12px;
        background: #0a0a0a;
        color: var(--text-color);
        cursor: pointer;
        list-style: none;
        border-bottom: 1px solid transparent;
        text-transform: uppercase;
        font-size: 1.1rem;
    }

    details.section > summary:hover { background: var(--dim-color); color: var(--accent-color); }
    details.section[open] > summary {
        border-bottom: 1px solid var(--dim-color);
        background: #0f0f0f;
        color: var(--accent-color);
        text-shadow: 0px 0px 5px var(--accent-color);
    }

    .section-content { padding: 20px; }

    .subsection {
        margin-bottom: 25px;
        border-left: 4px solid var(--dim-color);
        padding-left: 15px;
    }

    .subsection-title {
        background: var(--dim-color);
        color: var(--accent-color);
        padding: 2px 6px;
        font-weight: bold;
        text-transform: uppercase;
        display: inline-block;
        margin-bottom: 10px;
        font-size: 0.9rem;
    }

    p { margin-bottom: 12px; margin-top: 0; text-align: justify; }
    ul { padding-left: 20px; margin-bottom: 15px; }
    li { margin-bottom: 5px; }

    .code-block {
        background: #020a02;
        border: 1px dashed var(--dim-color);
        padding: 10px;
        margin: 10px 0;
        font-family: 'Courier New', monospace;
        color: var(--accent-color);
        overflow-x: auto;
        white-space: pre-wrap;
    }
</style>
</head>
<body>

<div class="dither-layer"></div>
<div class="scanlines"></div>

<div class="container">
    <h1>Part II: Hash Operations</h1>

    <!-- MAIN CONTENT BUCKET -->
    <div class="part-content">
        
        <!-- ============================================== -->
        <!-- SECTION 1: SLIDING WINDOW & COVERING -->
        <!-- ============================================== -->
        <details class="section">
            <summary>1. Sliding Windows</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">
                        DECOMPOSITION / Sliding window exact multiset matching
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Hash/decomposition.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>
                        Decomposition turns a continuous string into fixed-length tokens. This treats the window as a collection of items, allowing frequency maps to verify that a specific multiset of words is present, regardless of their internal order.</p>
                    <p>Determine window size with: Word count x Word Length </p>
                    <p><strong>The Core Pattern:</strong> Fixed unit size → target multiset → sliding window of exact total size → Slice window into uniform unit, word length sized → compute observed multiset → check exact equality.</p>
                    <ol>
                        <li><strong>Determine the fixed unit size:</strong> Measure the length of each individual element (the "slice size").</li>
                        <li><strong>Build the target frequency map:</strong> Record the exact number of occurrences expected for each distinct element in the required multiset.</li>
                        <li><strong>Slide a fixed-size window:</strong> At every position, partition the window into pieces of the fixed unit size and compare the observed frequency map to the target map.</li>
                        <li><strong>Storage:</strong> If the maps match exactly (same elements, same counts), append the starting position index to the result list.</li>
                    </ol>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Ordered Sequential Covering
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Hash/ordered_seq.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>Given a list of words (paragraph) and an ordered list of distinct keywords, find the shortest contiguous subarray in the paragraph that contains all keywords in the <strong>exact order</strong> they appear.</p>
                    <p><strong>Example:</strong> <code>paragraph = ["apple", "banana", "cat", "apple"]</code>, <code>keywords = ["banana", "apple"]</code></p>
                    <div class="code-block" style="text-align: left;">
1. Setup & Initialization
   Initialize a global minimum tracker to infinity. Create a hashmap to retrieve a keyword’s temporal order (Rank k). Create two arrays: one tracking the index where each keyword was last seen, and another tracking the global chain length between all keywords identified so far.

2. Scan and Identify
   Iterate through the text word by word. If the current word is not in your hashmap, skip it. If it is a keyword, look up its Rank 'k' (0 to m-1) in the hashmap to determine its place in the sequence.

3. Start Chain (First Keyword)
   If the current word is the first keyword in the sequence (Rank 0), set its current chain length to 1. This resets the tracking logic, marking the potential start of a new valid subarray.

4. Extend Chain (Subsequent Keywords)
   If the word has Rank k > 0, check if the preceding keyword (Rank k-1) has a valid chain. If yes, calculate the distance from the previous keyword's last known index to the current index, add it to the previous length, and save it as the new chain length.

5. Update Position
   Record the current index into the latest_index array for keyword "x" (Rank k). This ensures that future distance calculations always reference the most recently discovered instance of this word.

6. Check Completeness
   If the current word is the final keyword in the list and completes a valid chain, compare the total chain length against the global minimum. If this new subarray is shorter, update the global minimum.
                    </div>
                </div>
        </section>

        <div class="subsection">
            <span class="subsection-title">
                Minimum Window Subarray (Unordered)
                <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Hash/slidingwindow.html'; v.classList.add('active');">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                        <circle cx="12" cy="12" r="3"></circle>
                    </svg>
                </button>
            </span>
            <p><strong>Flow:</strong> Expand Right, Shrink Left.</p>
            <ol>
                <li><strong>Initialization:</strong> Create a frequency map of the characters in the target string. Initialize <code>left</code> and <code>right</code> pointers at the start of the source string. Set a counter, <code>remaining_to_cover</code>, of the number of unique characters needed.</li>
                <li><strong>Expand Right:</strong> Move the <code>right</code> pointer forward to add a character to the window. If this character exists in your target map, decrement its count from the frequency map. If the count hits exactly 0, it means you have enough of this specific character; decrement <code>remaining_to_cover</code>. If you hit negative values, it means a surplus in the window for that element.</li>
                <li><strong>Identify Valid Window:</strong> Check the <code>remaining_to_cover</code> counter. If it equals 0, the current window from <code>left</code> to <code>right</code> contains all required characters. Proceed to the shrinking phase to see if you can make this window smaller.</li>
                <li><strong>Shrink Left:</strong> While valid, update the minimum size. Move <code>left</code> forward to eject a character. If it is a target character, increment its count because we have removed a required item from the window, so we must increase the tally of that character needed.</li>
                <li><strong>Break Validity:</strong> If a target character's count rises above 0 after shrinking, the window is no longer valid because it is missing a required character. Increment <code>remaining_to_cover</code>. Stop shrinking and resume expanding to find that missing character again.</li>
                <li><strong>Result Tracking:</strong> You track the result using two variables: the minimum length found so far and the starting index of that window. Whenever you find a valid window that is smaller than your current record, you update these variables with the current window's size and <code>left</code> position. At the end, use the start index and length to extract the final substring.</li>
            </ol>
        </div>

            </div>
        </details>

        <!-- ============================================== -->
        <!-- SECTION 2: SET & FREQUENCY ANALYSIS -->
        <!-- ============================================== -->
        <details class="section">
            <summary>2. Set & Frequency Analysis</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">Maximal Consecutive Integers 
                        <button class="eye-btn" onclick="const v=document.querySelector('.retro-viewport'); v.querySelector('iframe').src='Hash/maximal_consecutives.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>Find the longest consecutive range in a set. </p>
                    <p>If you need the list [1, 2, 3, 4], simply save the start number of the longest chain found. You can then reconstruct the list at the end.</p>
                    <p><strong>Efficient Solution:</strong></p>
                    <ol>
                        <li><strong>Create the Set:</strong> Convert the input array into a Hash Set. This structure allows you to check if a specific number exists in O(1) time. Initialize a variable to zero to track the maximum sequence length found so far.</li>
                        <li><strong>Pick a Seed:</strong> Loop as long as the set is not empty. In each iteration, select and remove (pop) an arbitrary number <em>a</em> from the set. This number will serve as the anchor point to begin searching for a consecutive chain of integers.</li>
                        <li><strong>Expand Left:</strong> Check for <em>a-1</em>. If it is in the set, remove it and move to <em>a-2</em>. Repeat this process, decrementing and removing numbers, until you reach a number that does not exist in the set. The last found number is the lower bound.</li>
                        <li><strong>Expand Right:</strong> Check for <em>a+1</em>. If it is in the set, remove it and move to <em>a+2</em>. Repeat this process, incrementing and removing numbers, until you reach a number that does not exist in the set. The last found number is the upper bound.</li>
                        <li><strong>Measure and Update:</strong> Calculate the size of the sequence found using the boundaries (e.g., Right - Left + 1). Compare this result to your stored maximum length. If the new sequence is longer, update your record. Repeat until the set is empty.</li>
                    </ol>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Min Distance Between Duplicates
                        <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Hash/min_distance.html'; document.querySelector('.retro-viewport').classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>Find the smallest position gap between any two identical elements.</p>
                    <p><strong>Logic:</strong></p>
                    <ul>
                        <li><strong>1. Setup Variables:</strong> Initialize an empty hash map (dictionary) to store numbers and their indices. Create a variable named min_dist and set it to the largest possible number (infinity) to track the best result.</li>
                        <li><strong>2. Start Iteration:</strong> Begin a loop that goes through the array one element at a time. Keep track of both the current number (value) and its specific location (index) in the list.</li>
                        <li><strong>3. Check for History:</strong> At each step, check if the current number already exists as a key in your hash map. If it exists, it means you have seen this number before, identifying a duplicate pair.</li>
                        <li><strong>4. Calculate the Gap:</strong> If the number is in the map, subtract the index stored in the map (the previous location) from the current index. This calculation gives you the distance between the two duplicates.</li>
                        <li><strong>5. Update Minimum:</strong> Compare this newly calculated gap against your global min_dist. If the new gap is smaller than the one currently stored, update min_dist to this new, lower value.</li>
                        <li><strong>6. Record Position:</strong> Update the hash map by saving the current number as the key and the current index as the value. This ensures that future comparisons are always made against the most recent occurrence of the number.</li>
                        <li><strong>7. Final Output:</strong> After the loop finishes, check min_dist. If it is still infinity, no duplicates were found (return -1). Otherwise, return min_dist as the smallest gap.</li>
                    </ul>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Resource Availability Checks
                        <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Hash/resource_avail_check.html'; document.querySelector('.retro-viewport').classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <ol>
                        <li><strong>Map the Requirements:</strong> First, analyze the list. Create a frequency map (a key-value pair) that counts exactly how many of each specific item are required to fulfill the request.</li>
                        <li><strong>Stream the Inventory:</strong> Begin processing the available inventory one item at a time. </li>
                        <li><strong>Match and Decrement:</strong> For every item found in the inventory stream, check if it exists in your needs map. If there is a match, decrease the required count for that specific item by one.</li>
                        <li><strong>Remove Completed Needs:</strong> Monitor the counts in your map. As soon as a specific item's count reaches zero, it means that requirement is fully met. Remove that entry from the map entirely.</li>
                        <li><strong>Early Exit Optimization:</strong> After removing an entry, check if the map is empty. If it is, stop scanning immediately. All needs are met, so you return "True" without wasting time checking the remaining stock.</li>
                    </ol>
                </div>

            </div>
        </details>

        <!-- ============================================== -->
        <!-- SECTION 3: CACHING & TREES -->
        <!-- ============================================== -->
        <details class="section">
            <summary>3. Caching & Trees</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">
                        LCA (Least Common Ancestor)
                        <button class="eye-btn" onclick="const v=document.querySelector('.retro-viewport'); v.querySelector('iframe').src='Hash/LCA.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p>The "Close Ancestor" Optimization. Instead of tracing all the way to the root, we use <strong>Interleaved Traversal</strong>.</p>
                </div>
                    
                    <p><strong>Step 1: Initialization</strong><br>
                    Start with pointers at Node A and Node B. Initialize an empty Hash Set. This set acts as a shared memory log to record every node visited. We will use this to detect the exact moment the two paths intersect.</p>
                
                    <p><strong>Step 2: The Loop</strong><br>
                    Begin a loop that continues until the LCA is found. In each iteration, we alternate processing one step for Node A and then one step for Node B, rather than racing one node all the way to the top immediately.</p>
                
                    <p><strong>Step 3: Process Node A</strong><br>
                    Check if pointer A is valid (i.e., not Null/None, ensuring we aren't above the root). If valid and the node is already in the Set, paths have crossed; return it as the LCA. If not, add it to the Set and move to the parent.</p>
                
                    <p><strong>Step 4: Process Node B</strong><br>
                    Similarly, check if pointer B is valid (not Null). If the current node is in the Hash Set (placed there by A), B has stepped onto A’s path; return this node as the LCA. If no, add it to the Set and move B to its parent.</p>
                
                    <p><strong>Step 5: Handling Roots</strong><br>
                    If a pointer moves past the root, it becomes Null (invalid). That pointer stops moving. The other pointer continues its ascent step-by-step until it lands on a node previously marked by the stopped path.</p>
                
                    <p><strong>Step 6: Termination</strong><br>
                    The moment a valid pointer identifies a node already in the Hash Set, the algorithm ends. This guarantees the "lowest" ancestor is found immediately without traversing the rest of the tree above the intersection.</p>
                </div>

                <div class="subsection">
                    <span class="subsection-title">LRU Caching (DLL + Hash)</span>
                    <p><strong>Goal:</strong> Fast retrieval + Smart eviction.</p>
                    <ul>
                        <li><strong>Hash Map:</strong> Stores <code>[Key, Node_Pointer]</code>. Provides O(1) random access.</li>
                        <li><strong>Doubly Linked List:</strong> Stores actual Values. Maintains temporal order (Head=MRU, Tail=LRU).</li>
                    </ul>
                </div>

            </div>
        </details>

        <!-- ============================================== -->
        <!-- SECTION 4: THEORY & DESIGN -->
        <!-- ============================================== -->
        <details class="section">
            <summary>4. Theory & Design</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">Hashable Class Design</span>
                    <p><strong>Equivalence Relation:</strong> The rule you invent to decide if two things are "the same" (e.g., Logical Identity vs Physical Identity).</p>
                    <p><strong>The Contract:</strong> If <code>A equals B</code>, then <code>Hash(A)</code> MUST equal <code>Hash(B)</code>. If this is broken, the computer files them in different buckets and duplicates cannot be detected.</p>
                </div>

                <div class="subsection">
                    <span class="subsection-title">Hash Tables Theory</span>
                    <p>Hash tables store data in an array (for physical speed) by converting keys to indices.</p>
                    <ul>
                        <li><strong>Hard Rule (Consistency):</strong> Same input must always equal same output.</li>
                        <li><strong>Soft Rule (Distribution):</strong> Keys should be spread out to avoid collisions.</li>
                        <li><strong>Speed Rule (Efficiency):</strong> Calculation must be fast. Avoid cryptographic hashes (SHA256) for standard maps.</li>
                    </ul>
                </div>

            </div>
        </details>

    </div>
</div>

</body>
</html>