<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LCA Visualization: Responsive Ditherpunk</title>
    <style>
        /* --- CORE VARIABLES & RESET --- */
        :root {
            --bg: #000000;
            --fg: #00FF00;
            --fg-dim: #005500;
            --font-main: 'Courier New', Courier, monospace;
            --border-width: clamp(2px, 0.2rem, 4px);
            
            /* Dynamic sizing using clamp(min, preferred, max) */
            --node-size: clamp(32px, 5vw, 60px); 
            --font-size-base: clamp(12px, 1.5vw, 16px);
            --header-height: clamp(60px, 10vh, 80px);
            --sidebar-width: clamp(250px, 25vw, 400px);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            height: 100dvh; /* Dynamic viewport height for mobile browsers */
            width: 100%;
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font-main);
            overflow: hidden;
            font-size: var(--font-size-base);
        }

        /* --- GRID LAYOUT --- */
        body {
            display: grid;
            /* Desktop: Sidebar takes available space but stays within min/max bounds */
            grid-template-columns: 1fr var(--sidebar-width);
            grid-template-rows: 1fr var(--header-height);
            grid-template-areas: 
                "tree log"
                "controls log";
        }

        /* --- CRT SCANLINE EFFECT --- */
        body::after {
            content: " ";
            display: block;
            position: absolute;
            inset: 0; /* Modern shorthand for top/left/right/bottom: 0 */
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 999;
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
        }

        /* --- PATTERNS --- */
        .pattern-a {
            background-image: linear-gradient(45deg, var(--fg) 25%, transparent 25%, transparent 50%, var(--fg) 50%, var(--fg) 75%, transparent 75%, transparent);
            background-size: 0.25rem 0.25rem;
            color: var(--bg) !important;
            text-shadow: 1px 1px 0 var(--fg), -1px -1px 0 var(--fg);
        }

        .pattern-b {
            background-image: linear-gradient(45deg, var(--fg) 25%, transparent 25%), linear-gradient(-45deg, var(--fg) 25%, transparent 25%), linear-gradient(45deg, transparent 75%, var(--fg) 75%), linear-gradient(-45deg, transparent 75%, var(--fg) 75%);
            background-size: 0.25rem 0.25rem;
            background-position: 0 0, 0 2px, 2px -2px, -2px 0px;
            color: var(--bg) !important;
            text-shadow: 1px 1px 0 var(--fg), -1px -1px 0 var(--fg);
        }

        /* --- 1. TREE VIEW --- */
        #tree-container {
            grid-area: tree;
            position: relative;
            border-bottom: var(--border-width) solid var(--fg);
            border-right: var(--border-width) solid var(--fg);
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        svg.edges-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        line {
            stroke: var(--fg);
            stroke-width: var(--border-width);
        }

        .node {
            position: absolute;
            width: var(--node-size);
            height: var(--node-size);
            border: var(--border-width) solid var(--fg);
            border-radius: 50%; 
            background: var(--bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
            z-index: 10;
            /* Centering handled here */
            transform: translate(-50%, -50%); 
            transition: transform 0.2s cubic-bezier(0,1.5,.5,1), background-color 0.2s;
        }

        .node.active-a {
            background: var(--fg);
            color: var(--bg);
            box-shadow: 0.25rem 0.25rem 0 rgba(0, 255, 0, 0.5);
            z-index: 15;
        }

        .node.active-b {
            background: var(--bg);
            color: var(--fg);
            border: calc(var(--border-width) * 2) double var(--fg);
            box-shadow: 0.25rem 0.25rem 0 rgba(0, 255, 0, 0.5);
            z-index: 15;
        }

        .node.lca {
            animation: glitch-anim 0.3s infinite;
            background: var(--fg);
            color: var(--bg);
            border: calc(var(--border-width) * 2) solid var(--fg);
            z-index: 30;
        }

        /* Pointers */
        .pointer {
            position: absolute;
            font-size: 1.2em;
            font-weight: bold;
            z-index: 20;
            transition: top 0.4s ease, left 0.4s ease;
            text-shadow: 2px 2px 0px #000;
            white-space: nowrap;
            /* Center alignment to match node center */
            transform: translate(-50%, 0);
            /* Offset based on node size so it works on any screen size/ratio */
            margin-top: calc(var(--node-size) / 2 + 5px);
        }
        .pointer.null { opacity: 0.5; text-decoration: line-through; }

        /* --- 2. LOG SIDEBAR --- */
        #log-panel {
            grid-area: log;
            border-left: var(--border-width) solid var(--fg);
            display: flex;
            flex-direction: column;
            background: var(--bg);
            min-height: 0; 
            min-width: 0; /* Flexbox safety */
        }

        .panel-header {
            background: var(--fg);
            color: var(--bg);
            padding: 0.8rem;
            text-transform: uppercase;
            font-weight: bold;
            text-align: center;
            border-bottom: var(--border-width) solid var(--fg);
            font-size: 0.9em;
            letter-spacing: 1px;
        }

        #log-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            font-size: 0.85em;
            font-family: 'Courier New', monospace;
            scroll-behavior: smooth;
        }

        .log-entry {
            margin-bottom: 0.5em;
            padding: 0.25em;
            border-bottom: 1px dashed var(--fg-dim);
            line-height: 1.4;
            word-break: break-word; /* Prevent overflow on small screens */
        }
        .log-entry.error { color: #FF4444; background: #220000; }

        /* Custom Scrollbar */
        #log-content::-webkit-scrollbar { width: 8px; }
        #log-content::-webkit-scrollbar-track { background: var(--bg); border-left: 2px solid var(--fg); }
        #log-content::-webkit-scrollbar-thumb { background: var(--fg); border: 2px solid var(--bg); }

        /* --- 3. CONTROL DECK --- */
        #controls {
            grid-area: controls;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1rem;
            border-right: var(--border-width) solid var(--fg);
            border-top: var(--border-width) solid var(--fg);
            background: var(--bg);
            gap: 1rem;
            /* Handle narrow widths gracefully */
            flex-wrap: wrap; 
        }

        #status-text {
            font-size: 1em;
            text-transform: uppercase;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 120px;
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
        }

        button {
            background: var(--bg);
            color: var(--fg);
            border: 2px solid var(--fg);
            padding: 0.5rem 1rem;
            font-family: var(--font-main);
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 3px 3px 0 var(--fg-dim);
            transition: transform 0.1s;
            font-size: 0.85em;
            white-space: nowrap;
            /* Ensure good touch targets on mobile */
            min-height: 38px;
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: 1px 1px 0 var(--fg-dim);
        }

        button:disabled {
            border-color: var(--fg-dim);
            color: var(--fg-dim);
            box-shadow: none;
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* --- ANIMATIONS --- */
        @keyframes glitch-anim {
            0% { transform: translate(-50%, -50%) skew(0deg); }
            20% { transform: translate(-52%, -48%) skew(-10deg); }
            40% { transform: translate(-48%, -52%) skew(10deg); }
            60% { transform: translate(-50%, -50%) skew(0deg); }
            80% { transform: translate(-52%, -48%) skew(5deg); }
            100% { transform: translate(-50%, -50%) skew(0deg); }
        }

        /* --- RESPONSIVE MEDIA QUERIES --- */
        
        /* Tablet / Mobile Landscape / Small Desktops */
        @media (max-width: 850px) {
            body {
                /* Stack layout vertically */
                grid-template-columns: 1fr;
                /* Tree gets flexible height, log gets fixed height, controls auto */
                grid-template-rows: 1fr 200px auto;
                grid-template-areas: 
                    "tree" 
                    "log" 
                    "controls";
            }
            
            #log-panel { border-left: none; border-top: var(--border-width) solid var(--fg); }
            #controls { border-right: none; }
            #tree-container { border-right: none; }
            
            /* Pointers font size adjustment */
            .pointer { font-size: 1em; }
        }

        /* Small Phones (Portrait) */
        @media (max-width: 480px) {
            :root {
                --node-size: 10vw; /* Make nodes relative to width on tiny screens */
            }

            body {
                grid-template-rows: 1fr 150px auto; /* Shrink log area */
            }

            #controls {
                padding: 0.5rem;
                justify-content: center;
            }

            #status-text {
                width: 100%;
                text-align: center;
                margin-bottom: 0.5rem;
                font-size: 0.9em;
            }
            
            .btn-group {
                width: 100%;
                justify-content: center;
            }

            button {
                flex: 1;
                padding: 0.5rem;
                font-size: 0.75em;
            }
        }
    </style>
</head>
<body>

    <!-- Tree Visualization Area -->
    <div id="tree-container">
        <svg class="edges-layer" id="edges-svg"></svg>
        <div id="nodes-layer"></div>
        <!-- Pointers -->
        <div id="ptr-a" class="pointer" style="display:none;">▲ A</div>
        <div id="ptr-b" class="pointer" style="display:none;">▲ B</div>
    </div>

    <!-- Right Sidebar Log -->
    <aside id="log-panel">
        <div class="panel-header">Hash Set Memory</div>
        <div id="log-content">
            <div class="log-entry">> BOOTING...</div>
        </div>
    </aside>

    <!-- Bottom Controls -->
    <footer id="controls">
        <div id="status-text">STATUS: IDLE</div>
        <div class="btn-group">
            <button id="btn-reset">Reset</button>
            <button id="btn-step" disabled>Step</button>
            <button id="btn-auto" disabled>Auto-Run</button>
        </div>
    </footer>

    <script>
        /* --- ERROR HANDLING --- */
        window.onerror = function(msg, url, line) {
            const logPanel = document.getElementById('log-content');
            if(logPanel) {
                const div = document.createElement('div');
                div.className = 'log-entry error';
                div.innerText = `[SYS ERR]: ${msg}`;
                logPanel.appendChild(div);
            }
        };

        /* --- CONFIGURATION --- */
        const DEPTH = 4;
        const ANIMATION_DELAY = 500;

        /* --- STATE --- */
        let nodes = {}; 
        let rootId = null;
        let ptrA = null; 
        let ptrB = null; 
        let visitedSet = new Map(); 
        let currentTurn = 'A'; 
        let autoInterval = null;
        let isFinished = false;

        /* --- DOM REFS --- */
        const treeContainer = document.getElementById('tree-container');
        const nodesLayer = document.getElementById('nodes-layer');
        const edgesSvg = document.getElementById('edges-svg');
        const logContent = document.getElementById('log-content');
        const statusText = document.getElementById('status-text');
        const ptrAEl = document.getElementById('ptr-a');
        const ptrBEl = document.getElementById('ptr-b');
        
        const btnReset = document.getElementById('btn-reset');
        const btnStep = document.getElementById('btn-step');
        const btnAuto = document.getElementById('btn-auto');

        /* --- INITIALIZATION --- */
        document.addEventListener('DOMContentLoaded', () => {
            try {
                init();
            } catch (e) {
                log(`[FATAL]: ${e.message}`, true);
            }
        });

        function init() {
            logContent.innerHTML = '';
            log("> SYSTEM ONLINE.");
            generateTree();
            resetAlgorithm();
            
            requestAnimationFrame(() => {
                updateLineCoordinates();
                log("> VISUALIZER READY.");
            });
        }

        /* --- LOGIC --- */
        function generateTree() {
            nodes = {};
            let queue = [];
            
            rootId = '1';
            nodes[rootId] = { id: rootId, parent: null, x: 50, y: 10, depth: 0 };
            queue.push(nodes[rootId]);

            while (queue.length > 0) {
                let curr = queue.shift();
                if (curr.depth < DEPTH) {
                    // Spread factor uses logic that works in percentages relative to viewport width
                    let spread = 25 / Math.pow(2, curr.depth);
                    
                    // Left Child
                    let leftId = (parseInt(curr.id) * 2).toString();
                    nodes[leftId] = { 
                        id: leftId, 
                        parent: curr.id, 
                        depth: curr.depth + 1,
                        x: curr.x - spread,
                        y: ((curr.depth + 1) * (85 / DEPTH)) + 10
                    };
                    queue.push(nodes[leftId]);

                    // Right Child
                    let rightId = (parseInt(curr.id) * 2 + 1).toString();
                    nodes[rightId] = { 
                        id: rightId, 
                        parent: curr.id, 
                        depth: curr.depth + 1,
                        x: curr.x + spread,
                        y: ((curr.depth + 1) * (85 / DEPTH)) + 10
                    };
                    queue.push(nodes[rightId]);
                }
            }
        }

        function drawTree() {
            nodesLayer.innerHTML = '';
            edgesSvg.innerHTML = '';

            // Draw Edges
            Object.values(nodes).forEach(node => {
                if (node.parent) {
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    edgesSvg.appendChild(line);
                    node.svgLine = line; 
                }
            });

            // Draw Nodes
            Object.values(nodes).forEach(node => {
                const div = document.createElement('div');
                div.className = 'node';
                div.id = `node-${node.id}`;
                div.textContent = node.id;
                div.style.left = node.x + '%';
                div.style.top = node.y + '%';
                nodesLayer.appendChild(div);
            });
        }

        function updateLineCoordinates() {
            const containerRect = treeContainer.getBoundingClientRect();
            // Safety check against zero-size (hidden/collapsed) container
            if (containerRect.width === 0 || containerRect.height === 0) return;

            Object.values(nodes).forEach(node => {
                if (node.parent && node.svgLine) {
                    const parent = nodes[node.parent];
                    
                    const x1 = (parent.x / 100) * containerRect.width;
                    const y1 = (parent.y / 100) * containerRect.height;
                    const x2 = (node.x / 100) * containerRect.width;
                    const y2 = (node.y / 100) * containerRect.height;

                    node.svgLine.setAttribute('x1', x1);
                    node.svgLine.setAttribute('y1', y1);
                    node.svgLine.setAttribute('x2', x2);
                    node.svgLine.setAttribute('y2', y2);
                }
            });
        }

        function resetAlgorithm() {
            visitedSet.clear();
            currentTurn = 'A';
            isFinished = false;

            const leaves = Object.values(nodes).filter(n => n.depth === DEPTH);
            
            if (leaves.length < 2) {
                generateTree(); 
                return resetAlgorithm();
            }

            const randA = leaves[Math.floor(Math.random() * leaves.length)];
            let randB = leaves[Math.floor(Math.random() * leaves.length)];
            
            let safeGuard = 0;
            while(randB.id === randA.id && safeGuard < 50) {
                randB = leaves[Math.floor(Math.random() * leaves.length)];
                safeGuard++;
            }

            ptrA = randA.id;
            ptrB = randB.id;
            
            drawTree();
            updatePointerVisuals();
            
            statusText.textContent = `READY: A[${ptrA}] | B[${ptrB}]`;
            statusText.style.color = "var(--fg)";
            statusText.style.backgroundColor = "transparent";
            
            btnStep.disabled = false;
            btnAuto.disabled = false;
            
            log(`> START NODES: A=${ptrA}, B=${ptrB}`);
        }

        /* --- EXECUTION --- */
        function performStep() {
            if (isFinished) return;

            const isTurnA = (currentTurn === 'A');
            const currentPtr = isTurnA ? ptrA : ptrB;
            const otherPtr = isTurnA ? ptrB : ptrA;
            const label = isTurnA ? 'A' : 'B';
            
            statusText.textContent = `> PROCESSING ${label}: Node ${currentPtr || 'NULL'}`;

            if (currentPtr === null) {
                log(`> [${label}] IS NULL (Skipping turn).`);
                if (otherPtr === null) {
                    finish("FAIL: Both Pointers Null", null);
                } else {
                    currentTurn = isTurnA ? 'B' : 'A';
                    highlightActiveNode();
                }
                return;
            }

            const nodeEl = document.getElementById(`node-${currentPtr}`);
            const nodeObj = nodes[currentPtr];

            // CRITICAL LOGIC: CHECK MEMORY
            if (visitedSet.has(currentPtr)) {
                const owner = visitedSet.get(currentPtr);
                log(`> MEMORY HIT: Node ${currentPtr} visited by ${owner}`);
                
                finish(`INTERSECTION: NODE ${currentPtr}`, currentPtr);
                return;
            }

            visitedSet.set(currentPtr, label);
            log(`> LOGGED: ${currentPtr} -> [${label} Hist]`);
            
            nodeEl.classList.add(isTurnA ? 'pattern-a' : 'pattern-b');
            
            if (isTurnA) ptrA = nodeObj.parent;
            else ptrB = nodeObj.parent;

            currentTurn = isTurnA ? 'B' : 'A';
            updatePointerVisuals();
        }

        function finish(msg, lcaId) {
            isFinished = true;
            statusText.textContent = msg;
            statusText.style.color = "#FFF";
            statusText.style.backgroundColor = "var(--fg)";
            
            if (lcaId) {
                const el = document.getElementById(`node-${lcaId}`);
                if (el) {
                    el.classList.remove('pattern-a', 'pattern-b');
                    el.classList.add('lca');
                }
            }
            log(`> PROCESS COMPLETE.`);
            stopAuto();
            btnStep.disabled = true;
            btnAuto.disabled = true;
        }

        /* --- VISUAL HELPERS --- */
        function updatePointerVisuals() {
            highlightActiveNode();
            
            const nodeA = nodes[ptrA];
            const nodeB = nodes[ptrB];

            setPointer(ptrAEl, nodeA, 'A');
            setPointer(ptrBEl, nodeB, 'B');
        }

        function setPointer(el, node, label) {
            if (!node) {
                el.classList.add('null');
                el.innerHTML = `Ø ${label}`;
            } else {
                el.classList.remove('null');
                el.innerHTML = `▲ ${label}`;
                el.style.display = 'block';
                el.style.left = node.x + '%';
                // Note: Top is set to the node center. 
                // CSS transform and margin handles the offset based on node-size variable.
                el.style.top = node.y + '%'; 
            }
        }

        function highlightActiveNode() {
            document.querySelectorAll('.active-a, .active-b').forEach(el => {
                el.classList.remove('active-a', 'active-b');
            });
            if (isFinished) return;

            if (currentTurn === 'A' && ptrA) {
                const el = document.getElementById(`node-${ptrA}`);
                if(el) el.classList.add('active-a');
            } else if (currentTurn === 'B' && ptrB) {
                const el = document.getElementById(`node-${ptrB}`);
                if(el) el.classList.add('active-b');
            }
        }

        function log(msg, isError = false) {
            const div = document.createElement('div');
            div.className = isError ? 'log-entry error' : 'log-entry';
            div.innerText = msg;
            logContent.appendChild(div);
            logContent.scrollTop = logContent.scrollHeight;
        }

        function stopAuto() {
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
                btnAuto.textContent = "Auto-Run";
            }
        }

        /* --- EVENTS --- */
        btnStep.addEventListener('click', performStep);
        
        btnAuto.addEventListener('click', () => {
            if (autoInterval) {
                stopAuto();
            } else {
                performStep();
                autoInterval = setInterval(performStep, ANIMATION_DELAY);
                btnAuto.textContent = "Stop";
            }
        });

        btnReset.addEventListener('click', () => {
            stopAuto();
            init(); 
        });

        // Throttle resize events for performance
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(updateLineCoordinates, 50);
        });
    </script>
</body>
</html>