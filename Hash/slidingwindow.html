--- START OF FILE slidingwindow_responsive.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Protocol: SLIDING_WINDOW [RESPONSIVE]</title>
    
    <!-- Retro Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg: #050505;
            --green: #33FF00;
            --red: #FF0033;
            --gold: #FFCC00;
            --dim-green: rgba(51, 255, 0, 0.2);
            --dim-gold: rgba(255, 204, 0, 0.3);
            --font-main: 'VT323', monospace;
            
            /* Responsive Cell Size: Min 40px, Max 80px, Target 6vw */
            --cell-size: clamp(2.5rem, 6vw, 5rem); 
            --header-height: auto;
            --footer-height: auto;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            background-color: var(--bg);
            color: var(--green);
            font-family: var(--font-main);
            min-height: 100dvh; /* Dynamic viewport height for mobile */
            height: 100dvh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            text-transform: uppercase;
            font-size: clamp(1rem, 2vw, 1.4rem);
            cursor: crosshair;
        }

        /* --- CRT EFFECT LAYERS --- */
        .crt-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 999;
        }
        
        .crt-flicker {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            z-index: 998;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.02; }
            50% { opacity: 0.05; }
            100% { opacity: 0.02; }
        }

        /* --- UTILS --- */
        .glow-text { text-shadow: 0 0 5px var(--green); }
        .glow-gold { text-shadow: 0 0 5px var(--gold); color: var(--gold); }
        
        /* --- LAYOUT --- */
        header {
            padding: 1rem;
            border-bottom: 2px solid var(--green);
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            flex-shrink: 0;
        }

        .title { white-space: nowrap; font-size: 1.2em; }

        .target-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .char-box {
            width: 2.2em; height: 2.2em;
            border: 2px solid var(--green);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            position: relative;
        }
        .char-box.missing { border-color: var(--red); box-shadow: 0 0 5px var(--red); }
        .char-box.found { background: var(--dim-green); box-shadow: 0 0 5px var(--green); }
        .char-box.found::after {
            content: ''; position: absolute; top:0; left:0; right:0; bottom:0;
            background-image: radial-gradient(var(--green) 20%, transparent 20%);
            background-size: 3px 3px;
            opacity: 0.5;
        }

        /* --- TAPE SECTION --- */
        .tape-container {
            position: relative;
            display: flex;
            align-items: center;
            overflow-x: auto;
            flex-grow: 1; /* Takes up remaining vertical space */
            padding: 0 1rem;
            background: #000;
            /* Momentum scrolling for mobile */
            -webkit-overflow-scrolling: touch; 
            scrollbar-width: thin;
            scrollbar-color: var(--green) #000;
        }
        
        .tape-wrapper {
            display: flex;
            position: relative;
            margin: 0 auto;
            padding: 3rem 0; /* Space for pointers */
        }

        .tape-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 1px solid #333;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            flex-shrink: 0;
            position: relative;
            background: #000;
            z-index: 2;
        }

        .tape-cell.active-green { border: 2px solid var(--green); box-shadow: inset 0 0 10px var(--dim-green); }

        /* Pointers */
        .pointer {
            position: absolute;
            width: 0; height: 0;
            border-left: 0.6em solid transparent;
            border-right: 0.6em solid transparent;
            z-index: 10;
            transition: left 0.2s cubic-bezier(0, 1, 0.5, 1);
        }
        .pointer-left {
            border-bottom: 1em solid var(--red);
            bottom: 1em; /* Relative to tape-wrapper padding */
            filter: drop-shadow(0 0 5px var(--red));
        }
        .pointer-right {
            border-bottom: 1em solid var(--green);
            bottom: 1em;
            filter: drop-shadow(0 0 5px var(--green));
        }

        /* Overlays */
        .window-overlay {
            position: absolute;
            height: calc(100% - 2rem); /* Fit inside wrapper padding */
            top: 1rem;
            background: var(--dim-green);
            border: 1px dashed var(--green);
            z-index: 1;
            transition: left 0.2s, width 0.2s;
        }
        .window-overlay::after {
            content: ''; position: absolute; top:0; left:0; right:0; bottom:0;
            background-image: radial-gradient(var(--green) 15%, transparent 16%);
            background-size: 3px 3px;
            opacity: 0.3;
        }

        .best-overlay {
            position: absolute;
            height: calc(100% - 1rem);
            top: 0.5rem;
            background: var(--dim-gold);
            border: 2px solid var(--gold);
            z-index: 0;
            transition: all 0.3s;
            display: none;
        }

        /* --- STATS & SIDEBAR --- */
        .bottom-ui {
            display: flex;
            flex-wrap: wrap; /* Wraps on mobile */
            border-top: 2px solid var(--green);
            flex-shrink: 0;
            max-height: 40vh; /* Prevent taking over screen */
            overflow-y: auto;
        }

        .stats-panel {
            flex: 2 1 300px; /* Grow 2x, shrink, min-width 300px */
            border-right: 2px solid var(--green);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        /* Remove right border on mobile wrap */
        @media (max-width: 768px) {
            .stats-panel { border-right: none; border-bottom: 2px solid var(--green); }
        }

        .counter-box {
            border: 2px solid var(--red);
            padding: 0.5rem;
            color: var(--red);
            text-align: center;
            font-size: 1.2em;
            transition: all 0.2s;
        }
        .counter-box.complete {
            border-color: var(--green);
            background: var(--green);
            color: black;
            animation: flash 0.5s;
        }

        @keyframes flash { 0% { background: white; } 100% { background: var(--green); } }

        .hash-map {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .hash-item {
            border: 1px solid #333;
            padding: 0.2rem 0.5rem;
            min-width: 3rem;
            text-align: center;
            font-size: 1.1em;
        }
        .hash-item.updated {
            animation: glitch-scale 0.3s;
            border-color: var(--green);
            color: var(--green);
            text-shadow: 2px 0 var(--red), -2px 0 var(--gold);
        }

        @keyframes glitch-scale {
            0% { transform: scale(1); }
            50% { transform: scale(1.2) skew(10deg); }
            100% { transform: scale(1); }
        }

        .sidebar {
            flex: 1 1 200px; /* Grow 1x, shrink, min-width 200px */
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            background: #000;
        }

        .best-display {
            border: 2px solid var(--gold);
            padding: 1rem;
            color: var(--gold);
            text-shadow: 0 0 5px var(--gold);
            word-break: break-all;
            font-size: 1em;
        }

        /* --- CONTROLS --- */
        .controls {
            border-top: 2px solid var(--green);
            padding: 1rem;
            display: flex;
            justify-content: center;
            gap: 1rem;
            background: #000;
            flex-wrap: wrap; /* Buttons wrap on tiny screens */
            flex-shrink: 0;
            padding-bottom: max(1rem, env(safe-area-inset-bottom));
        }

        button {
            background: transparent;
            border: 2px solid var(--green);
            color: var(--green);
            font-family: var(--font-main);
            font-size: 1rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 5px var(--dim-green);
            transition: all 0.1s;
            flex: 1 0 auto; /* Buttons scale nicely */
            max-width: 150px;
        }

        button:hover { background: var(--green); color: black; }
        button:active { transform: translateY(2px); }
        button:disabled { border-color: #333; color: #333; cursor: not-allowed; box-shadow: none; }

        /* SVG Connections Layer */
        #connections {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 99;
        }
        line.connector {
            stroke: var(--green);
            stroke-width: 2;
            stroke-dasharray: 4;
            animation: dash 0.5s linear infinite;
        }
        @keyframes dash { to { stroke-dashoffset: -8; } }

    </style>
</head>
<body>

    <div class="crt-overlay"></div>
    <div class="crt-flicker"></div>
    <svg id="connections"></svg>

    <header>
        <div class="title glow-text">>> SLIDING_WINDOW_PROTOCOL</div>
        <div class="target-container" id="targetContainer">
            <span style="margin-right:0.5rem">TARGET:</span>
            <!-- Target boxes generated by JS -->
        </div>
    </header>

    <main class="tape-container" id="scrollContainer">
        <div class="tape-wrapper" id="tapeWrapper">
            <!-- Cells generated by JS -->
            
            <div id="windowOverlay" class="window-overlay" style="width: 0; left: 0; opacity: 0;"></div>
            <div id="bestOverlay" class="best-overlay"></div>

            <div id="ptrLeft" class="pointer pointer-left" style="left: 0;"></div>
            <div id="ptrRight" class="pointer pointer-right" style="left: 0;"></div>
        </div>
    </main>

    <div class="bottom-ui">
        <section class="stats-panel">
            <div id="counterBox" class="counter-box">
                REMAINING: <span id="remainVal">--</span>
            </div>
            <div>
                <div style="margin-bottom:0.5rem; color:#555; font-size: 0.9em;">>> MEMORY_DUMP (Counts)</div>
                <div class="hash-map" id="hashMap">
                    <!-- Hash items generated by JS -->
                </div>
            </div>
        </section>

        <aside class="sidebar">
            <div class="leaderboard-title glow-gold">BEST WINDOW</div>
            <div class="best-display" id="bestDisplay">
                SEARCHING...
            </div>
        </aside>
    </div>

    <footer class="controls">
        <button id="btnPlay">▶ PLAY</button>
        <button id="btnPause">❚❚ PAUSE</button>
        <button id="btnStep">⏭ STEP</button>
        <button id="btnReset">⟲ RESET</button>
    </footer>

    <script>
        // --- CONFIG & STATE ---
        const S = "ADOBECODEBANC";
        const T = "ABC";
        
        const state = {
            left: 0,
            right: 0,
            windowCounts: {},
            requiredCounts: {},
            formed: 0,
            required: 0,
            ans: [-1, 0, 0], // length, left, right
            mode: 'EXPAND', // EXPAND, CHECK, SHRINK, FINISHED
            isPlaying: false,
            timer: null,
            speed: 600,
            initialized: false
        };

        // --- DOM ELEMENTS ---
        const els = {
            tapeWrapper: document.getElementById('tapeWrapper'),
            scrollContainer: document.getElementById('scrollContainer'),
            targetContainer: document.getElementById('targetContainer'),
            ptrLeft: document.getElementById('ptrLeft'),
            ptrRight: document.getElementById('ptrRight'),
            windowOverlay: document.getElementById('windowOverlay'),
            bestOverlay: document.getElementById('bestOverlay'),
            counterBox: document.getElementById('counterBox'),
            remainVal: document.getElementById('remainVal'),
            hashMap: document.getElementById('hashMap'),
            bestDisplay: document.getElementById('bestDisplay'),
            svg: document.getElementById('connections'),
            btnPlay: document.getElementById('btnPlay'),
            btnPause: document.getElementById('btnPause'),
            btnStep: document.getElementById('btnStep'),
            btnReset: document.getElementById('btnReset')
        };

        // --- RESPONSIVE UTILS ---
        function getCellSize() {
            // Dynamically measure the size of a cell to handle responsiveness
            const cell = document.querySelector('.tape-cell');
            if (cell) {
                return cell.getBoundingClientRect().width;
            }
            return 50; // Fallback
        }

        // --- INITIALIZATION ---
        function init() {
            // Build Required Map
            state.requiredCounts = {};
            for(let char of T) {
                state.requiredCounts[char] = (state.requiredCounts[char] || 0) + 1;
            }
            state.required = Object.keys(state.requiredCounts).length;
            
            renderTape();
            renderTarget();
            renderHashMap();
            resetState();
            
            state.initialized = true;

            // Handle Resize
            window.addEventListener('resize', () => {
                // Debounce slightly or just update immediately
                requestAnimationFrame(() => {
                    updatePointers();
                    updateWindowOverlay();
                    if(state.ans[0] !== -1) updateBestWindowUI();
                });
            });
        }

        function resetState() {
            stopAutoPlay();
            state.left = 0;
            state.right = 0;
            state.windowCounts = {};
            state.formed = 0;
            state.ans = [-1, 0, 0];
            state.mode = 'EXPAND';
            
            // Clear UI
            updatePointers();
            updateWindowOverlay();
            els.bestOverlay.style.display = 'none';
            els.counterBox.className = 'counter-box';
            els.remainVal.innerText = state.required;
            els.bestDisplay.innerHTML = "SEARCHING...";
            els.bestDisplay.className = "best-display";
            
            // Clear Hash Map UI
            els.hashMap.innerHTML = '';
            renderHashMap(); // Re-render empty
            
            // Clear Tape Highlights
            document.querySelectorAll('.tape-cell').forEach(c => c.className = 'tape-cell');
            document.querySelectorAll('.char-box').forEach(c => c.classList.remove('found'));
        }

        function renderTape() {
            els.tapeWrapper.innerHTML = '';
            // Re-add pointers and overlays first so they stay in DOM
            els.tapeWrapper.appendChild(els.windowOverlay);
            els.tapeWrapper.appendChild(els.bestOverlay);
            els.tapeWrapper.appendChild(els.ptrLeft);
            els.tapeWrapper.appendChild(els.ptrRight);

            for(let i=0; i<S.length; i++) {
                const cell = document.createElement('div');
                cell.className = 'tape-cell';
                cell.innerText = S[i];
                cell.id = `cell-${i}`;
                els.tapeWrapper.appendChild(cell);
            }
        }

        function renderTarget() {
            els.targetContainer.innerHTML = '<span style="margin-right:10px">TARGET:</span>';
            const uniqueChars = [...new Set(T.split(''))];
            uniqueChars.forEach(char => {
                const box = document.createElement('div');
                box.className = 'char-box missing';
                box.id = `target-${char}`;
                box.innerText = char;
                const sub = document.createElement('span');
                sub.style.fontSize = '0.7em';
                sub.style.position = 'absolute';
                sub.style.bottom = '0';
                sub.style.right = '2px';
                sub.innerText = state.requiredCounts[char];
                box.appendChild(sub);
                els.targetContainer.appendChild(box);
            });
        }

        function renderHashMap() {
            // Dynamic population
        }

        // --- CORE ALGORITHM STEP ---
        function step() {
            if (state.mode === 'FINISHED') return;

            // 1. EXPAND PHASE
            if (state.mode === 'EXPAND') {
                if (state.right >= S.length) {
                    state.mode = 'FINISHED';
                    els.btnPlay.disabled = true;
                    els.btnStep.disabled = true;
                    return;
                }

                const char = S[state.right];
                const cell = document.getElementById(`cell-${state.right}`);
                
                // Visuals
                cell.classList.add('active-green');
                drawConnection(cell, char); // Juice

                // Logic
                state.windowCounts[char] = (state.windowCounts[char] || 0) + 1;
                updateHashMapUI(char);

                if (state.requiredCounts[char] && state.windowCounts[char] === state.requiredCounts[char]) {
                    state.formed++;
                    flashTarget(char);
                }

                // Move Pointer Visual
                state.right++; 
                updatePointers();
                updateWindowOverlay();
                updateStats();

                // Check Transition
                if (state.formed === state.required) {
                    state.mode = 'CHECK'; // Immediate transition check next tick
                }
            }

            // 2. CHECK PHASE (Validity & Best Window)
            else if (state.mode === 'CHECK') {
                els.counterBox.classList.add('complete');
                els.remainVal.innerText = "0";

                const currentLen = state.right - state.left;
                if (state.ans[0] === -1 || currentLen < state.ans[0]) {
                    state.ans = [currentLen, state.left, state.right];
                    updateBestWindowUI();
                }
                
                state.mode = 'SHRINK';
            }

            // 3. SHRINK PHASE
            else if (state.mode === 'SHRINK') {
                const char = S[state.left];
                const cell = document.getElementById(`cell-${state.left}`);
                
                // Logic removal
                state.windowCounts[char]--;
                updateHashMapUI(char); // Update UI
                cell.classList.remove('active-green'); // Remove highlight as it leaves window

                if (state.requiredCounts[char] && state.windowCounts[char] < state.requiredCounts[char]) {
                    state.formed--;
                    unflashTarget(char);
                }

                // Move Left
                state.left++;
                updatePointers();
                updateWindowOverlay();
                updateStats();

                // Decide next mode
                if (state.formed < state.required) {
                    els.counterBox.classList.remove('complete');
                    state.mode = 'EXPAND';
                } else {
                    // Still valid, check for better window next tick
                    state.mode = 'CHECK';
                }
            }
        }

        // --- UI UPDATERS ---

        function updatePointers() {
            const cellSize = getCellSize();
            const rIndex = state.right - 1; 
            const lIndex = state.left;

            // Constrain visual if initially 0
            const visualR = Math.max(0, rIndex);
            
            // We need to account for pointer width to center it
            // CSS: pointers are 0 width, but have border. 
            // Left ptr: border-left 0.6em (~10-15px depending on screen). 
            // Let's center based on cell center.
            
            const cellCenter = cellSize / 2;
            // Pointer is centered at left: X. No offset needed because CSS arrow points up to X.
            // Actually, CSS pointer has width 0. Left=0 puts it at left edge.
            // To center on cell: left = index * cellSize + (cellSize/2) - (pointerWidth/2)
            // But simplified: let's put it at cell boundary for sliding window logic
            
            // Standard sliding window vis: Left ptr at START of cell, Right ptr at END of cell
            els.ptrLeft.style.left = (lIndex * cellSize) + 'px';
            
            // Right pointer usually sits 'after' the current window end, or ON the last element
            // Here, state.right is exclusive index. visualR is inclusive index.
            // Let's place it at the right edge of visualR cell.
            els.ptrRight.style.left = (visualR * cellSize) + (cellSize) + 'px';
            // Offset slightly back to align the arrow tip (approx 10px depending on scale)
            // Since we went responsive, let's just aim for the gap line.
            els.ptrRight.style.transform = `translateX(-50%)`;
            els.ptrLeft.style.transform = `translateX(-50%)`;

            // Auto scroll logic
            const containerWidth = els.scrollContainer.clientWidth;
            const scrollPos = els.scrollContainer.scrollLeft;
            const activePos = state.right * cellSize;
            
            // Scroll if near edge
            if (activePos > scrollPos + containerWidth - (cellSize * 2)) {
                els.scrollContainer.scrollTo({ left: activePos - containerWidth + (cellSize * 3), behavior: 'smooth' });
            }
        }

        function updateWindowOverlay() {
            if (state.right === 0) return;
            const cellSize = getCellSize();
            const width = (state.right - state.left) * cellSize;
            const left = state.left * cellSize;
            
            els.windowOverlay.style.opacity = '1';
            els.windowOverlay.style.left = left + 'px';
            els.windowOverlay.style.width = width + 'px';
        }

        function updateBestWindowUI() {
            const [len, l, r] = state.ans;
            const cellSize = getCellSize();
            const width = (r - l) * cellSize;
            const left = l * cellSize;

            els.bestOverlay.style.display = 'block';
            els.bestOverlay.style.left = left + 'px';
            els.bestOverlay.style.width = width + 'px';

            const str = S.substring(l, r);
            els.bestDisplay.innerHTML = `"${str}" <br> LEN: ${len}`;
            els.bestDisplay.classList.add('glow-gold');
            
            setTimeout(() => els.bestDisplay.classList.remove('glow-gold'), 500);
        }

        function updateHashMapUI(char) {
            let box = document.getElementById(`hash-${char}`);
            if (!box) {
                box = document.createElement('div');
                box.className = 'hash-item';
                box.id = `hash-${char}`;
                box.innerHTML = `${char} : <span id="count-${char}">0</span>`;
                els.hashMap.appendChild(box);
            }

            const countSpan = document.getElementById(`count-${char}`);
            countSpan.innerText = state.windowCounts[char];
            
            box.classList.remove('updated');
            void box.offsetWidth; 
            box.classList.add('updated');
        }

        function updateStats() {
            if (state.formed === state.required) {
                els.remainVal.innerText = "0";
            } else {
                els.remainVal.innerText = state.required - state.formed;
            }
        }

        function flashTarget(char) {
            const box = document.getElementById(`target-${char}`);
            if(box) {
                box.classList.remove('missing');
                box.classList.add('found');
            }
        }

        function unflashTarget(char) {
            const box = document.getElementById(`target-${char}`);
            if(box) {
                box.classList.remove('found');
                box.classList.add('missing');
            }
        }

        // --- JUICE ---
        function drawConnection(cellElem, char) {
            let hashElem = document.getElementById(`hash-${char}`);
            if (!hashElem) return;

            const r1 = cellElem.getBoundingClientRect();
            const r2 = hashElem.getBoundingClientRect();

            // Calculate centers relative to viewport for SVG line
            const x1 = r1.left + (r1.width/2);
            const y1 = r1.bottom;
            const x2 = r2.left + (r2.width/2);
            const y2 = r2.top;

            const line = document.createElementNS('http://www.w3.org/2000/svg','line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('class', 'connector');
            
            els.svg.appendChild(line);

            setTimeout(() => {
                line.remove();
            }, 300);
        }

        // --- CONTROLS LOGIC ---
        function tick() {
            if (!state.isPlaying) return;
            step();
            if (state.mode !== 'FINISHED') {
                state.timer = setTimeout(tick, state.speed);
            }
        }

        function startAutoPlay() {
            if (state.isPlaying) return;
            state.isPlaying = true;
            els.btnPlay.style.background = 'var(--green)';
            els.btnPlay.style.color = 'black';
            tick();
        }

        function stopAutoPlay() {
            state.isPlaying = false;
            clearTimeout(state.timer);
            els.btnPlay.style.background = 'transparent';
            els.btnPlay.style.color = 'var(--green)';
        }

        els.btnPlay.addEventListener('click', startAutoPlay);
        els.btnPause.addEventListener('click', stopAutoPlay);
        els.btnStep.addEventListener('click', () => {
            stopAutoPlay();
            step();
        });
        els.btnReset.addEventListener('click', () => {
            stopAutoPlay();
            els.btnPlay.disabled = false;
            els.btnStep.disabled = false;
            resetState();
        });

        // Start
        init();

    </script>
</body>
</html>