<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Inventory Optimization // Ditherpunk</title>
    <style>
        :root {
            --bg: #000000;
            --fg: #39FF14;
            --fg-dim: #1a5c0b;
            --font-main: 'Courier New', Courier, monospace;
            --scan-speed: 2s;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font-main);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: grid;
            grid-template-rows: 1fr 2fr;
            grid-template-columns: 1fr;
        }

        /* --- DITHERPUNK AESTHETIC OVERLAYS --- */
        
        /* 1-bit Dither Pattern Simulation */
        body::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: radial-gradient(var(--fg-dim) 1px, transparent 1px);
            background-size: 4px 4px;
            opacity: 0.3;
            pointer-events: none;
            z-index: 100;
        }

        /* Scanline Effect */
        body::after {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 101;
        }

        /* --- LAYOUT ZONES --- */

        /* ZONE C: DASHBOARD (Top) */
        #dashboard {
            grid-row: 1;
            border-bottom: 2px solid var(--fg);
            padding: 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            position: relative;
            z-index: 10;
        }

        .dashboard-header {
            font-size: 1.2rem;
            text-transform: uppercase;
            margin-bottom: 1rem;
            border: 1px solid var(--fg);
            padding: 0.5rem 1rem;
            box-shadow: 4px 4px 0px var(--fg-dim);
        }

        .needs-grid {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .need-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px dotted var(--fg);
            padding: 1rem;
            width: 80px;
            transition: all 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }

        .need-icon {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .need-count {
            font-size: 1.5rem;
        }

        /* COMPLETED STATE (Removed from DOM via JS, but styling for exit) */
        .need-item.complete {
            transform: scale(0);
            opacity: 0;
        }

        /* ZONE A & B: STREAM & SCANNER (Bottom) */
        #stream-zone {
            grid-row: 2;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
        }

        /* ZONE B: THE SCANNER LINE */
        #scanner {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: var(--fg);
            transform: translateX(-50%);
            z-index: 50;
            box-shadow: 0 0 10px var(--fg);
        }

        #scanner::before {
            content: "SCANNING LOGIC // MATCH CHECK";
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 0.8rem;
            white-space: nowrap;
            background: var(--bg);
            padding: 2px;
        }

        #scanner-light {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid var(--fg);
            border-radius: 50%;
            background: transparent;
            transition: background 0.1s;
        }

        /* ZONE A: CONVEYOR BELT */
        .conveyor-track {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background: repeating-linear-gradient(
                90deg,
                var(--fg-dim),
                var(--fg-dim) 10px,
                transparent 10px,
                transparent 20px
            );
            transform: translateY(-50%);
            z-index: 1;
        }

        .stream-item {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            font-weight: bold;
            color: var(--fg);
            background: var(--bg);
            border: 1px solid var(--fg);
            padding: 10px;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
            box-shadow: 4px 4px 0 rgba(57, 255, 20, 0.2);
        }

        .stream-item.ignored {
            color: var(--fg-dim);
            border-color: var(--fg-dim);
            opacity: 0.5;
            box-shadow: none;
        }

        .stream-item.matched {
            background-color: var(--fg);
            color: var(--bg);
            box-shadow: 0 0 20px var(--fg);
            animation: consume 0.3s forwards;
        }

        @keyframes consume {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.5); }
            100% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        }

        /* OVERLAY: SUCCESS STATE */
        #success-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            backdrop-filter: blur(4px);
        }

        #success-overlay h1 {
            font-size: 8vw;
            border: 4px solid var(--fg);
            padding: 1rem 3rem;
            background: repeating-linear-gradient(
                45deg,
                var(--fg),
                var(--fg) 2px,
                var(--bg) 2px,
                var(--bg) 4px
            );
            color: var(--bg);
            text-shadow: none;
        }

        .optimization-note {
            margin-top: 2rem;
            font-size: 1.5rem;
            max-width: 600px;
            text-align: center;
            border-left: 4px solid var(--fg);
            padding-left: 1rem;
        }

        .arrow-pointer {
            position: absolute;
            bottom: 20%;
            left: 20%;
            font-size: 1.2rem;
            transform: rotate(-10deg);
            opacity: 0;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

    </style>
</head>
<body>

    <!-- ZONE C: DASHBOARD -->
    <div id="dashboard">
        <div class="dashboard-header">Target Needs Map [Frequency Count]</div>
        <div class="needs-grid" id="needs-container">
            <!-- Populated by JS -->
        </div>
    </div>

    <!-- ZONE A & B: STREAM -->
    <div id="stream-zone">
        <div class="conveyor-track"></div>
        
        <!-- ZONE B: SCANNER -->
        <div id="scanner">
            <div id="scanner-light"></div>
        </div>

        <!-- Items injected here by JS -->
    </div>

    <!-- SUCCESS OVERLAY -->
    <div id="success-overlay">
        <h1>TRUE</h1>
        <div class="optimization-note">
            ALL REQUIREMENTS MET.<br>
            EARLY EXIT TRIGGERED.<br>
            REMAINING STREAM IGNORED.
        </div>
        <div class="arrow-pointer" id="pointer">
            &larr; Note frozen items (CPU saved)
        </div>
    </div>

    <script>
        // CONFIGURATION
        const CONFIG = {
            speed: 3, // pixels per frame
            spawnRate: 60, // frames between spawns
            scannerPosPercent: 50, // scanner is at 50% screen width
            symbols: ['A', 'B', 'C', 'X', 'Y', 'Z', '7', '#', '@'],
            targetNeeds: { 'A': 4, 'B': 3, '@': 2 } // The "Map"
        };

        // STATE
        let streamItems = [];
        let frameCount = 0;
        let isRunning = true;
        let animationId;
        
        // DOM ELEMENTS
        const needsContainer = document.getElementById('needs-container');
        const streamZone = document.getElementById('stream-zone');
        const scannerLight = document.getElementById('scanner-light');
        const successOverlay = document.getElementById('success-overlay');
        const pointer = document.getElementById('pointer');

        // INITIALIZATION
        function init() {
            renderDashboard();
            loop();
        }

        // 1. MAP THE REQUIREMENTS
        function renderDashboard() {
            needsContainer.innerHTML = '';
            for (const [key, value] of Object.entries(CONFIG.targetNeeds)) {
                const div = document.createElement('div');
                div.className = 'need-item';
                div.id = `need-${key}`;
                div.innerHTML = `
                    <div class="need-icon">${key}</div>
                    <div class="need-count" id="count-${key}">${value}</div>
                `;
                needsContainer.appendChild(div);
            }
        }

        // 2. STREAM THE INVENTORY (Game Loop)
        function loop() {
            if (!isRunning) return;

            frameCount++;

            // Spawn new items
            if (frameCount % CONFIG.spawnRate === 0) {
                spawnItem();
            }

            // Move and Process items
            updateItems();

            animationId = requestAnimationFrame(loop);
        }

        function spawnItem() {
            // Randomly choose a symbol. 
            // Weighted slightly to ensure we actually finish the demo reasonably fast.
            const r = Math.random();
            let type;
            const needsKeys = Object.keys(CONFIG.targetNeeds);
            
            if (r > 0.5 && needsKeys.length > 0) {
                // 50% chance to spawn something we might need
                type = needsKeys[Math.floor(Math.random() * needsKeys.length)];
            } else {
                // 50% chance to spawn junk
                type = CONFIG.symbols[Math.floor(Math.random() * CONFIG.symbols.length)];
            }

            const el = document.createElement('div');
            el.className = 'stream-item';
            el.innerText = type;
            streamZone.appendChild(el);

            streamItems.push({
                element: el,
                type: type,
                x: -10, // Start just off-screen left (percent)
                processed: false
            });
        }

        // 3. MATCH AND DECREMENT
        function updateItems() {
            // Convert scanner position to pixels relative to stream zone
            const zoneWidth = streamZone.clientWidth;
            const scannerX = (CONFIG.scannerPosPercent / 100) * zoneWidth;

            // Iterate backwards to allow safe removal
            for (let i = streamItems.length - 1; i >= 0; i--) {
                const item = streamItems[i];
                
                // Update position (convert pixels to percent for responsive CSS)
                const currentPixelX = (item.x / 100) * zoneWidth;
                const newPixelX = currentPixelX + CONFIG.speed;
                item.x = (newPixelX / zoneWidth) * 100;
                
                item.element.style.left = `${item.x}%`;

                // Logic Check at Scanner Line
                if (!item.processed && newPixelX >= scannerX) {
                    item.processed = true;
                    processItem(item);
                }

                // Cleanup if off-screen right
                if (item.x > 110) {
                    item.element.remove();
                    streamItems.splice(i, 1);
                }
            }
        }

        function processItem(item) {
            const needCount = CONFIG.targetNeeds[item.type];

            if (needCount && needCount > 0) {
                // MATCH FOUND
                CONFIG.targetNeeds[item.type]--;
                
                // Update Dashboard
                const countEl = document.getElementById(`count-${item.type}`);
                countEl.innerText = CONFIG.targetNeeds[item.type];
                
                // Visuals: Item consumed
                item.element.classList.add('matched');
                
                // Visuals: Scanner flash
                scannerLight.style.backgroundColor = 'var(--fg)';
                setTimeout(() => scannerLight.style.backgroundColor = 'transparent', 100);

                // 4. REMOVE COMPLETED NEEDS
                if (CONFIG.targetNeeds[item.type] === 0) {
                    const needEl = document.getElementById(`need-${item.type}`);
                    needEl.classList.add('complete');
                    
                    // Remove key from map logic
                    delete CONFIG.targetNeeds[item.type];
                    
                    // Remove from DOM after animation
                    setTimeout(() => needEl.remove(), 500);
                    
                    // 5. EARLY EXIT CHECK
                    checkCompletion();
                }
            } else {
                // IGNORE / NO MATCH
                item.element.classList.add('ignored');
            }
        }

        function checkCompletion() {
            if (Object.keys(CONFIG.targetNeeds).length === 0) {
                // EARLY EXIT OPTIMIZATION
                stopSystem();
            }
        }

        function stopSystem() {
            isRunning = false;
            cancelAnimationFrame(animationId);
            
            // Show success overlay
            successOverlay.style.display = 'flex';
            
            // Point arrow only if there are items left on the belt
            const unprocessedItems = streamItems.filter(i => !i.processed);
            if (unprocessedItems.length > 0) {
                pointer.style.opacity = '1';
            } else {
                pointer.style.display = 'none';
            }
        }

        // Start
        window.onload = init;

    </script>
</body>
</html>