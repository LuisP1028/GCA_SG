<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protocol: CHAIN_SCANNER // RESPONSIVE</title>
    <style>
        :root {
            /* Palette */
            --bg: #050505;
            --fg: #00FF00;
            --dim: #004400;
            --highlight: #CCFF00;
            --err: #FF0033;
            --win: #D0F;
            
            /* Typography */
            --font-stack: 'Courier New', Courier, monospace;
            --text-base: clamp(15px, 1.5vw, 16px);
            --text-lg: clamp(16px, 2.5vw, 24px);
            
            /* Spacing */
            --gap-sm: 0.5rem;
            --gap-md: 1rem;
            --border-width: 2px;
        }

        * {
            box-sizing: border-box;
            user-select: none;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font-stack);
            font-size: var(--text-base);
            overflow: hidden; /* Prevent body scroll, let app handle it */
        }

        /* --- BACKGROUND FX --- */
        #dither-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.12;
            pointer-events: none;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.25) 50%,
                rgba(0,0,0,0.25)
            );
            background-size: 100% 4px;
            pointer-events: none;
        }

        /* --- MAIN LAYOUT --- */
        #app {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            height: 100vh; /* Full viewport height */
            width: 100vw;
            padding: clamp(10px, 2vw, 20px);
            gap: var(--gap-md);
            max-width: 2560px; /* Cap width on ultrawide for readability */
            margin: 0 auto;
        }

        /* --- 1. HEADER --- */
        header {
            flex: 0 0 auto; /* Don't shrink */
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            border-bottom: var(--border-width) solid var(--fg);
            padding-bottom: var(--gap-sm);
            gap: var(--gap-sm);
        }

        h1 {
            margin: 0;
            font-size: var(--text-lg);
            text-shadow: 0 0 5px var(--fg);
            text-transform: uppercase;
            letter-spacing: 2px;
            white-space: nowrap;
        }

        .controls {
            display: flex;
            gap: var(--gap-sm);
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            background: var(--bg);
            color: var(--fg);
            border: var(--border-width) solid var(--fg);
            padding: 0.5rem 1rem;
            font-family: var(--font-stack);
            font-weight: bold;
            font-size: 0.9em;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.1s;
        }

        button:hover {
            background: var(--fg);
            color: var(--bg);
            box-shadow: 0 0 10px var(--fg);
        }

        label { font-size: 0.8em; font-weight: bold;}

        input[type="range"] {
            -webkit-appearance: none;
            background: var(--dim);
            height: 6px;
            width: 80px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--fg);
            cursor: pointer;
        }

        /* --- 2. TEXT ZONE (Flexible) --- */
        #zone-text {
            flex: 1 1 auto; /* Grow to fill space */
            border: var(--border-width) solid var(--fg);
            padding: var(--gap-md);
            overflow-y: auto; /* Internal Scroll */
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
            gap: 0.5em 0.8em;
            background: rgba(0, 20, 0, 0.6);
            line-height: 1.6;
            font-size: 1.1em;
        }

        .word-node {
            position: relative;
            padding: 0.1em 0.3em;
            transition: background 0.1s;
        }

        .word-node small {
            position: absolute;
            top: -0.8em;
            left: 0;
            font-size: 0.6em;
            opacity: 0.5;
            pointer-events: none;
        }

        /* STATES */
        .cursor-active {
            background: var(--fg);
            color: var(--bg);
            box-shadow: 0 0 15px var(--fg);
            z-index: 10;
        }
        .is-keyword {
            border-bottom: 2px solid var(--highlight);
            color: var(--highlight);
            font-weight: bold;
        }
        .winning-span {
            background: rgba(208, 0, 255, 0.2);
            border: 1px solid var(--win);
            color: #fff;
            text-shadow: 0 0 5px var(--win);
        }

        /* --- 3. DASHBOARD (Responsive Grid) --- */
        #zone-dashboard {
            flex: 0 0 auto; /* Content based height, but creates the "middle" section */
            display: grid;
            /* Mobile: Stacked | Desktop: Side-by-Side */
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); 
            gap: var(--gap-md);
            border: var(--border-width) solid var(--fg);
            padding: var(--gap-md);
            background: rgba(0,0,0,0.85);
            min-height: 20vh;
        }

        /* Target List */
        .target-list {
            border: 1px dashed var(--dim);
            padding: var(--gap-sm);
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .target-header {
            font-weight: bold;
            margin-bottom: 0.5rem;
            text-decoration: underline;
        }
        .target-item { opacity: 0.5; margin-bottom: 0.25rem; }
        .target-item.active-target { opacity: 1; color: var(--highlight); text-shadow: 0 0 5px var(--highlight); }

        /* The Table */
        .matrix-container {
            overflow-x: auto; /* Allow table to scroll horizontally on very small screens */
            border: 1px solid var(--dim);
            padding: var(--gap-sm);
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 300px; /* Ensure columns don't collapse too much */
        }

        .data-table th, .data-table td {
            text-align: left;
            padding: 0.5em;
            border-bottom: 1px solid var(--dim);
        }

        .data-table th {
            color: var(--fg);
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.85em;
            letter-spacing: 1px;
            background: rgba(0, 50, 0, 0.3);
        }

        .row-updated { animation: flashRow 0.5s ease-out; }
        @keyframes flashRow {
            0% { background: var(--fg); color: var(--bg); }
            100% { background: transparent; color: var(--fg); }
        }

        /* --- 4. CONSOLE (Bottom Fixed Height) --- */
        #zone-console {
            flex: 0 0 15vh; /* Fixed percentage of height */
            min-height: 100px;
            max-height: 200px;
            border: var(--border-width) solid var(--fg);
            padding: var(--gap-sm);
            display: flex;
            flex-direction: column;
            font-size: 0.85em;
            background: #000;
        }

        .console-header {
            flex: 0 0 auto;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px dashed var(--dim);
            padding-bottom: 0.25rem;
            margin-bottom: 0.25rem;
        }

        .global-min-box {
            font-weight: bold;
            color: var(--highlight);
        }

        #log-feed {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .log-entry { word-wrap: break-word; }
        .log-entry::before { content: '>> '; opacity: 0.5;}
        .log-success { color: var(--highlight); }
        .log-fail { color: var(--err); }
        .log-win { color: var(--win); font-weight: bold; }

        /* --- MEDIA QUERIES for Edge Cases --- */
        @media (max-width: 600px) {
            h1 { font-size: 1.2rem; }
            .controls label { display: none; } /* Hide label to save space */
            #zone-dashboard { grid-template-columns: 1fr; } /* Force stack */
            .target-list { display: none; } /* Hide target list on strict mobile to prioritize table */
        }

    </style>
</head>
<body>

    <!-- VISUAL NOISE LAYERS -->
    <canvas id="dither-canvas"></canvas>
    <div class="scanlines"></div>

    <div id="app">
        
        <!-- 1. Header -->
        <header>
            <h1>Ordered Subarray Scanner</h1>
            <div class="controls">
                <label for="speed-slider">SPEED</label>
                <input type="range" id="speed-slider" min="50" max="1000" value="200">
                <button id="btn-toggle">START</button>
                <button id="btn-reset">RESET</button>
            </div>
        </header>

        <!-- 2. Text Stream -->
        <div id="zone-text" aria-label="Text Stream">
            <!-- Words injected via JS -->
        </div>

        <!-- 3. Dashboard -->
        <div id="zone-dashboard">
            <!-- Left: Target List -->
            <div class="target-list" id="target-list-display">
                <div class="target-header">TARGET SEQ:</div>
                <!-- Injected via JS -->
            </div>

            <!-- Right: The Matrix Table -->
            <div class="matrix-container">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Keyword</th>
                            <th>Last Index</th>
                            <th>Chain Length</th>
                        </tr>
                    </thead>
                    <tbody id="state-table-body">
                        <!-- Rows injected via JS -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- 4. System Console -->
        <div id="zone-console">
            <div class="console-header">
                <span>SYSTEM LOG</span>
                <span class="global-min-box">MIN SUBARRAY: <span id="global-min-val">∞</span></span>
            </div>
            <div id="log-feed"></div>
        </div>

    </div>

<script>
    /**
     * CONFIGURATION & DATA
     */
    const RAW_TEXT = "The code breaker attempted to crack the cipher. The first code was simple, but the second code was complex. Finally, the master breaker cracked the cipher.";
    const KEYWORDS = ["code", "breaker", "cipher"];
    const WORDS = RAW_TEXT.split(' ');

    // DOM Elements
    const elZoneText = document.getElementById('zone-text');
    const elTableBody = document.getElementById('state-table-body');
    const elTargetList = document.getElementById('target-list-display');
    const elLog = document.getElementById('log-feed');
    const elGlobalMin = document.getElementById('global-min-val');
    const btnToggle = document.getElementById('btn-toggle');
    const btnReset = document.getElementById('btn-reset');
    const sliderSpeed = document.getElementById('speed-slider');

    // State
    let isRunning = false;
    let timer = null;
    let currentIndex = 0;
    let globalMin = Infinity;
    let winningRange = null;

    // Algorithm State
    let lastIndices = new Array(KEYWORDS.length).fill(-1);
    let chainLengths = new Array(KEYWORDS.length).fill(0);

    /**
     * INITIALIZATION
     */
    function init() {
        // 1. Render Text
        elZoneText.innerHTML = '';
        WORDS.forEach((word, idx) => {
            const span = document.createElement('span');
            span.className = 'word-node';
            span.id = `w-${idx}`;
            span.innerHTML = `${word}<small>${idx}</small>`; // Added index number
            elZoneText.appendChild(span);
        });

        // 2. Render Targets
        // Keep header
        const header = elTargetList.firstElementChild;
        elTargetList.innerHTML = '';
        elTargetList.appendChild(header);

        KEYWORDS.forEach((kw, i) => {
            const div = document.createElement('div');
            div.className = 'target-item';
            div.id = `target-${i}`;
            div.textContent = `[${i}] ${kw.toUpperCase()}`;
            elTargetList.appendChild(div);
        });

        // 3. Render Table
        renderTable();
        
        // 4. Reset Globals
        currentIndex = 0;
        globalMin = Infinity;
        winningRange = null;
        lastIndices.fill(-1);
        chainLengths.fill(0);
        elGlobalMin.textContent = "∞";
        elLog.innerHTML = ''; 
        log("System Ready. Waiting for input.");
        
        // Ensure dither is sized correctly
        drawDither();
    }

    function renderTable() {
        elTableBody.innerHTML = '';
        KEYWORDS.forEach((kw, k) => {
            const tr = document.createElement('tr');
            tr.id = `row-${k}`;
            tr.innerHTML = `
                <td>${k}</td>
                <td>${kw.toUpperCase()}</td>
                <td id="cell-idx-${k}" style="font-family: monospace">-</td>
                <td id="cell-len-${k}" style="font-family: monospace">-</td>
            `;
            elTableBody.appendChild(tr);
        });
    }

    /**
     * CORE LOGIC
     */
    function step() {
        if (currentIndex >= WORDS.length) {
            stop();
            log("End of stream reached.", "log-success");
            return;
        }

        // 1. Visual Cursor
        if (currentIndex > 0) {
            const prev = document.getElementById(`w-${currentIndex-1}`);
            if(prev) prev.classList.remove('cursor-active');
        }
        const currentEl = document.getElementById(`w-${currentIndex}`);
        currentEl.classList.add('cursor-active');
        
        // Smart Scroll (Only scroll if out of view)
        const rect = currentEl.getBoundingClientRect();
        const containerRect = elZoneText.getBoundingClientRect();
        if (rect.bottom > containerRect.bottom || rect.top < containerRect.top) {
            currentEl.scrollIntoView({behavior: "smooth", block: "center"});
        }

        // 2. Normalize word
        const rawWord = WORDS[currentIndex];
        const cleanWord = rawWord.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").toLowerCase();

        // 3. Check Keyword
        const keywordRank = KEYWORDS.indexOf(cleanWord);

        if (keywordRank !== -1) {
            currentEl.classList.add('is-keyword');
            handleKeyword(keywordRank, currentIndex);
        }

        currentIndex++;
    }

    function handleKeyword(rank, idx) {
        log(`Found '${KEYWORDS[rank]}' (Rank ${rank}) at index ${idx}`);
        
        // Flash Dashboard Row
        const row = document.getElementById(`row-${rank}`);
        row.classList.remove('row-updated');
        void row.offsetWidth; 
        row.classList.add('row-updated');

        // Update Target List Highlight
        document.querySelectorAll('.target-item').forEach(el => el.classList.remove('active-target'));
        document.getElementById(`target-${rank}`).classList.add('active-target');

        // Logic
        if (rank === 0) {
            chainLengths[0] = 1;
            lastIndices[0] = idx;
            updateCell(0, idx, 1);
            log(`-> Rank 0 reset.`, 'log-success');
        } else {
            const prevLen = chainLengths[rank - 1];
            
            if (prevLen > 0) {
                const prevIdx = lastIndices[rank - 1];
                const distance = idx - prevIdx; 
                const newLen = prevLen + distance;

                chainLengths[rank] = newLen;
                lastIndices[rank] = idx;
                
                updateCell(rank, idx, newLen);
                log(`-> Linked Rank ${rank-1} to ${rank}. Length: ${newLen}`, 'log-success');
                
                highlightConnection(prevIdx, idx);

                if (rank === KEYWORDS.length - 1) {
                    checkWin(newLen, idx);
                }

            } else {
                log(`-> Broken Chain. Rank ${rank-1} invalid.`, 'log-fail');
                chainLengths[rank] = 0;
                lastIndices[rank] = -1;
                updateCell(rank, '-', '-');
            }
        }
    }

    function checkWin(totalLen, endIdx) {
        if (totalLen < globalMin) {
            globalMin = totalLen;
            elGlobalMin.textContent = globalMin;
            
            // Formula: Start = End - Length + 1
            const startIdx = endIdx - totalLen + 1;
            winningRange = { start: startIdx, end: endIdx };
            
            log(`*** NEW RECORD: ${totalLen} ***`, 'log-win');
            updateWinningVisuals();
        } else {
            log(`Complete but longer (${totalLen}).`);
        }
    }

    function updateCell(rank, idxVal, lenVal) {
        document.getElementById(`cell-idx-${rank}`).textContent = idxVal;
        document.getElementById(`cell-len-${rank}`).textContent = lenVal;
    }

    function highlightConnection(start, end) {
        for(let i=start+1; i<end; i++) {
             const el = document.getElementById(`w-${i}`);
             // Subtle visual trail
             el.style.backgroundColor = 'rgba(0, 255, 0, 0.1)';
             setTimeout(() => el.style.backgroundColor = '', 200);
        }
    }

    function updateWinningVisuals() {
        document.querySelectorAll('.winning-span').forEach(el => el.classList.remove('winning-span'));
        if(winningRange) {
            for(let i=winningRange.start; i<=winningRange.end; i++) {
                document.getElementById(`w-${i}`).classList.add('winning-span');
            }
        }
    }

    function log(msg, type='') {
        const div = document.createElement('div');
        div.className = `log-entry ${type}`;
        div.textContent = msg;
        elLog.appendChild(div);
        elLog.scrollTop = elLog.scrollHeight;
    }

    // Canvas Dither
    function drawDither() {
        const canvas = document.getElementById('dither-canvas');
        if(!canvas) return;
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const w = canvas.width;
        const h = canvas.height;
        const idata = ctx.createImageData(w, h);
        const buffer32 = new Uint32Array(idata.data.buffer);
        const len = buffer32.length;

        for (let i = 0; i < len; i++) {
            if (Math.random() < 0.15) {
                // Green pixel 0xff00ff00 (Little Endian: A B G R)
                buffer32[i] = 0xff00ff00; 
            }
        }
        ctx.putImageData(idata, 0, 0);
    }

    // Loops & Controls
    function start() {
        if(isRunning) return;
        isRunning = true;
        btnToggle.textContent = "PAUSE";
        const loop = () => {
            if(!isRunning) return;
            step();
            const delay = parseInt(sliderSpeed.value);
            timer = setTimeout(loop, delay);
        };
        loop();
    }

    function stop() {
        isRunning = false;
        btnToggle.textContent = "RESUME";
        clearTimeout(timer);
    }

    function toggle() {
        if(isRunning) stop();
        else start();
    }

    function reset() {
        stop();
        document.querySelectorAll('.word-node').forEach(el => {
            el.className = 'word-node';
            el.style.backgroundColor = '';
        });
        btnToggle.textContent = "START";
        init();
    }

    // Listeners
    btnToggle.addEventListener('click', toggle);
    btnReset.addEventListener('click', reset);
    window.addEventListener('resize', () => {
        drawDither();
    });

    // Boot
    init();

</script>
</body>
</html>