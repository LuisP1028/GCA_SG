<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Part III: Greedy Algorithms // Study Guide</title>
<style>
    /* 
       --- STYLE CONFIGURATION --- 
    */
    :root {
        --bg-color: #000000;
        --text-color: #00ff41;
        --accent-color: #00ff41;
        --dim-color: #003b00;
        --border-color: #00ff41;
        --font-main: 'Courier New', Courier, monospace;
        --font-header: 'Arial Black', Impact, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: var(--font-main);
        line-height: 1.5;
        overflow-x: hidden;
    }

    .dither-layer {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        z-index: -1;
        background-image: radial-gradient(circle, #003b00 1px, transparent 1px);
        background-size: 4px 4px;
        opacity: 0.4;
    }

    .scanlines {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(to bottom, rgba(0, 255, 65, 0), rgba(0, 255, 65, 0) 50%, rgba(0, 20, 0, 0.2) 50%, rgba(0, 20, 0, 0.2));
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 9999;
    }

    .container {
        max-width: 900px;
        width: 100%;
        margin: 0 auto;
        padding: 40px 20px;
        border-left: 2px dashed var(--dim-color);
        border-right: 2px dashed var(--dim-color);
        background-color: rgba(0, 10, 0, 0.9);
        min-height: 100vh;
    }

    h1 {
        font-family: var(--font-header);
        text-transform: uppercase;
        font-size: 2.5rem;
        border-bottom: 5px solid var(--accent-color);
        margin-bottom: 40px;
        color: var(--accent-color);
        text-align: center;
    }

    strong { color: var(--accent-color); text-decoration: underline; }
    em { font-style: normal; color: #50c878; border-bottom: 1px dotted var(--dim-color); }

    /* ACCORDION STYLES */
    details.section {
        margin-bottom: 15px;
        border: 1px solid var(--dim-color);
        background: #050505;
    }

    details.section > summary {
        font-family: var(--font-main);
        font-weight: bold;
        padding: 12px;
        background: #0a0a0a;
        color: var(--text-color);
        cursor: pointer;
        list-style: none;
        border-bottom: 1px solid transparent;
        text-transform: uppercase;
        font-size: 1.1rem;
    }

    details.section > summary:hover { background: var(--dim-color); color: var(--accent-color); }
    details.section[open] > summary {
        border-bottom: 1px solid var(--dim-color);
        background: #0f0f0f;
        color: var(--accent-color);
        text-shadow: 0px 0px 5px var(--accent-color);
    }

    .section-content { padding: 20px; }

    .subsection {
        margin-bottom: 25px;
        border-left: 4px solid var(--dim-color);
        padding-left: 15px;
    }

    .subsection-title {
        background: var(--dim-color);
        color: var(--accent-color);
        padding: 2px 6px;
        font-weight: bold;
        text-transform: uppercase;
        display: inline-block;
        margin-bottom: 10px;
        font-size: 0.9rem;
    }

    p { margin-bottom: 12px; margin-top: 0; text-align: justify; }
    ul { padding-left: 20px; margin-bottom: 15px; }
    li { margin-bottom: 5px; }

    .code-block {
        background: #020a02;
        border: 1px dashed var(--dim-color);
        padding: 10px;
        margin: 10px 0;
        font-family: 'Courier New', monospace;
        color: var(--accent-color);
        overflow-x: auto;
        white-space: pre-wrap;
    }
</style>
</head>
<body>

<div class="dither-layer"></div>
<div class="scanlines"></div>

<div class="container">
    <h1>Part III: Greedy Algorithms</h1>

    <div class="part-content">
        
        <details class="section">
            <summary>1. Interval Scheduling</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <div class="subsection-title">GREEDY ALGORITHMS</div>
                    <p>Identifying that a local optimal choice (pairing the current largest with the current smallest) leads to a global optimum. Recognizing when a Greedy approach works‚Äîand when it doesn't‚Äîis a core skill.</p>
                </div>

                <div class="subsection">
                    <div class="subsection-title">
                        Compute an Optimum Assignment of Tasks [Pairwise min-max pairing]
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Greedy/greedy_pairwise_minmax.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                
                    <p><strong>Step 1: Pre-Processing (Sorting)</strong></p>
                    <p>Sort the task durations in ascending order. This ranks the data, granting immediate access to the shortest and longest tasks required for the optimization strategy.</p>
                
                    <p><strong>Step 2: Greedy (Pairing short and long tasks)</strong></p>
                    <p>Pair the longest task with the shortest. This offsets the heaviest load with the lightest available addition, ensuring the combined pair total stays as low as possible.</p>
                
                    <p><strong>Step 3: Iterative Construction</strong></p>
                    <p>Continue this pattern by moving inward from both ends of the list. Match the next shortest task with the next longest until every task is paired and the schedule is complete.</p>
                
                    <p><strong>Validation: Why This Works</strong></p>
                    <p>Pairing extremes prevents heavy tasks from stacking. This balances the load, ensuring the maximum pair sum is minimized to achieve the lowest possible bottleneck for the schedule.</p>
                </div>

                <div class="subsection">
                    <div class="subsection-title">
                        Schedule to Optimize Waiting Time
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Greedy/minimize_waiting.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
                                <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                            </svg>
                        </button>
                    </div>
                    <p>If you run a long task first, every subsequent task must wait for that long task to finish, drastically increasing the cumulative waiting time.</p>
                    <p><strong>The Process:</strong></p>
                    <ol>
                        <li>Input: Receive an unsorted array of integers representing service durations.</li>
                        <li>Transformation: Apply a sorting algorithm to enforce a non-decreasing order.</li>
                        <li>Calculation: Iterate through the sorted array once. For each element, multiply its value by the count of elements remaining after it.</li>
                        <li>Output: Sum these products to return the minimum metric.</li>
                    </ol>
                    <p><strong>The Logic:</strong><br>
                    The logic relies on the weight of contribution.</p>
                    <ul>
                        <li>A query processed early contributes its service time to the waiting time of every query that follows it.</li>
                        <li>A query processed last contributes its service time to zero other queries (no one is waiting behind it).</li>
                        <li>Therefore, to minimize the total sum, the values with the highest multiplier (processed earliest) must be the smallest numbers.</li>
                    </ul>
                    
                </div>

<div class="subsection">
                    <div class="subsection-title">
                        INTERVAL COVERING
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Greedy/interval_covering.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
                                <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                            </svg>
                        </button>
                    </div>
                    <p><strong> Interval covering finds clusters where tasks overlap, to minimize unnecessary work.</strong></p>
                    <p><strong>[STRATEGY]</strong></p>
                    <p><strong>A. Focus on the "First Ending" Interval</strong><br>
                    Look at the entire set of intervals. Find the first task that ends earliest (has the minimum right endpoint).</p>
                    <p><strong>B. Select the Rightmost Point (Extremal Point)</strong><br>
                    <br> By picking the right endpoint, still covering the first-ending interval, we maximize the probability that this same point will also overlap with intervals starting later.</p>
                    <p><strong>THE HOW:</strong></p>
                    <p><strong>Step 1: Sort the Data</strong><br>
                    To implement the above logic efficiently, sort all intervals in the list based on their right endpoints in ascending order.</p>
                    <p><strong>Step 2: Iterate and Filter</strong><br>
                    This loop filters out tasks you have already done.</p>
                    <ul>
                        <li>The Test: Did this task start after your last visit?
                            <ul>
                                <li>Yes: You missed it. You must add a new visit (at this task's deadline) to catch it.</li>
                                <li>No: Your previous visit already caught it. You can safely ignore this task.</li>
                            </ul>
                        </li>
                    </ul>

                </div>

            </div>
        </details>

        <details class="section">
            <summary>2. Invariants & Optimality</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <div class="subsection-title">
                        3 SUM PROBLEM
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Greedy/3_sum.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
                                <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                            </svg>
                        </button>
                    </div>
                    <p>You are given a list of numbers and a target total. You must determine if any three numbers from that list add up to the target.</p>
                    
                    <p><strong>The Strategy</strong><br>
                    "Lock" one element to reduce the problem complexity. For each element, solve the 2-Sum subproblem: find two numbers summing to the remaining difference using the two-pointer technique.</p>
                
                    <p><strong>Phase 1: Preparation (Sorting)</strong><br>
                    Sort the array in non-decreasing order. This imposes a monotonic structure, allowing the two-pointer algorithm to efficiently traverse values based on the magnitude of the current sum.</p>
                
                    <p><strong>Phase 2: Reduction (Iteration)</strong><br>
                    Iterate through the array, selecting the current element a as the fixed candidate.</p>
                
                    <p><strong>Phase 3: The 2-Sum Subroutine</strong><br>
                    Initialize two pointers: low at index 0 and high at n-1. Because element repetition is permitted, the search range encompasses the entire array for every fixed candidate.</p>
                
                    <p><strong>The Loop (Convergence Logic)</strong><br>
                    While low ‚â§ high, calculate total = a + A[low] + A[high]. If total equals the target, return True. If total is too low, increment the low pointer; if too high, decrement the high pointer.</p>
                
                    <p><strong>Phase 4: Termination</strong><br>
                    If the outer iteration completes the traversal without the subroutine identifying a valid triplet, the solution space is exhausted. Return False to indicate no solution exists.</p>
                </div>

                <div class="subsection">
                    <div class="subsection-title">
                        FINDING MAJORITY ELEMENT
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Greedy/majority_element.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
                                <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                            </svg>
                        </button>
                    </div>
                    <p>A Majority Element is rigorously defined as an element that appears in strictly more than half of the positions</p>
                    <p><strong>The Logic of "Mutual Destruction"</strong><br>
                    The algorithm acts as a war of attrition. Mismatched elements are paired and eliminated. Since the Majority Element exceeds 50% of the input, even if every non-majority element successfully neutralizes one majority instance, the majority inevitably survives the elimination process to remain standing.</p>
                    <p><strong>Step 1: Establish State Variables</strong><br>
                    Initialize two variables: candidate to store the potential majority element, and count (integer) to track its current net surplus against other elements.</p>
                    <p><strong>Step 2: Begin Linear Scan</strong><br>
                    Iterate through the input_stream linearly. Process each element (it) sequentially, moving through the list one by one until the end of the stream is reached.</p>
                    <p><strong>Step 3: The Zero-Count Check</strong><br>
                    Check count. If it is 0, previous pairs have mutually destroyed each other. Immediately set the current element (it) as the new candidate and reset count to 1.</p>
                    <p><strong>Step 4: The Comparison</strong><br>
                    Compare it with candidate. If they match, increment count to reinforce the current hypothesis. If they differ, decrement count to pair and eliminate the distinct elements.</p>
                    <p><strong>Step 5: The Result</strong><br>
                    Upon completing the scan, the value remaining in candidate is the Majority Element, as it is the only element mathematically capable of surviving the pairwise elimination.</p>
                </div>

            </div>
        </details>

        <details class="section">
            <summary>3. Heuristics</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <div class="subsection-title">
                        MAXIMUM WATER TRAPPED BY VERTICALS
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Greedy/water.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
                                <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                            </svg>
                        </button>
                    </div>
                    <p><strong>The Goal:</strong><br>
                    You want to maximize this simple calculation:(Distance between the walls) √ó (Height of the shorter wall)</p>
                    <p><strong>Step 1: Initialize Pointers</strong><br>
                    Create two pointers, ùê¢ùê¢ and ùê£ùê£.<br>
                    - Set ùê¢ùê¢ to the very first index (0).<br>
                    - Set ùê£ùê£ to the very last index (ùëõ‚àí1).<br>
                    - Initialize a variable max_water to 0.</p>
                    <p><strong>Step 2: The Iterative Loop</strong><br>
                    Enter a loop that continues as long as ùê¢ùê¢ is strictly less than ùê£ùê£. This ensures we have a valid width.</p>
                    <p><strong>Step 3: Calculate Current Capacity</strong><br>
                    Inside the loop:<br>
                    1. Calculate the Width:<br>
                    (ùê£ ‚àí ùê¢).<br>
                    2. Determine the Height:<br>
                    The minimum value between heights[ùê¢] and heights[ùê£].<br>
                    3. Calculate Area:<br>
                    Width √ó Height.<br>
                    4. Update max_water:<br>
                    If this current Area is greater than the recorded max_water, overwrite it.</p>
                    <p><strong>Step 4: The Decision Logic (Greedy Elimination)</strong><br>
                    Compare the height of the line at ùê¢ùê¢ with the height of the line at ùê£ùê£.</p>
                    <p><strong>Scenario A: Left wall is shorter</strong><br>
                    The short left wall limits the water height. Keeping it while moving the right wall closer only shrinks width without gaining height. You must ditch the left wall to find a taller one.</p>
                    <p><strong>Scenario B: Right wall is shorter</strong><br>
                    The short right wall limits the water height. Keeping it while moving the left wall closer only shrinks width without gaining height. You must ditch the right wall to find a taller one.</p>
                    <p><strong>Scenario C: Walls are equal height</strong><br>
                    Both walls limit the height equally. Narrowing the gap while keeping either wall will only reduce the total water.</p>
                    <ul>
                        <li>You can safely discard either wall (usually the left) to continue searching.</li>
                    </ul>
                    <p><strong>Step 5: Return Result</strong><br>
                    Once i and j meet, the entire search space has been explored or logically eliminated. Return max_water</p>
                </div>

            </div>
        </details>

    </div>
</div>

</body>
</html>