<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Part III: Greedy Algorithms // Study Guide</title>
<style>
    /* 
       --- STYLE CONFIGURATION --- 
    */
    :root {
        --bg-color: #000000;
        --text-color: #00ff41;
        --accent-color: #00ff41;
        --dim-color: #003b00;
        --border-color: #00ff41;
        --font-main: 'Courier New', Courier, monospace;
        --font-header: 'Arial Black', Impact, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: var(--font-main);
        line-height: 1.5;
        overflow-x: hidden;
    }

    .dither-layer {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        z-index: -1;
        background-image: radial-gradient(circle, #003b00 1px, transparent 1px);
        background-size: 4px 4px;
        opacity: 0.4;
    }

    .scanlines {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(to bottom, rgba(0, 255, 65, 0), rgba(0, 255, 65, 0) 50%, rgba(0, 20, 0, 0.2) 50%, rgba(0, 20, 0, 0.2));
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 9999;
    }

    .container {
        max-width: 900px;
        width: 100%;
        margin: 0 auto;
        padding: 40px 20px;
        border-left: 2px dashed var(--dim-color);
        border-right: 2px dashed var(--dim-color);
        background-color: rgba(0, 10, 0, 0.9);
        min-height: 100vh;
    }

    h1 {
        font-family: var(--font-header);
        text-transform: uppercase;
        font-size: 2.5rem;
        border-bottom: 5px solid var(--accent-color);
        margin-bottom: 40px;
        color: var(--accent-color);
        text-align: center;
    }

    strong { color: var(--accent-color); text-decoration: underline; }
    em { font-style: normal; color: #50c878; border-bottom: 1px dotted var(--dim-color); }

    /* ACCORDION STYLES */
    details.section {
        margin-bottom: 15px;
        border: 1px solid var(--dim-color);
        background: #050505;
    }

    details.section > summary {
        font-family: var(--font-main);
        font-weight: bold;
        padding: 12px;
        background: #0a0a0a;
        color: var(--text-color);
        cursor: pointer;
        list-style: none;
        border-bottom: 1px solid transparent;
        text-transform: uppercase;
        font-size: 1.1rem;
    }

    details.section > summary:hover { background: var(--dim-color); color: var(--accent-color); }
    details.section[open] > summary {
        border-bottom: 1px solid var(--dim-color);
        background: #0f0f0f;
        color: var(--accent-color);
        text-shadow: 0px 0px 5px var(--accent-color);
    }

    .section-content { padding: 20px; }

    .subsection {
        margin-bottom: 25px;
        border-left: 4px solid var(--dim-color);
        padding-left: 15px;
    }

    .subsection-title {
        background: var(--dim-color);
        color: var(--accent-color);
        padding: 2px 6px;
        font-weight: bold;
        text-transform: uppercase;
        display: inline-block;
        margin-bottom: 10px;
        font-size: 0.9rem;
    }

    p { margin-bottom: 12px; margin-top: 0; text-align: justify; }
    ul { padding-left: 20px; margin-bottom: 15px; }
    li { margin-bottom: 5px; }

    .code-block {
        background: #020a02;
        border: 1px dashed var(--dim-color);
        padding: 10px;
        margin: 10px 0;
        font-family: 'Courier New', monospace;
        color: var(--accent-color);
        overflow-x: auto;
        white-space: pre-wrap;
    }
</style>
</head>
<body>

<div class="dither-layer"></div>
<div class="scanlines"></div>

<div class="container">
    <h1>Part III: Greedy Algorithms</h1>

    <div class="part-content">
        
        <details class="section">
            <summary>1. Interval Scheduling</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <div class="subsection-title">GREEDY ALGORITHMS</div>
                    <p>Identifying that a local optimal choice (pairing the current largest with the current smallest) leads to a global optimum. Recognizing when a Greedy approach works‚Äîand when it doesn't‚Äîis a core skill.</p>
                </div>

                <div class="subsection">
                    <div class="subsection-title">
                        Compute an Optimum Assignment of Tasks [Pairwise min-max pairing]
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Greedy/greedy_pairwise_minmax.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                    <p><strong>Step 1: Pre-Processing (Sorting)</strong></p>
                    <ul>
                        <li>Logic: To make efficient decisions, we need immediate access to the extremal values (the shortest and longest tasks).</li>
                        <li>Action: Apply a sorting algorithm to the input array task_durations.</li>
                        <li>Result: The array is now ordered ùê≠‚ÇÅ ‚â§ ùê≠‚ÇÇ ‚â§ ‚Ä¶ ‚â§ ùê≠‚Çô<br>This transforms the data from a random collection into a rank-ordered sequence, at a cost of O(ùëÅ log ùëÅ) time.</li>
                    </ul>
                    <p><strong>Step 2: Applying the Greedy Heuristic</strong></p>
                    <ul>
                        <li>Logic: The core insight is that the longest-duration task creates the highest risk of a bottleneck. To mitigate this risk, it must be paired with the task that adds the least additional time.</li>
                        <li>Action: Pair the element at index 0 (absolute minimum) with the element at index ùëõ‚àí1 (absolute maximum).</li>
                        <li>Validation ‚Äî Example durations: 1, 8, 9, 10
                        <br>- Pairing longest (10) with second-longest (9) ‚Üí burden = ‚ÇÅ‚Çâ
                        <br>- Pairing longest (10) with shortest (1) ‚Üí burden = ‚ÇÅ‚ÇÅ
                        <br>Crucial distinction: The optimum makespan is not necessarily achieved by always taking min + max.
                        <br>In this case the correct pairing is (1,10) and (8,9) ‚Üí sums 11 and 17 ‚Üí makespan = 17.
                        <br>Even though 11 is low, this strategy keeps the highest pair sum (17) as small as possible.</li>
                    </ul>
                    <p><strong>Step 3: Iterative Construction</strong></p>
                    <ul>
                        <li>Logic: Once the current longest and shortest tasks are paired, they are removed from consideration. This leaves a sub-problem of size ùëõ‚àí2 that has the same structure as the original problem.</li>
                        <li>Action: Proceed inward using two pointers (or a single index ùëñ).
                        <br>For iteration ùëñ (starting from 0):
                        <br>Pair array[ùëñ] with array[ùëõ‚àí1‚àíùëñ]</li>
                        <li>This process continues for ‚åäùëõ/2‚åã iterations (or until the middle is reached when ùëõ is odd).</li>
                    </ul>
                    <p>The final pairing is therefore:<br>(ùê≠‚ÇÅ, ùê≠‚Çô), (ùê≠‚ÇÇ, ùê≠‚Çô‚Çã‚ÇÅ), (ùê≠‚ÇÉ, ùê≠‚Çô‚Çã‚ÇÇ), ‚Ä¶</p>
                </div>

                <div class="subsection">
                    <div class="subsection-title">
                        Schedule to Optimize Waiting Time
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Greedy/minimize_waiting.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
                                <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                            </svg>
                        </button>
                    </div>
                    <p>If you run a long task first, every subsequent task must wait for that long task to finish, drastically increasing the cumulative waiting time.</p>
                    <ul>
                        <li>Conversely, if you run short tasks first, the subsequent tasks wait less. The solution requires arranging the input data to exploit this mathematical relationship.</li>
                    </ul>
                    <p><strong>The Process:</strong></p>
                    <ol>
                        <li>Input: Receive an unsorted array of integers representing service durations.</li>
                        <li>Transformation: Apply a sorting algorithm to enforce a non-decreasing order.</li>
                        <li>Calculation: Iterate through the sorted array once. For each element, multiply its value by the count of elements remaining after it.</li>
                        <li>Output: Sum these products to return the minimum metric.</li>
                    </ol>
                    <p><strong>The Logic:</strong><br>
                    The logic relies on the weight of contribution.</p>
                    <ul>
                        <li>A query processed early contributes its service time to the waiting time of every query that follows it.</li>
                        <li>A query processed last contributes its service time to zero other queries (no one is waiting behind it).</li>
                        <li>Therefore, to minimize the total sum, the values with the highest multiplier (processed earliest) must be the smallest numbers.</li>
                    </ul>
                    <p><strong>THE HOW:</strong></p>
                    <p><strong>Step 1: Sorting</strong><br>
                    Sort the list of tasks from shortest to longest. This is the most critical step: running quick tasks first minimizes the total time everyone else spends sitting in the queue.</p>
                    <p><strong>Step 2: The Loop</strong><br>
                    Start a loop to look at each task in your sorted list one by one. This sets up the process where you will evaluate the specific cost of each task in the sequence.</p>
                    <p><strong>Step 3: The Multiplier</strong><br>
                    Count how many tasks are stuck waiting behind the current one. For example, if there are 5 tasks total and you are processing the first one, there are 4 tasks waiting behind it.</p>
                    <p><strong>Step 4: The Math</strong><br>
                    Multiply the current task's duration by the number of waiting tasks (from Step 3). Add this result to your total. This calculates exactly how much wait time this specific task causes.</p>
                    <p><strong>Step 5: The Result</strong><br>
                    Once the loop finishes, the final sum is your answer. Return this number. It represents the lowest possible total waiting time for the entire group of tasks.</p>
                </div>

<div class="subsection">
                    <div class="subsection-title">
                        INTERVAL COVERING
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Greedy/interval_covering.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
                                <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                            </svg>
                        </button>
                    </div>
                    <p><strong>[STRATEGY]</strong></p>
                    <p><strong>A. Focus on the "First Ending" Interval</strong><br>
                    Look at the entire set of intervals. Find the first task that ends earliest. (has the minimum right endpoint).</p>
                    <p><strong>B. Select the Rightmost Point (Extremal Point)</strong><br>
                    To cover the interval identified in Step 1, pick its right endpoint.
                    <br>- Why? This is the greedy choice. By picking the latest possible time that still covers the first-ending interval, we maximize the probability that this same point will also overlap with intervals starting later.</p>
                    <p>IN OTHER WORDS: Tasks don't change; your visit time does.If you visit early, you miss tasks starting later.by waiting until the deadline, you wait for those later tasks to begin, so you can catch them and the first task simultaneously.</p>
                    <p><strong>THE HOW:</strong></p>
                    <p><strong>Step 1: Sort the Data</strong><br>
                    To implement the above logic efficiently, sort all intervals in the list based on their right endpoints in ascending order.</p>
                    <p><strong>Step 2: Iterate and Filter</strong><br>
                    This loop filters out tasks you have already done.</p>
                    <ul>
                        <li>The Test: Did this task start after your last visit?
                            <ul>
                                <li>Yes: You missed it. You must add a new visit (at this task's deadline) to catch it.</li>
                                <li>No: Your previous visit already caught it. You can safely ignore this task.</li>
                            </ul>
                        </li>
                    </ul>

                </div>

            </div>
        </details>

        <details class="section">
            <summary>2. Invariants & Optimality</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <div class="subsection-title">
                        3 SUM PROBLEM
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Greedy/3_sum.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
                                <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                            </svg>
                        </button>
                    </div>
                    <p>You are given a list of numbers and a target total. You must determine if any three numbers from that list add up to the target.</p>
                    <p><strong>The Strategy:</strong><br>
                    "Lock" one number first. Now, the problem changes: you only need to find two numbers that add up to the remaining amount needed. You repeat this "lock one, find two" process for every number in the list.</p>
                    <p><strong>Phase 1: Preparation (Sorting)</strong><br>
                    The algorithm begins by sorting A in non-decreasing order.
                    <br>‚Ä¢ Sorting establishes the monotonic property required for the two-pointer technique.</p>
                    <p><strong>Phase 2: Reduction (Iteration)</strong><br>
                    We iterate through each element a in the array. We treat the current a as the fixed candidate for the first number in the triple.</p>
                    <p><strong>Phase 3: The 2-Sum Subroutine (Two-Pointer Search)</strong><br>
                    For every fixed a, we execute a search for b and c using two indices (pointers), let's call them low and high.
                    <br>‚Ä¢ Initialization: Set low = 0 (start of array) and high = n - 1 (end of array).
                    <br>‚ó¶ Note: Because repetition is allowed, low starts at 0, not at the index of a.</p>
                    <p><strong>The Loop (Convergence Logic)</strong><br>
                    While low ‚â§ high:</p>
                    <p>1. Calculate Sum<br>
                    current_sum = A[low] + A[high]<br>
                    2. Check Match<br>
                    If current_sum = ùë°‚àíùëé<br>
                    ‚Üí Solution found. Return True.<br>
                    3. Branch 1 (Underflow)<br>
                    If current_sum < ùë°‚àíùëé<br>
                    ‚Üí Sum is too small.<br>
                    Since the array is sorted, increase the sum by selecting a larger value for the lower pointer.<br>
                    4. Branch 2 (Overflow)<br>
                    If current_sum > ùë°‚àíùëé<br>
                    ‚Üí Sum is too large.<br>
                    Since the array is sorted, decrease the sum by selecting a smaller value for the upper pointer.</p>
                    <p><strong>Phase 4: Termination</strong><br>
                    If the outer loop finishes checking all a values without the inner 2-Sum subroutine returningTrue, then no such triple exists.</p>
                </div>

                <div class="subsection">
                    <div class="subsection-title">
                        FINDING MAJORITY ELEMENT
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Greedy/majority_element.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
                                <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                            </svg>
                        </button>
                    </div>
                    <p>A Majority Element is rigorously defined as an element that appears in strictly more than half of the positions</p>
                    <p><strong>The Logic of "Mutual Destruction"</strong><br>
                    The Boyer-Moore Voting Algorithm functions as a war of attrition.</p>
                    <ul>
                        <li>Every time the algorithm finds two different elements (a mismatch), it performs Elimination.</li>
                        <li>It effectively says: "I will remove one Instance of the Candidate and one Instance of a Non-Candidate."</li>
                    </ul>
                    <p>If the Majority Element makes up more than 50% of the army, and every single enemy (Non-Candidate) manages to kill one Majority soldier, the Majority will still have soldiers left standing at the end.</p>
                    <p><strong>Step 1: Establish State Variables</strong><br>
                    We allocate memory for two variables only:<br>
                    1. candidate: Stores the specific string currently suspected to be the majority.<br>
                    2. candidate_count: An integer acting as a counter for the candidate.</p>
                    <p><strong>Step 2: Begin Linear Scan (The Loop)</strong><br>
                    We begin iterating through the input_stream. For every element it (iterator) in the sequence, we perform a logic check. It verifies whether the input stream contains a subsequent element to process.</p>
                    <p><strong>Step 3: The Zero-Count Check (Reset Mechanism)</strong><br>
                    Logic: If candidate_count is 0, it implies that all previous elements have effectively cancelled each other out (or we are at the start).</p>
                    <p><strong>Step 4: The Comparison</strong><br>
                    If the count is positive, compare the current element (it) with the candidate:</p>
                    <ul>
                        <li>Scenario A (Match): If candidate == it, reinforce the current hypothesis by incrementing the count by 1.</li>
                        <li>Scenario B (Mismatch): If candidate != it, pair the distinct elements to cancel them out by decrementing the count by 1. (A zero count will trigger a reset in the next step).</li>
                    </ul>
                    <p><strong>Step 5: The Result</strong><br>
                    When the list is finished, the string left in your candidate variable is the answer, thanks to the logic of mutual destruction.</p>
                </div>
                
                <div class="subsection">
                    <div class="subsection-title">
                        FINDING MINIMUM IN ROTATED ARRAY
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'BinarySearch/min_element.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
                                <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                            </svg>
                        </button>
                    </div>
                    <p><strong>Step 1: Initialize Boundaries</strong><br>
                    We define the entire array as the search area. We place a 'left' marker at the very beginning (index 0) and a 'right' marker at the very end to bracket the smallest number.</p>
                    <p><strong>Step 2: The Loop Condition</strong><br>
                    Run the search while 'left' is strictly less than 'right'. We aren't looking for a missing value; we are narrowing down to a single survivor. When the markers meet, the loop stops.</p>
                    <p><strong>Step 3: Calculate Midpoint</strong><br>
                    We cut the range in half by adding 'left' and 'right' and dividing by two (integer division). This gives us the center index of the current search space.</p>
                    <p><strong>Step 4: The Comparison (Pivot Logic)</strong><br>
                    We compare the middle element against the rightmost element to determine where the rotation break occurs:</p>
                    <ul>
                        <li><strong>Case A (The "Broken" Sequence):</strong> If mid > right, the drop to the minimum happens to the right. We move the start to <code>mid + 1</code>.</li>
                        <li><strong>Case B (The "Sorted" Sequence):</strong> If mid &le; right, the minimum is either at <code>mid</code> or to its left. We set the end to <code>mid</code>, discarding the right half.</li>
                    </ul>
                    <p><strong>Step 5: Termination and Return</strong><br>
                    The loop repeats, halving the range, until 'left' and 'right' converge on the same index. Since we never discard the minimum, this final spot holds the answer.</p>
                </div>

                <div class="subsection">
                    <div class="subsection-title">The Gasup Problem</div>
                    <ul>
                        <li>The Goal: Find the one specific city where, if you start there with an empty tank, you will never run out of gas during the trip.</li>
                    </ul>
                    <p><strong>Step 1: Conceptual Initialization</strong><br>
                    We assume we start at the first city (Index 0) with 0 gallons of gas. Mathematically we will track the deficit</p>
                    <p><strong>Step 2: Linear Traversal</strong><br>
                    We iterate through the cities from ùëñ = 1 to ùëõ‚àí1. At each step, we calculate the fuel status as if we had traveled from the previous city</p>
                    <p><strong>Step 3: Calculating the Running Balance</strong><br>
                    For every city, we update a running variable (let‚Äôs call it remaining_gallons, representing the net fuel change after leaving the previous city and arriving at the current one.</p>
                    <p><strong>Step 4: Identifying the Global Minimum</strong><br>
                    We maintain a record of the minimum fuel level observed so far (min_gas) and the city index where that minimum occurred (min_city).</p>
                    <ul>
                        <li>Logic: If the remaining_gallons drops to a value lower than we have ever seen before, it means the stretch of road leading up to this specific city is the most resource-draining part of the loop relative to our start at Index 0.</li>
                    </ul>
                    <p><strong>Step 5: Selection of the Minimum City</strong><br>
                    By making this ‚Äúminimum city‚Äù the starting point, we define the baseline. Since this was the lowest point in the sequence, setting this point to 0 (by starting there) guarantees that all subsequent points in the sequence will be ‚â• 0.</p>
                    <p><strong>Step 6: The Return</strong><br>
                    Return the min_city identified in Step 4.</p>
                </div>

            </div>
        </details>

        <details class="section">
            <summary>3. Heuristics</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <div class="subsection-title">
                        MAXIMUM WATER TRAPPED BY VERTICALS
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Greedy/water.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
                                <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                            </svg>
                        </button>
                    </div>
                    <p><strong>The Goal:</strong><br>
                    You want to maximize this simple calculation:(Distance between the walls) √ó (Height of the shorter wall)</p>
                    <p><strong>Step 1: Initialize Pointers</strong><br>
                    Create two pointers, ùê¢ùê¢ and ùê£ùê£.<br>
                    - Set ùê¢ùê¢ to the very first index (0).<br>
                    - Set ùê£ùê£ to the very last index (ùëõ‚àí1).<br>
                    - Initialize a variable max_water to 0.</p>
                    <p><strong>Step 2: The Iterative Loop</strong><br>
                    Enter a loop that continues as long as ùê¢ùê¢ is strictly less than ùê£ùê£. This ensures we have a valid width.</p>
                    <p><strong>Step 3: Calculate Current Capacity</strong><br>
                    Inside the loop:<br>
                    1. Calculate the Width:<br>
                    (ùê£ ‚àí ùê¢).<br>
                    2. Determine the Height:<br>
                    The minimum value between heights[ùê¢] and heights[ùê£].<br>
                    3. Calculate Area:<br>
                    Width √ó Height.<br>
                    4. Update max_water:<br>
                    If this current Area is greater than the recorded max_water, overwrite it.</p>
                    <p><strong>Step 4: The Decision Logic (Greedy Elimination)</strong><br>
                    Compare the height of the line at ùê¢ùê¢ with the height of the line at ùê£ùê£.</p>
                    <p><strong>Scenario A: Left wall is shorter</strong><br>
                    The short left wall limits the water height. Keeping it while moving the right wall closer only shrinks width without gaining height. You must ditch the left wall to find a taller one.</p>
                    <p><strong>Scenario B: Right wall is shorter</strong><br>
                    The short right wall limits the water height. Keeping it while moving the left wall closer only shrinks width without gaining height. You must ditch the right wall to find a taller one.</p>
                    <p><strong>Scenario C: Walls are equal height</strong><br>
                    Both walls limit the height equally. Narrowing the gap while keeping either wall will only reduce the total water.</p>
                    <ul>
                        <li>You can safely discard either wall (usually the left) to continue searching.</li>
                    </ul>
                    <p><strong>Step 5: Return Result</strong><br>
                    Once i and j meet, the entire search space has been explored or logically eliminated. Return max_water</p>
                </div>

            </div>
        </details>

    </div>
</div>

</body>
</html>