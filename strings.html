<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Part V: Strings // Study Guide</title>
<style>
    /* 
       --- STYLE CONFIGURATION --- 
    */
    :root {
        --bg-color: #000000;
        --text-color: #00ff41;
        --accent-color: #00ff41;
        --dim-color: #003b00;
        --border-color: #00ff41;
        --font-main: 'Courier New', Courier, monospace;
        --font-header: 'Arial Black', Impact, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: var(--font-main);
        line-height: 1.5;
        overflow-x: hidden;
    }

    .dither-layer {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        z-index: -1;
        background-image: radial-gradient(circle, #003b00 1px, transparent 1px);
        background-size: 4px 4px;
        opacity: 0.4;
    }

    .scanlines {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(to bottom, rgba(0, 255, 65, 0), rgba(0, 255, 65, 0) 50%, rgba(0, 20, 0, 0.2) 50%, rgba(0, 20, 0, 0.2));
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 9999;
    }

    .container {
        max-width: 900px;
        width: 100%;
        margin: 0 auto;
        padding: 40px 20px;
        border-left: 2px dashed var(--dim-color);
        border-right: 2px dashed var(--dim-color);
        background-color: rgba(0, 10, 0, 0.9);
        min-height: 100vh;
    }

    h1 {
        font-family: var(--font-header);
        text-transform: uppercase;
        font-size: 2.5rem;
        border-bottom: 5px solid var(--accent-color);
        margin-bottom: 40px;
        color: var(--accent-color);
        text-align: center;
    }

    strong { color: var(--accent-color); text-decoration: underline; }
    em { font-style: normal; color: #50c878; border-bottom: 1px dotted var(--dim-color); }

    /* ACCORDION STYLES */
    details.section {
        margin-bottom: 15px;
        border: 1px solid var(--dim-color);
        background: #050505;
    }

    details.section > summary {
        font-family: var(--font-main);
        font-weight: bold;
        padding: 12px;
        background: #0a0a0a;
        color: var(--text-color);
        cursor: pointer;
        list-style: none;
        border-bottom: 1px solid transparent;
        text-transform: uppercase;
        font-size: 1.1rem;
    }

    details.section > summary:hover { background: var(--dim-color); color: var(--accent-color); }
    details.section[open] > summary {
        border-bottom: 1px solid var(--dim-color);
        background: #0f0f0f;
        color: var(--accent-color);
        text-shadow: 0px 0px 5px var(--accent-color);
    }

    .section-content { padding: 20px; }

    .subsection {
        margin-bottom: 25px;
        border-left: 4px solid var(--dim-color);
        padding-left: 15px;
    }

    .subsection-title {
        background: var(--dim-color);
        color: var(--accent-color);
        padding: 2px 6px;
        font-weight: bold;
        text-transform: uppercase;
        display: inline-block;
        margin-bottom: 10px;
        font-size: 0.9rem;
    }

    p { margin-bottom: 12px; margin-top: 0; text-align: justify; }
    ul { padding-left: 20px; margin-bottom: 15px; }
    li { margin-bottom: 5px; }

    .code-block {
        background: #020a02;
        border: 1px dashed var(--dim-color);
        padding: 10px;
        margin: 10px 0;
        font-family: 'Courier New', monospace;
        color: var(--accent-color);
        overflow-x: auto;
        white-space: pre-wrap;
    }
</style>
</head>
<body>

<div class="dither-layer"></div>
<div class="scanlines"></div>

<div class="container">
    <h1>Part V: Strings</h1>

    <div class="part-content">
        
        <details class="section">
            <summary>1. Palindromes & Anagrams</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <div class="subsection-title">
                        PALINDROMIC STRINGS
                        <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Searching/palindrome.html'; document.querySelector('.retro-viewport').classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                    <p>A sequence of characters that reads the exact same forwards and backwards.</p>
                    <p><strong>THE HOW:</strong></p>
                    <p><strong>Step 1: Initialization</strong><br>
                    Create two pointers to track position. Set the Left index to the start of the string (0) and the Right index to the very last character.</p>
                    <p><strong>Step 2: The Convergence Loop</strong><br>
                    Begin a loop that continues running only as long as the Left index remains positioned strictly before the Right index.</p>
                    <p><strong>Step 3: Left-Side Sanitization</strong><br>
                    Advance the Left pointer forward to skip any non-alphanumeric characters (like symbols or spaces), stopping immediately if it meets the Right pointer.</p>
                    <p><strong>Step 4: Right-Side Sanitization</strong><br>
                    Move the Right pointer backward to skip any non-alphanumeric characters, stopping immediately if it meets the Left pointer.</p>
                    <p><strong>Step 5: Normalization and Comparison</strong><br>
                    Convert the found characters to the same case and compare them. If they are different, the pattern is broken; return False immediately.</p>
                    <p><strong>Step 6: Convergence</strong><br>
                    If the characters match, narrow the search window by moving the Left pointer one step forward and the Right pointer one step backward.</p>
                    <p><strong>Step 7: Termination</strong><br>
                    If the pointers meet or cross without ever triggering a mismatch, the string is verified as a palindrome. Return True.</p>
                </div>

            </div>
        </details>

        <details class="section">
            <summary>2. Pattern Matching</summary>
            <div class="section-content">
                <div class="subsection">
                    <div class="subsection-title">
                        REPLACE AND REMOVE [Two Pass Algorithm]
                        <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Searching/replace_and_remove.html'; document.querySelector('.retro-viewport').classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                    <p>The problem asks you to modify a character array within its existing memory footprint (in-place). You must iterate through the array to delete all instances of the character 'b' and replace every instance of the character 'a' with two 'd's. The array has sufficient physical capacity to hold the resulting longer string</p>
                    <p>The optimal solution utilizes a two-pass algorithm.</p>
                    <ol>
                        <li>Pass One (Forward - "Filter and Count"):<br>Iterate from the start to the end. Remove 'b's by shifting valid characters to the left (compacting the array) and count the number of 'a's to calculate the final required length.</li>
                        <li>Pass Two (Backward - "Expand and Substitute"):<br>Iterate from the end of the compacted data backwards. Move characters to their final positions. If the character is 'a', write two 'd's; otherwise, copy the character. This backward approach prevents the expansion of 'a' into 'dd' from overwriting subsequent characters that have not yet been moved.</li>
                    </ol>
                </div>
                <p><strong>THE HOW: EXPANDED</strong></p>
                <p><strong>Phase 1: Filter and Count</strong></p>
                <ol>
                    <li>Initialize a read pointer and a write pointer at the start of the array, and set an a_count variable to zero.</li>
                    <li>Iterate through the array using the read pointer.</li>
                    <li>If the current character is 'b', ignore it and continue.</li>
                    <li>If the character is not 'b', copy it to the write pointer's location and move write forward.</li>
                    <li>Whenever you copy an 'a', increment the a_count.</li>
                    <li>Once finished, the write pointer marks the end of the compacted data, effectively deleting all 'b's.</li>
                </ol>
                <p><strong>Phase 2: Expand in Reverse</strong></p>
                <ol>
                    <li>Calculate the final string length by adding a_count to the current size of the compacted data.</li>
                    <li>Place a read pointer at the end of the compacted data and a write pointer at the very end of the new total capacity.</li>
                    <li>Iterate backward through the array.</li>
                    <li>If the read pointer encounters an 'a', insert two 'd's at the write position and move write back two steps.</li>
                    <li>If it encounters any other character, simply copy it to the write position and move write back one step.</li>
                    <li>Continue until the read pointer reaches the start, ensuring expansion happens without overwriting unprocessed data.</li>
                </ol>
            </div>
        </details>

                <div class="subsection">
                    <div class="subsection-title">
                        REVERSE WORDS IN A SENTENCE [DOUBLE REVERSAL]
                        <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Searching/Double_Reversal.html'; document.querySelector('.retro-viewport').classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                    <p>We need to take a sentence (a mutable sequence of characters) and rearrange the words so the last word becomes the first, the second-to-last becomes the second, and so on.</p>
                    <p>The strategy rundown:<br>
                    Reversing the entire data structure moves the words to their correct relative areas, but leaves the words themselves backward. We then iterate through the sentence and flip each individual word back to its correct forward readability.</p>
                    <ol>
                        <li>Total Inversion: The state of the entire system is inverted.</li>
                        <li>Linear Scanning: The system is traversed from index 0 to (n)</li>
                        <li>Boundary Detection: The scanner looks for the Sentinel (space).</li>
                        <li>Segmented Inversion: When a boundary is found, the specific segment (word) defined by the previous and current pointers is inverted again.</li>
                    </ol>
                </div>
                <div>
                    <p><strong>THE HOW:</strong></p>
                    <p><strong>Phase 1: The Global Transposition</strong></p>
                    <p><strong>Step 1:</strong><br>
                    Receive the input as a mutable bytearray s.</p>
                    <p><strong>Step 2:</strong><br>
                    Reverse the entire bytearray. This moves words to their correct relative positions, but the characters within each word remain backward (e.g., "ram is costly" becomes "yltsoc si mar").</p>
                    <p><strong>Phase 2: The Iterative Correction</strong></p>
                    <p><strong>Step 3:</strong><br>
                    Initialize a start pointer at index 0 and begin a loop to scan through the array.</p>
                    <p><strong>Step 4:</strong><br>
                    Inside the loop, search for the next space character (b' ') beginning from the current start position. Assign this index to end.</p>
                    <p><strong>Step 5:</strong><br>
                    If a space is found, reverse the segment between start and end to correct the word (e.g., "yltsoc" to "costly"). Then, move start to end + 1 to prepare for the next word.</p>
                    <p><strong>Step 6:</strong><br>
                    If no space is found, it means the end of the array has been reached. Break the loop to handle the final word separately.</p>
                    <p><strong>FINALLY:</strong></p>
                    <p><strong>Step 7:</strong><br>
                    Since the last word lacks a trailing space, it wasn't processed in the loop. Reverse the remaining segment from start to the end of the array to fix this final word.</p>
                    </div>

            </div>
        </details>

        <details class="section">
            <summary>3. Parsing & Formatting</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <div class="subsection-title">INTERCONVERT STRINGS AND INTEGERS</div>
                    <p><strong>Part 1: Integer to String</strong><br>
                    We convert the number backward, extracting one digit at a time starting from the ones place.</p>
                    <ol>
                        <li>Handle the Sign If the number is negative, record that fact and convert the number to positive so the math is simpler.</li>
                        <li>Extract Digits Use the modulo operator (x % 10) to isolate the last digit.</li>
                        <li>Convert to Character Transform the single digit (0-9) into its character representation (e.g., chr(ord('0') + digit)).</li>
                        <li>Store Append this character to a list. We use a list because adding to the end is computationally fast.</li>
                        <li>Shift Divide the number by 10 (x // 10) to remove the digit you just processed. Repeat until the number hits 0.</li>
                        <li>Finalize Since we processed the last digit first, our list is backward. Reverse the list, join it into a string, and re-add the negative sign if needed.</li>
                    </ol>
                    <p>Example: We process the number backward. For 347:</p>
                    <ul>
                        <li>%10 → Extract 7, add to list ['7']</li>
                        <li>Shift: 347 // 10 → 34</li>
                        <li>%10 → Extract 4, add to list ['7', '4']</li>
                        <li>Shift: 34 // 10 → 3</li>
                        <li>%10 → Extract 3, add to list ['7', '4', '3']</li>
                    </ul>
                    <p><strong>Part 2: String to Integer [HORNER’S METHOD]</strong><br>
                    We build the number forward, reading from left to right.</p>
                    <ol>
                        <li>Check Sign Look at the first character. If it is '−', mark the result as negative and begin processing at the second character.</li>
                        <li>Accumulate Initialize a variable total = 0.</li>
                        <li>Loop For each digit character in the string: • Shift left: total ← total × 10 • Add: total ← total + (current character as integer)</li>
                        <li>To convert "314", start with a total of 0. Read from left to right. For each new digit, multiply the total by 10 to “shift” the existing numbers to the left, then add the new digit.
                            <br>a. Digit '3': Shift: 0 × 10 = 0 Add 3 Total: 3
                            <br>b. Digit '1': Shift: 3 × 10 = 30 Add 1 Total: 31
                            <br>c. Digit '4': Shift: 31 × 10 = 310 Add 4 Total: 314</li>
                        <li>Result If the original string began with '−', apply the negative sign to the final total.</li>
                    </ol>
                </div>

                <div class="subsection">
                    <div class="subsection-title">IMPLEMENTING RUN LENGTH ENCODING</div>
                    <p>Run-Length Encoding (RLE) is a lossless data compression algorithm. It reduces the size of data by replacing consecutive repeating characters with a single instance of that character and a count of how many times it repeats.</p>
                    <p>The problem requires two distinct operations:</p>
                    <ol>
                        <li>Compression (Encoding): traversing a raw string (e.g., "AAA") and converting it into a serialized format consisting of a repetition count followed by the character (e.g., "3A").</li>
                        <li>Decompression (Decoding): Parsing a serialized string (e.g., "12B") to reconstruct the original sequence (e.g., "BBBBBBBBBBBB").</li>
                    </ol>
                    <p><strong>STEP-BY-STEP</strong></p>
                    <p><strong>THE ENCODER</strong></p>
                    <ol>
                        <li>Initialization:
                            <ul>
                                <li>result (list): The buffer for our output strings.</li>
                                <li>count (integer): The counter for the current run. It starts at 1 because if a character exists, we have at least one of them.</li>
                            </ul>
                        </li>
                        <li>Iteration with Look-Behind:
                            <ul>
                                <li>We iterate using an index i from 1 up to len(s) (inclusive).</li>
                                <li>To know when a group of identical items ends, you check the item behind you.</li>
                            </ul>
                        </li>
                        <li>Comparison (Checking for end):<br>To see if the current run has ended, check:
                            <ul>
                                <li>i == len(s): We have reached the boundary (end of string).</li>
                                <li>OR</li>
                                <li>s[i] != s[i - 1]: The current character is different from the previous character (signal change).</li>
                            </ul>
                        </li>
                        <li>Handling the State:<br>If the character changes: The previous group is finished. Save the count and that previous character (e.g., "3a"), then reset the count to 1 for the new letter.<br>If the character is the same: The group is still growing. Just add 1 to the count.</li>
                    </ol>
                    <p><strong>THE DECODER</strong></p>
                    <ol>
                        <li>Initialization: We establish two state variables:
                            <ul>
                                <li>count (integer): An accumulator for the numeric value of the repetition, initialized to 0.</li>
                                <li>result (list): A buffer to store the expanded string segments.</li>
                            </ul>
                        </li>
                        <li>Iteration: We loop through every character c in the input strings</li>
                        <li>The Logical Bifurcation (DIGITS VS LETTERS):</li>
                    </ol>
                    <ul>
                        <li>If digit: We are currently parsing the repetition count.<br>Process: We must update the count accumulator using Base-10 reconstruction.
                            <ul>
                                <li>Why: We are building a count. We use Base 10 logic because the computer reads "53" as two separate characters: '5' then '3'.</li>
                            </ul>
                        </li>
                        <li>If letter: We have encountered the entity to be repeated. This signals the end of the current token. We perform string multiplication (c * count) to create the run. We append this run to the result list.</li>
                    </ul>
                </div>

            </div>
        </details>

    </div>
</div>

</body>
</html>