<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ditherpunk Min/Max Visualizer</title>
    <style>
        :root {
            --bg: #050505;
            --fg: #00ff00;
            --dim: #004400;
            --font: 'Courier New', Courier, monospace;
            
            /* Fluid sizing variables */
            --block-size: clamp(2.5rem, 10vw, 5rem);
            --font-sm: clamp(0.7rem, 1.5vw, 0.9rem);
            --font-md: clamp(0.9rem, 2vw, 1.2rem);
            --font-lg: clamp(1.2rem, 3vw, 2rem);
            --gap-std: clamp(0.5rem, 2vw, 1.5rem);
        }

        /* RESET & BASE */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font);
            margin: 0;
            padding: clamp(0.5rem, 2vw, 1.5rem);
            height: 100dvh; /* Dynamic viewport height for mobile */
            width: 100vw;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* App-like feel */
            font-weight: bold;
            font-size: var(--font-md);
        }

        /* Dither Pattern Generators */
        .dither-bg {
            background-image: radial-gradient(var(--fg) 15%, transparent 16%),
                              radial-gradient(var(--fg) 15%, transparent 16%);
            background-size: 4px 4px;
            background-position: 0 0, 2px 2px;
            opacity: 0.3;
        }

        /* HEADER */
        header {
            flex: 0 0 auto;
            border-bottom: 2px solid var(--fg);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
            font-size: var(--font-lg);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* MAIN LAYOUT CONTAINER */
        #container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: var(--gap-std);
            position: relative;
            min-height: 0; /* Important for flex nested scrolling */
        }

        /* 1. ARRAY STRIP */
        #array-strip {
            flex: 0 0 auto;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border: 1px dashed var(--dim);
            /* Handle overflow if data array is large */
            overflow-x: auto;
            scrollbar-width: none; 
        }

        /* Unified Block Style */
        .block {
            width: var(--block-size);
            height: auto;
            aspect-ratio: 1 / 1;
            border: 2px solid var(--fg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--font-lg);
            position: relative;
            background-color: var(--bg);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            flex-shrink: 0; /* Prevent squishing */
        }

        .block.active {
            background-color: var(--fg);
            color: var(--bg);
            box-shadow: 0.25rem 0.25rem 0px var(--dim);
            transform: translate(-2px, -2px);
        }

        .block.processed {
            opacity: 0.5;
            border-style: dotted;
        }

        /* 2. BATTLEFIELD (CPU) - The flexible spacer */
        #battlefield {
            flex: 1; /* Grows to fill available space */
            border: 2px solid var(--fg);
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            background: linear-gradient(rgba(0,255,0,0.05) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(0,255,0,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            min-height: 150px; /* Minimum breathing room */
        }

        .battle-label {
            position: absolute;
            top: 0;
            left: 0;
            background: var(--bg);
            padding: 0.2rem 0.5rem;
            border-right: 1px solid var(--fg);
            border-bottom: 1px solid var(--fg);
            font-size: var(--font-sm);
            letter-spacing: 1px;
        }

        .stage-area {
            display: flex;
            gap: clamp(1rem, 5vw, 4rem);
            align-items: center;
            margin-bottom: 1rem;
            width: 100%;
            justify-content: center;
        }

        .stage-col {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .comparator {
            font-size: clamp(1.5rem, 5vw, 3rem);
            font-weight: bold;
            color: var(--dim);
            text-shadow: 0 0 5px var(--fg);
        }

        .role-label {
            font-size: var(--font-sm);
            margin-top: 0.5rem;
            text-align: center;
            text-transform: uppercase;
        }

        /* 3. REGISTRY (MIN/MAX) */
        #registry {
            flex: 0 0 auto;
            display: flex;
            justify-content: space-around;
            padding: 1rem 0;
            border-top: 1px solid var(--fg);
            background: rgba(0, 20, 0, 0.5);
        }

        .reg-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 45%;
        }

        .reg-box span {
            font-size: var(--font-sm);
            margin-bottom: 0.5rem;
        }

        .reg-val {
            width: clamp(3rem, 15vw, 6rem);
            aspect-ratio: 1 / 1;
            border: 4px double var(--fg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--font-lg);
            background: var(--bg);
        }

        /* 4. LOG - Takes remaining visual anchor */
        #log-panel {
            flex: 0 1 15vh; /* Target 15% height, allow shrink */
            min-height: 80px;
            border: 1px solid var(--fg);
            overflow-y: auto;
            padding: 0.5rem;
            font-size: var(--font-sm);
            background: #001100;
            /* Scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: var(--fg) var(--bg);
        }

        .log-entry {
            margin-bottom: 4px;
            border-left: 2px solid var(--fg);
            padding-left: 8px;
            word-wrap: break-word;
        }

        /* CONTROLS */
        #controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
            flex: 0 0 auto;
        }
        
        button {
            background: var(--bg);
            color: var(--fg);
            border: 2px solid var(--fg);
            padding: 0.8rem 1.5rem;
            font-family: var(--font);
            font-size: var(--font-md);
            cursor: pointer;
            text-transform: uppercase;
            flex: 1;
            max-width: 200px;
            transition: background 0.2s, color 0.2s;
            touch-action: manipulation;
        }

        button:hover:not(:disabled) {
            background: var(--fg);
            color: var(--bg);
        }

        button:disabled {
            border-color: var(--dim);
            color: var(--dim);
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* UTILS */
        #stage-msg {
            text-align: center;
            font-size: var(--font-sm);
            min-height: 1.2em;
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 1rem;
        }

        /* CRT SCANLINE EFFECT */
        .scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 999;
        }

        /* High DPI / Large Screen tweaks */
        @media (min-width: 2000px) {
            :root {
                --gap-std: 2rem;
            }
            .scanlines { background-size: 100% 6px; }
        }

        /* Very Small Mobile Height */
        @media (max-height: 600px) {
            header { display: none; } /* Save space on landscape mobile */
            #log-panel { flex-basis: 10vh; }
        }
    </style>
</head>
<body>

<div class="scanlines"></div>

<header>
    // TOURNAMENT_MIN_MAX.EXE //
</header>

<div id="controls">
    <button id="btn-start" onclick="startVis()">Initialize</button>
    <button id="btn-reset" onclick="resetVis()" disabled>Reset</button>
</div>

<div id="container">
    
    <!-- TOP: ARRAY -->
    <div id="array-strip">
        <!-- JS will populate -->
    </div>

    <!-- MIDDLE: BATTLEFIELD -->
    <div id="battlefield">
        <div class="battle-label">CPU_REGISTERS :: COMPARISON_UNIT</div>
        
        <div class="stage-area" id="stage-main">
            <!-- Dynamic Injection -->
            <div class="block" style="border: 1px dotted var(--dim); opacity:0.3">?</div>
            <div class="comparator">VS</div>
            <div class="block" style="border: 1px dotted var(--dim); opacity:0.3">?</div>
        </div>
        <div id="stage-msg">WAITING FOR INPUT...</div>
    </div>

    <!-- BOTTOM: MIN/MAX -->
    <div id="registry">
        <div class="reg-box">
            <span>GLOBAL_MIN</span>
            <div id="val-min" class="reg-val">-</div>
        </div>
        <div class="reg-box">
            <span>GLOBAL_MAX</span>
            <div id="val-max" class="reg-val">-</div>
        </div>
    </div>

    <!-- LOG -->
    <div id="log-panel"></div>

</div>

<script>
    // No changes to logic required, but ensured robust execution
    const DATA = [3, 5, 1, 2, 4];
    const delay = ms => new Promise(res => setTimeout(res, ms));
    const SPEED = 1000; // Slightly faster for modern feel

    let currentMin = null;
    let currentMax = null;

    // DOM Elements
    const elStrip = document.getElementById('array-strip');
    const elStage = document.getElementById('stage-main');
    const elMsg = document.getElementById('stage-msg');
    const elMin = document.getElementById('val-min');
    const elMax = document.getElementById('val-max');
    const elLog = document.getElementById('log-panel');
    const btnStart = document.getElementById('btn-start');
    const btnReset = document.getElementById('btn-reset');

    function initBoard() {
        elStrip.innerHTML = '';
        DATA.forEach((val, idx) => {
            let div = document.createElement('div');
            div.className = 'block';
            div.id = `blk-${idx}`;
            div.innerText = val;
            elStrip.appendChild(div);
        });
        elMin.innerText = '-';
        elMax.innerText = '-';
        elLog.innerHTML = '';
        log("SYSTEM READY. DATA LOADED.");
        clearStage();
    }

    function log(msg) {
        let div = document.createElement('div');
        div.className = 'log-entry';
        div.innerText = `> ${msg}`;
        elLog.prepend(div);
    }

    function clearStage() {
        elStage.innerHTML = `
            <div class="block" style="border: 1px dotted var(--dim); opacity:0.3; color: var(--dim)">?</div>
            <div class="comparator">VS</div>
            <div class="block" style="border: 1px dotted var(--dim); opacity:0.3; color: var(--dim)">?</div>
        `;
        elMsg.innerText = "IDLE";
        elMsg.style.color = "var(--fg)";
        elMsg.style.backgroundColor = "transparent";
    }

    function setStage(val1, val2, label1="A", label2="B") {
        elStage.innerHTML = `
            <div class="stage-col">
                <div class="block active">${val1}</div>
                <div class="role-label">${label1}</div>
            </div>
            <div class="comparator">VS</div>
            <div class="stage-col">
                <div class="block active">${val2}</div>
                <div class="role-label">${label2}</div>
            </div>
        `;
    }

    async function highlightArray(indices) {
        indices.forEach(i => {
            const el = document.getElementById(`blk-${i}`);
            if(el) el.classList.add('active');
        });
    }

    async function markProcessed(indices) {
        indices.forEach(i => {
            const el = document.getElementById(`blk-${i}`);
            if(el) {
                el.classList.remove('active');
                el.classList.add('processed');
                el.classList.add('dither-bg');
            }
        });
    }

    async function startVis() {
        btnStart.disabled = true;
        btnReset.disabled = true;
        
        let n = DATA.length;
        let i = 0;

        log("STEP 1: INITIALIZATION");
        
        if (n % 2 === 0) {
            log(`First Pair: ${DATA[0]} & ${DATA[1]}`);
            await highlightArray([0, 1]);
            setStage(DATA[0], DATA[1]);
            await delay(SPEED);

            if (DATA[0] < DATA[1]) {
                currentMin = DATA[0];
                currentMax = DATA[1];
                elMsg.innerText = `${DATA[0]} < ${DATA[1]}`;
            } else {
                currentMin = DATA[1];
                currentMax = DATA[0];
                elMsg.innerText = `${DATA[1]} < ${DATA[0]}`;
            }
            
            i = 2; 
        } else {
            log(`Odd length. First: ${DATA[0]}`);
            await highlightArray([0]);
            currentMin = DATA[0];
            currentMax = DATA[0];
            i = 1; 
        }

        updateRegistry();
        await markProcessed(i === 2 ? [0, 1] : [0]);
        await delay(SPEED);

        while (i < n - 1) {
            let val1 = DATA[i];
            let val2 = DATA[i+1];
            
            log(`Processing Pair: [${val1}, ${val2}]`);
            clearStage();
            await highlightArray([i, i+1]);
            await delay(SPEED/2);

            // Step A: Compare the Pair
            setStage(val1, val2);
            elMsg.innerText = "Comparing Pair...";
            await delay(SPEED);

            let localMin, localMax;
            if (val1 < val2) {
                localMin = val1;
                localMax = val2;
                elMsg.innerText = `${val1} < ${val2}`;
            } else {
                localMin = val2;
                localMax = val1;
                elMsg.innerText = `${val2} < ${val1}`;
            }
            await delay(SPEED);

            // Step B: Winner vs Global Max
            log(`Local Max (${localMax}) vs Global (${currentMax})`);
            setStage(localMax, currentMax, "WINNER", "MAX");
            
            if (localMax > currentMax) {
                elMsg.innerText = "NEW MAX FOUND!";
                currentMax = localMax;
                updateRegistry();
            } else {
                elMsg.innerText = "No Change.";
            }
            await delay(SPEED);

            // Step C: Loser vs Global Min
            log(`Local Min (${localMin}) vs Global (${currentMin})`);
            setStage(localMin, currentMin, "LOSER", "MIN");

            if (localMin < currentMin) {
                elMsg.innerText = "NEW MIN FOUND!";
                currentMin = localMin;
                updateRegistry();
            } else {
                elMsg.innerText = "No Change.";
            }
            await delay(SPEED);

            await markProcessed([i, i+1]);
            i += 2;
        }

        if (i < n) {
            let val = DATA[i];
            log(`Leftover: ${val}`);
            await highlightArray([i]);
            
            setStage(val, currentMin, "LEFT", "MIN");
            if (val < currentMin) {
                currentMin = val;
                updateRegistry();
            }
            await delay(SPEED);

            setStage(val, currentMax, "LEFT", "MAX");
            if (val > currentMax) {
                currentMax = val;
                updateRegistry();
            }
            await delay(SPEED);
            await markProcessed([i]);
        }

        clearStage();
        elMsg.innerText = "COMPLETE";
        elMsg.style.color = "#fff";
        elMsg.style.backgroundColor = "var(--fg)";
        log("Process terminated. Results locked.");
        btnReset.disabled = false;
    }

    function updateRegistry() {
        elMin.innerText = currentMin;
        elMax.innerText = currentMax;
        
        // CSS Animation Trigger
        const triggerFlash = (el) => {
            el.parentElement.style.backgroundColor = "var(--dim)";
            setTimeout(() => el.parentElement.style.backgroundColor = "transparent", 200);
        };
        triggerFlash(elMin);
        triggerFlash(elMax);
    }

    function resetVis() {
        initBoard();
        btnStart.disabled = false;
        btnReset.disabled = true;
    }

    initBoard();
</script>
</body>
</html>