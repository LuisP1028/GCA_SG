<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ditherpunk Min/Max Visualizer</title>
    <style>
        :root {
            --bg: #050505;
            --fg: #00ff00;
            --dim: #004400;
            --font: 'Courier New', Courier, monospace;
        }

        /* Dither Pattern Generator */
        .dither-bg {
            background-image: radial-gradient(var(--fg) 15%, transparent 16%),
                              radial-gradient(var(--fg) 15%, transparent 16%);
            background-size: 4px 4px;
            background-position: 0 0, 2px 2px;
            opacity: 0.3;
        }

        .dither-fill {
            background-image: linear-gradient(45deg, var(--fg) 25%, transparent 25%, transparent 75%, var(--fg) 75%, var(--fg)),
                              linear-gradient(45deg, var(--fg) 25%, transparent 25%, transparent 75%, var(--fg) 75%, var(--fg));
            background-size: 4px 4px;
            background-position: 0 0, 2px 2px;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
            font-weight: bold;
        }

        /* HEADER */
        header {
            border-bottom: 2px solid var(--fg);
            padding-bottom: 10px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
        }

        /* MAIN LAYOUT */
        #container {
            flex: 1;
            display: grid;
            grid-template-rows: auto 1fr auto auto;
            gap: 20px;
            position: relative;
        }

        /* 1. ARRAY STRIP */
        #array-strip {
            display: flex;
            justify-content: center;
            gap: 10px;
            padding: 10px;
            border: 1px dashed var(--dim);
        }

        .block {
            width: 50px;
            height: 50px;
            border: 2px solid var(--fg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            position: relative;
            background-color: var(--bg);
            transition: all 0.3s;
        }

        .block.active {
            background-color: var(--fg);
            color: var(--bg);
            box-shadow: 4px 4px 0px var(--dim);
        }

        .block.processed {
            opacity: 0.5;
            border-style: dotted;
        }

        /* 2. BATTLEFIELD (CPU) */
        #battlefield {
            border: 2px solid var(--fg);
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: linear-gradient(rgba(0,255,0,0.05) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(0,255,0,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .battle-label {
            position: absolute;
            top: 5px;
            left: 5px;
            background: var(--bg);
            padding: 2px 5px;
            border: 1px solid var(--fg);
            font-size: 0.8rem;
        }

        .stage-area {
            display: flex;
            gap: 50px;
            align-items: center;
            margin-bottom: 20px;
            min-height: 80px;
        }

        .comparator {
            font-size: 2rem;
            font-weight: bold;
        }

        .role-label {
            font-size: 0.8rem;
            margin-top: 5px;
            text-align: center;
            text-transform: uppercase;
        }

        /* 3. REGISTRY (MIN/MAX) */
        #registry {
            display: flex;
            justify-content: space-around;
            padding: 20px;
            border-top: 1px solid var(--fg);
        }

        .reg-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .reg-val {
            width: 60px;
            height: 60px;
            border: 4px double var(--fg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            margin-top: 10px;
        }

        /* 4. LOG */
        #log-panel {
            height: 100px;
            border: 1px solid var(--fg);
            overflow-y: auto;
            padding: 10px;
            font-size: 0.9rem;
            background: #001100;
        }

        .log-entry {
            margin-bottom: 5px;
            border-left: 2px solid var(--fg);
            padding-left: 10px;
        }

        .highlight-w { color: #fff; background: var(--dim); }
        .highlight-l { text-decoration: underline; }

        /* BUTTON */
        #controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
        }
        
        button {
            background: var(--bg);
            color: var(--fg);
            border: 2px solid var(--fg);
            padding: 10px 20px;
            font-family: var(--font);
            font-size: 1rem;
            cursor: pointer;
            text-transform: uppercase;
        }

        button:hover {
            background: var(--fg);
            color: var(--bg);
        }

        button:disabled {
            border-color: var(--dim);
            color: var(--dim);
            cursor: not-allowed;
        }

        /* CRT SCANLINE EFFECT */
        .scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 999;
        }
    </style>
</head>
<body>

<div class="scanlines"></div>

<header>
    // TOURNAMENT_MIN_MAX.EXE //
</header>

<div id="controls">
    <button id="btn-start" onclick="startVis()">Initialize Sequence</button>
    <button id="btn-reset" onclick="resetVis()" disabled>Reset System</button>
</div>

<div id="container">
    
    <!-- TOP: ARRAY -->
    <div id="array-strip">
        <!-- JS will populate -->
    </div>

    <!-- MIDDLE: BATTLEFIELD -->
    <div id="battlefield">
        <div class="battle-label">CPU_REGISTERS :: COMPARISON_UNIT</div>
        
        <div class="stage-area" id="stage-main">
            <!-- Dynamic Injection -->
            <div class="block" style="border: 1px dotted var(--dim); opacity:0.3">?</div>
            <div class="comparator">VS</div>
            <div class="block" style="border: 1px dotted var(--dim); opacity:0.3">?</div>
        </div>
        <div id="stage-msg" style="height: 20px;">WAITING FOR INPUT...</div>
    </div>

    <!-- BOTTOM: MIN/MAX -->
    <div id="registry">
        <div class="reg-box">
            <span>GLOBAL_MIN</span>
            <div id="val-min" class="reg-val">-</div>
        </div>
        <div class="reg-box">
            <span>GLOBAL_MAX</span>
            <div id="val-max" class="reg-val">-</div>
        </div>
    </div>

    <!-- LOG -->
    <div id="log-panel" id="log"></div>

</div>

<script>
    const DATA = [3, 5, 1, 2, 4];
    const delay = ms => new Promise(res => setTimeout(res, ms));
    const SPEED = 1200;

    let currentMin = null;
    let currentMax = null;

    // DOM Elements
    const elStrip = document.getElementById('array-strip');
    const elStage = document.getElementById('stage-main');
    const elMsg = document.getElementById('stage-msg');
    const elMin = document.getElementById('val-min');
    const elMax = document.getElementById('val-max');
    const elLog = document.getElementById('log-panel');
    const btnStart = document.getElementById('btn-start');
    const btnReset = document.getElementById('btn-reset');

    function initBoard() {
        elStrip.innerHTML = '';
        DATA.forEach((val, idx) => {
            let div = document.createElement('div');
            div.className = 'block';
            div.id = `blk-${idx}`;
            div.innerText = val;
            elStrip.appendChild(div);
        });
        elMin.innerText = '-';
        elMax.innerText = '-';
        elLog.innerHTML = '';
        log("SYSTEM READY. DATA LOADED: [" + DATA.join(', ') + "]");
        clearStage();
    }

    function log(msg) {
        let div = document.createElement('div');
        div.className = 'log-entry';
        div.innerText = `> ${msg}`;
        elLog.prepend(div);
    }

    function clearStage() {
        elStage.innerHTML = `
            <div class="block" style="border: 1px dotted var(--dim); opacity:0.3">?</div>
            <div class="comparator">VS</div>
            <div class="block" style="border: 1px dotted var(--dim); opacity:0.3">?</div>
        `;
        elMsg.innerText = "IDLE";
    }

    function setStage(val1, val2, label1="A", label2="B") {
        elStage.innerHTML = `
            <div>
                <div class="block active">${val1}</div>
                <div class="role-label">${label1}</div>
            </div>
            <div class="comparator">VS</div>
            <div>
                <div class="block active">${val2}</div>
                <div class="role-label">${label2}</div>
            </div>
        `;
    }

    async function highlightArray(indices) {
        indices.forEach(i => document.getElementById(`blk-${i}`).classList.add('active'));
    }

    async function markProcessed(indices) {
        indices.forEach(i => {
            const el = document.getElementById(`blk-${i}`);
            el.classList.remove('active');
            el.classList.add('processed');
            el.classList.add('dither-bg');
        });
    }

    async function startVis() {
        btnStart.disabled = true;
        btnReset.disabled = true;
        
        let n = DATA.length;
        let i = 0;

        // 1. INITIALIZATION
        log("STEP 1: INITIALIZATION");
        
        if (n % 2 === 0) {
            // Even number: compare first pair to init min/max
            log(`Taking first pair: ${DATA[0]} and ${DATA[1]}`);
            await highlightArray([0, 1]);
            setStage(DATA[0], DATA[1]);
            await delay(SPEED);

            if (DATA[0] < DATA[1]) {
                currentMin = DATA[0];
                currentMax = DATA[1];
                elMsg.innerText = `${DATA[0]} < ${DATA[1]}`;
            } else {
                currentMin = DATA[1];
                currentMax = DATA[0];
                elMsg.innerText = `${DATA[1]} < ${DATA[0]}`;
            }
            
            i = 2; // Move past first two
        } else {
            // Odd number: first element is both min and max
            log(`Odd length. Init with first element: ${DATA[0]}`);
            await highlightArray([0]);
            currentMin = DATA[0];
            currentMax = DATA[0];
            i = 1; // Move past first one
        }

        updateRegistry();
        await markProcessed(i === 2 ? [0, 1] : [0]);
        await delay(SPEED);

        // 2. LOOP PAIRS
        while (i < n - 1) {
            let val1 = DATA[i];
            let val2 = DATA[i+1];
            
            log(`Processing Pair: [${val1}, ${val2}]`);
            clearStage();
            await highlightArray([i, i+1]);
            await delay(SPEED/2);

            // Step A: Compare the Pair
            setStage(val1, val2);
            elMsg.innerText = "Comparing Pair...";
            await delay(SPEED);

            let localMin, localMax;
            if (val1 < val2) {
                localMin = val1;
                localMax = val2;
                elMsg.innerText = `${val1} is Local Loser, ${val2} is Local Winner`;
            } else {
                localMin = val2;
                localMax = val1;
                elMsg.innerText = `${val2} is Local Loser, ${val1} is Local Winner`;
            }
            await delay(SPEED);

            // Step B: Compare Local Max vs Global Max
            log(`Checking Winner (${localMax}) vs Global Max (${currentMax})`);
            setStage(localMax, currentMax, "WINNER", "MAX");
            
            if (localMax > currentMax) {
                elMsg.innerText = `${localMax} > ${currentMax} -> NEW MAX!`;
                currentMax = localMax;
                updateRegistry();
            } else {
                elMsg.innerText = `${localMax} is not larger. No Change.`;
            }
            await delay(SPEED);

            // Step C: Compare Local Min vs Global Min
            log(`Checking Loser (${localMin}) vs Global Min (${currentMin})`);
            setStage(localMin, currentMin, "LOSER", "MIN");

            if (localMin < currentMin) {
                elMsg.innerText = `${localMin} < ${currentMin} -> NEW MIN!`;
                currentMin = localMin;
                updateRegistry();
            } else {
                elMsg.innerText = `${localMin} is not smaller. No Change.`;
            }
            await delay(SPEED);

            await markProcessed([i, i+1]);
            i += 2;
        }

        // 3. LEFTOVER
        if (i < n) {
            let val = DATA[i];
            log(`Processing Leftover: ${val}`);
            await highlightArray([i]);
            
            // Compare vs Min
            setStage(val, currentMin, "LEFT", "MIN");
            if (val < currentMin) {
                currentMin = val;
                updateRegistry();
            }
            await delay(SPEED);

            // Compare vs Max
            setStage(val, currentMax, "LEFT", "MAX");
            if (val > currentMax) {
                currentMax = val;
                updateRegistry();
            }
            await delay(SPEED);
            await markProcessed([i]);
        }

        // FINISH
        clearStage();
        elMsg.innerText = "ALGORITHM COMPLETE";
        elMsg.style.color = "#fff";
        elMsg.style.backgroundColor = "var(--fg)";
        log("Terminating process. Final results locked.");
        btnReset.disabled = false;
    }

    function updateRegistry() {
        elMin.innerText = currentMin;
        elMax.innerText = currentMax;
        // Flash effect
        elMin.parentElement.style.backgroundColor = "var(--dim)";
        elMax.parentElement.style.backgroundColor = "var(--dim)";
        setTimeout(() => {
            elMin.parentElement.style.backgroundColor = "transparent";
            elMax.parentElement.style.backgroundColor = "transparent";
        }, 200);
    }

    function resetVis() {
        initBoard();
        btnStart.disabled = false;
        btnReset.disabled = true;
    }

    // Initialize on load
    initBoard();

</script>
</body>
</html>