<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Staircase Search Algorithm - Responsive</title>
    <style>
        :root {
            --bg: #000000;
            --fg: #00FF00;
            --fg-dim: #004400;
            --grid-size: 6;
            
            /* Responsive gap calculation */
            --cell-gap: clamp(2px, 0.5vmin, 8px);
        }

        /* --- GLOBAL & TYPOGRAPHY --- */
        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            width: 100vw;
            height: 100dvh; /* Dynamic Viewport Height for mobile browsers */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            text-transform: uppercase;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- BACKGROUND DITHERING --- */
        .dither-bg {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            z-index: -1;
            opacity: 0.3;
            background-image: radial-gradient(var(--fg) 15%, transparent 16%),
                              radial-gradient(var(--fg) 15%, transparent 16%);
            background-size: 4px 4px;
            background-position: 0 0, 2px 2px;
            pointer-events: none;
        }

        /* --- LAYOUT --- */
        .container {
            display: flex;
            flex-direction: column;
            gap: 1.5vh;
            width: 94vw;
            /* Constrain width by height to ensure grid fits on screen */
            max-width: min(600px, 80vh); 
            position: relative;
            padding: 10px;
        }

        /* --- HUD --- */
        .hud {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.8rem;
            border: 2px solid var(--fg);
            padding: 1rem;
            background: var(--bg);
            box-shadow: 4px 4px 0 var(--fg-dim);
        }

        .hud-box {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .hud-label {
            font-size: clamp(0.7rem, 2vmin, 0.9rem);
            border-bottom: 1px solid var(--fg);
            margin-bottom: 0.3rem;
            display: inline-block;
            width: fit-content;
        }

        .target-display {
            font-size: clamp(1.5rem, 5vmin, 2.5rem);
            font-weight: bold;
            line-height: 1;
        }

        #coordsDisplay {
            font-size: clamp(0.8rem, 2.5vmin, 1.2rem);
        }

        .status-log {
            grid-column: span 2;
            height: 3.5em; /* relative height */
            border-top: 1px solid var(--fg);
            padding-top: 0.5rem;
            font-size: clamp(0.7rem, 2.5vmin, 0.9rem);
            line-height: 1.4;
            overflow: hidden;
            white-space: pre-wrap;
        }

        /* --- CONTROLS --- */
        .controls {
            grid-column: span 2;
            display: flex;
            gap: 0.5rem;
            justify-content: space-between;
        }

        button {
            background: var(--bg);
            color: var(--fg);
            border: 2px solid var(--fg);
            padding: 0.6rem 0.2rem;
            font-family: inherit;
            font-weight: bold;
            font-size: clamp(0.7rem, 2.5vmin, 1rem);
            cursor: pointer;
            text-transform: uppercase;
            flex: 1;
            transition: all 0.1s;
        }

        button:hover:not(:disabled) {
            background: var(--fg);
            color: var(--bg);
            transform: translateY(-2px);
            box-shadow: 0 2px 0 var(--fg-dim);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: none;
        }

        button:disabled {
            border-color: var(--fg-dim);
            color: var(--fg-dim);
            cursor: not-allowed;
            background: var(--bg);
        }

        /* --- MATRIX GRID --- */
        .matrix-wrapper {
            position: relative;
            width: 100%;
            /* Force square aspect ratio */
            aspect-ratio: 1 / 1; 
            margin: 0 auto;
        }

        .matrix {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), 1fr);
            grid-template-rows: repeat(var(--grid-size), 1fr);
            gap: var(--cell-gap);
            width: 100%;
            height: 100%;
            border: 2px solid var(--fg);
            padding: var(--cell-gap);
            background: var(--bg);
        }

        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--fg);
            /* Responsive font size based on container width */
            font-size: clamp(0.8rem, 4cqi, 2rem); 
            container-type: inline-size; /* logic for cqi units if supported, falls back safely */
            position: relative;
            background: var(--bg);
            transition: transform 0.2s, background-color 0.2s;
        }

        /* Cell States */
        .cell.active {
            background: var(--fg);
            color: var(--bg);
            font-weight: bold;
            z-index: 10;
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--fg);
        }

        .cell.eliminated {
            border-color: var(--fg-dim);
            color: var(--fg-dim);
        }

        .cell.eliminated::before {
            content: '';
            position: absolute;
            inset: 0;
            background-image: radial-gradient(var(--fg-dim) 20%, transparent 20%);
            background-size: 3px 3px;
        }
        
        .cell.eliminated::after {
            content: 'X';
            position: absolute;
            font-size: 150%;
            color: var(--fg);
            opacity: 0.3;
        }

        .cell.match {
            background: var(--fg);
            color: var(--bg);
            animation: pulse 0.5s infinite alternate;
        }
        
        .cell.match::after {
            content: 'âœ“';
            position: absolute;
            top: -10%; right: -10%;
            background: var(--bg);
            color: var(--fg);
            border: 1px solid var(--fg);
            width: 30%; height: 30%;
            font-size: 80%;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        /* Logic Hint / Shadow */
        .cell.shadow-elim {
            background-image: linear-gradient(135deg, #002200 25%, transparent 25%, transparent 50%, #002200 50%, #002200 75%, transparent 75%, transparent);
            background-size: 8px 8px;
        }

        /* --- OVERLAYS --- */
        .overlay-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 5;
            overflow: visible;
        }

        /* Tooltip Bubble */
        .logic-bubble {
            position: absolute;
            background: var(--bg);
            border: 1px solid var(--fg);
            padding: 0.4em 0.8em;
            font-size: clamp(0.8rem, 3vmin, 1.2rem);
            white-space: nowrap;
            z-index: 20;
            pointer-events: none;
            opacity: 0;
            transform: translate(-50%, -130%);
            box-shadow: 4px 4px 0 rgba(0,0,0,0.8);
            transition: opacity 0.2s, top 0.2s, left 0.2s;
        }
        .logic-bubble.visible {
            opacity: 1;
        }
        .logic-bubble::after {
            content: '';
            position: absolute;
            bottom: -6px; left: 50%;
            transform: translateX(-50%);
            border-width: 6px 6px 0;
            border-style: solid;
            border-color: var(--fg) transparent transparent transparent;
        }

        @keyframes pulse {
            from { transform: scale(1); box-shadow: 0 0 0 var(--fg); }
            to { transform: scale(1.05); box-shadow: 0 0 15px var(--fg); }
        }

        /* --- MEDIA QUERIES FOR ULTRA-SMALL SCREENS --- */
        @media (max-height: 500px) {
            .container { flex-direction: row; align-items: center; width: 98vw; max-width: none; }
            .hud { display: flex; flex-direction: column; width: 200px; min-width: 200px; }
            .matrix-wrapper { height: 90vh; width: 90vh; }
        }
    </style>
</head>
<body>

    <div class="dither-bg"></div>

    <div class="container">
        <!-- HEADER HUD -->
        <div class="hud">
            <div class="hud-box">
                <span class="hud-label">TARGET [x]</span>
                <div class="target-display" id="targetValue">--</div>
            </div>
            <div class="hud-box" style="align-items: flex-end;">
                <span class="hud-label">COORDS</span>
                <div id="coordsDisplay">R: - | C: -</div>
            </div>
            
            <div class="status-log" id="statusLog">> SYSTEM READY_</div>

            <div class="controls">
                <button id="btnReset">RESET</button>
                <button id="btnAuto">AUTO</button>
                <button id="btnNext">STEP</button>
            </div>
        </div>

        <!-- MAIN STAGE -->
        <div class="matrix-wrapper" id="matrixWrapper">
            <!-- SVG Layer for the Path -->
            <svg class="overlay-canvas">
                <polyline id="pathTrace" points="" fill="none" stroke="#00FF00" stroke-width="2" stroke-linecap="square" vector-effect="non-scaling-stroke" />
            </svg>
            
            <!-- Comparison Bubble -->
            <div id="logicBubble" class="logic-bubble"></div>

            <!-- Grid -->
            <div class="matrix" id="grid">
                <!-- Cells generated by JS -->
            </div>
        </div>
    </div>

<script>
    /* 
     * RESPONSIVE STAIRCASE SEARCH ENGINE
     */

    const GRID_SIZE = 6;
    const SPEED_SLOW = 800;
    const SPEED_FAST = 300;

    // DOM Elements
    const gridEl = document.getElementById('grid');
    const matrixWrapper = document.getElementById('matrixWrapper');
    const targetDisplay = document.getElementById('targetValue');
    const coordsDisplay = document.getElementById('coordsDisplay');
    const statusLog = document.getElementById('statusLog');
    const logicBubble = document.getElementById('logicBubble');
    const pathTrace = document.getElementById('pathTrace');
    
    const btnNext = document.getElementById('btnNext');
    const btnAuto = document.getElementById('btnAuto');
    const btnReset = document.getElementById('btnReset');

    // State Variables
    let matrix = [];
    let target = 0;
    let currentRow = 0;
    let currentCol = GRID_SIZE - 1;
    let isSearchActive = false;
    let isAutoPlaying = false;
    let autoTimer = null;
    
    // Store path as logical coordinates {r, c} instead of pixels
    // This allows us to redraw the line correctly when window resizes
    let logicalPath = []; 

    // --- INITIALIZATION ---

    function init() {
        generateSortedMatrix();
        pickTarget();
        renderGrid();
        resetSearchState();
        log("SYSTEM INITIALIZED. MATRIX SORTED.");
    }

    function generateSortedMatrix() {
        matrix = Array.from({ length: GRID_SIZE }, () => new Array(GRID_SIZE).fill(0));
        matrix[0][0] = Math.floor(Math.random() * 10) + 1;

        // Fill first row
        for (let c = 1; c < GRID_SIZE; c++) {
            matrix[0][c] = matrix[0][c-1] + Math.floor(Math.random() * 5) + 2;
        }

        // Fill first col
        for (let r = 1; r < GRID_SIZE; r++) {
            matrix[r][0] = matrix[r-1][0] + Math.floor(Math.random() * 5) + 2;
        }

        // Fill rest
        for (let r = 1; r < GRID_SIZE; r++) {
            for (let c = 1; c < GRID_SIZE; c++) {
                const maxPrev = Math.max(matrix[r-1][c], matrix[r][c-1]);
                matrix[r][c] = maxPrev + Math.floor(Math.random() * 10) + 1;
            }
        }
    }

    function pickTarget() {
        if (Math.random() > 0.2) {
            const r = Math.floor(Math.random() * GRID_SIZE);
            const c = Math.floor(Math.random() * GRID_SIZE);
            target = matrix[r][c];
        } else {
            target = Math.floor(Math.random() * 100);
        }
        targetDisplay.innerText = target;
    }

    function renderGrid() {
        gridEl.innerHTML = '';
        // Set CSS variable for grid size
        document.documentElement.style.setProperty('--grid-size', GRID_SIZE);
        
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.innerText = matrix[r][c];
                cell.dataset.r = r;
                cell.dataset.c = c;
                gridEl.appendChild(cell);
            }
        }
    }

    function resetSearchState() {
        currentRow = 0;
        currentCol = GRID_SIZE - 1;
        isSearchActive = true;
        isAutoPlaying = false;
        logicalPath = [];
        pathTrace.setAttribute('points', '');
        
        document.querySelectorAll('.cell').forEach(c => c.className = 'cell');
        updateControls(true);
        highlightCell(currentRow, currentCol);
    }

    // --- VISUALIZATION & RESPONSIVENESS ---

    function getCell(r, c) {
        return document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
    }

    function highlightCell(r, c) {
        if(r >= GRID_SIZE || c < 0) return;

        document.querySelectorAll('.cell.active').forEach(el => el.classList.remove('active'));

        const cell = getCell(r, c);
        if(cell) {
            cell.classList.add('active');
            coordsDisplay.innerText = `R:${r} C:${c}`;
            
            // Add logical point
            logicalPath.push({r, c});
            updateTraceLine();
        }
    }

    // Calculates SVG points from logical path based on current DOM layout
    function updateTraceLine() {
        if (logicalPath.length === 0) return;

        const points = logicalPath.map(p => {
            const cell = getCell(p.r, p.c);
            if (!cell) return null;
            // Calculate center relative to the matrix wrapper
            const cellRect = cell.getBoundingClientRect();
            const wrapperRect = matrixWrapper.getBoundingClientRect();
            
            const x = (cellRect.left - wrapperRect.left) + (cellRect.width / 2);
            const y = (cellRect.top - wrapperRect.top) + (cellRect.height / 2);
            return `${x},${y}`;
        }).filter(Boolean);

        pathTrace.setAttribute('points', points.join(' '));
    }

    function showBubble(r, c, operator) {
        const cell = getCell(r, c);
        if (!cell) return;
        
        const cellVal = matrix[r][c];
        logicBubble.innerText = `${target} ${operator} ${cellVal}`;
        logicBubble.classList.add('visible');

        positionBubble(cell);
    }

    function positionBubble(cell) {
        if(!cell) return;
        
        const cellRect = cell.getBoundingClientRect();
        const wrapperRect = matrixWrapper.getBoundingClientRect();

        // Calculate position relative to wrapper
        const top = cellRect.top - wrapperRect.top;
        const left = (cellRect.left - wrapperRect.left) + (cellRect.width / 2);

        logicBubble.style.top = `${top}px`;
        logicBubble.style.left = `${left}px`;
    }

    function hideBubble() {
        logicBubble.classList.remove('visible');
    }

    // --- LOGIC STEP ---

    async function nextStep() {
        if (!isSearchActive) return;

        if (currentRow >= GRID_SIZE || currentCol < 0) {
            endSearch(false);
            return;
        }

        const currentVal = matrix[currentRow][currentCol];
        const cell = getCell(currentRow, currentCol);

        btnNext.disabled = true; 
        
        if (currentVal === target) {
            // MATCH
            showBubble(currentRow, currentCol, '=');
            log(`MATCH FOUND AT [${currentRow},${currentCol}]`);
            cell.classList.remove('active');
            cell.classList.add('match');
            endSearch(true);
            return;
        } 
        else if (target < currentVal) {
            // LEFT
            showBubble(currentRow, currentCol, '<');
            log(`${target} < ${currentVal}. COL ${currentCol} ELIMINATED.`);
            
            for(let r = currentRow + 1; r < GRID_SIZE; r++) {
                getCell(r, currentCol)?.classList.add('shadow-elim');
            }

            await wait(isAutoPlaying ? SPEED_FAST : SPEED_SLOW);

            eliminateColumn(currentCol);
            currentCol--;
            
            if (currentCol >= 0) highlightCell(currentRow, currentCol);
        } 
        else {
            // DOWN
            showBubble(currentRow, currentCol, '>');
            log(`${target} > ${currentVal}. ROW ${currentRow} ELIMINATED.`);

            for(let c = 0; c < currentCol; c++) {
                getCell(currentRow, c)?.classList.add('shadow-elim');
            }

            await wait(isAutoPlaying ? SPEED_FAST : SPEED_SLOW);

            eliminateRow(currentRow);
            currentRow++;

            if (currentRow < GRID_SIZE) highlightCell(currentRow, currentCol);
        }

        hideBubble();
        btnNext.disabled = false;

        if(isSearchActive && isAutoPlaying) {
             autoTimer = setTimeout(() => {
                 if(isAutoPlaying) nextStep();
             }, 200);
        }
    }

    function eliminateColumn(c) {
        for (let r = 0; r < GRID_SIZE; r++) {
            const cell = getCell(r, c);
            if(cell) {
                cell.classList.remove('active', 'shadow-elim');
                cell.classList.add('eliminated');
            }
        }
    }

    function eliminateRow(r) {
        for (let c = 0; c < GRID_SIZE; c++) {
            const cell = getCell(r, c);
            if(cell) {
                cell.classList.remove('active', 'shadow-elim');
                cell.classList.add('eliminated');
            }
        }
    }

    function endSearch(found) {
        isSearchActive = false;
        stopAutoPlay();
        updateControls(false);
        if(!found) {
            log("SEARCH ENDED. TARGET NOT FOUND.");
            gridEl.style.opacity = '0.6';
        }
    }

    // --- UTILS ---

    function log(msg) {
        statusLog.innerText = `> ${msg}_`;
    }

    function wait(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function stopAutoPlay() {
        isAutoPlaying = false;
        clearTimeout(autoTimer);
        btnAuto.innerText = "AUTO";
        btnAuto.classList.remove('active');
    }

    function updateControls(active) {
        btnNext.disabled = !active;
        btnAuto.disabled = !active;
    }

    // --- RESPONSIVE OBSERVER ---
    
    // Monitors the grid size and updates SVG path and bubble positions immediately
    const resizeObserver = new ResizeObserver(() => {
        updateTraceLine();
        
        // Reposition bubble if visible
        if(logicBubble.classList.contains('visible') && isSearchActive) {
            const cell = getCell(currentRow, currentCol);
            positionBubble(cell);
        }
    });
    
    resizeObserver.observe(matrixWrapper);

    // --- EVENT LISTENERS ---

    btnNext.addEventListener('click', () => {
        stopAutoPlay();
        nextStep();
    });

    btnAuto.addEventListener('click', () => {
        if (isAutoPlaying) {
            stopAutoPlay();
        } else {
            isAutoPlaying = true;
            btnAuto.innerText = "STOP";
            nextStep();
        }
    });

    btnReset.addEventListener('click', () => {
        stopAutoPlay();
        gridEl.style.opacity = '1';
        init();
    });

    // Boot
    init();

</script>
</body>
</html>