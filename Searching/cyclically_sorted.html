<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYCLIC_DESCENT // DITHERPUNK_VISUALIZER</title>
    <style>
        :root {
            --bg-color: #000000;
            --main-color: #00FF00;
            --dim-color: #003300;
        }

        body {
            background-color: var(--bg-color);
            color: var(--main-color);
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
        }

        /* Scanline Effect Overlay */
        body::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                to bottom,
                rgba(18, 16, 16, 0) 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            z-index: 10;
            pointer-events: none;
        }

        /* Layout */
        #canvas-container {
            flex: 3; /* Occupy top 75% */
            position: relative;
            border-bottom: 2px solid var(--main-color);
            box-sizing: border-box;
            overflow: hidden;
            min-height: 0; /* Allow shrinking */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            flex: 1; /* Occupy bottom 25% */
            display: flex;
            flex-direction: row;
            padding: 10px;
            gap: 10px;
            background-color: var(--bg-color);
            z-index: 11;
            box-sizing: border-box;
            min-height: 0; /* Vital for nested flex scrolling */
        }

        .panel {
            flex: 1;
            border: 2px solid var(--main-color);
            padding: 10px;
            padding-top: 15px; /* Make room for title */
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: 4px 4px 0px var(--dim-color);
            min-height: 0; /* Vital: prevents panel from growing with content */
            overflow: hidden; /* Contains the scrollbar inside */
        }

        .panel-title {
            position: absolute;
            top: -10px;
            left: 10px;
            background: var(--bg-color);
            padding: 0 5px;
            font-weight: bold;
            letter-spacing: 2px;
            z-index: 2;
        }

        /* Control Deck Styling */
        .var-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 1.2rem;
            flex-shrink: 0; /* Prevent variables from squishing */
        }
        .var-label { font-weight: bold; }
        .var-val { border-bottom: 1px dashed var(--main-color); min-width: 50px; text-align: right; }

        button {
            margin-top: auto;
            background: var(--bg-color);
            color: var(--main-color);
            border: 2px solid var(--main-color);
            padding: 10px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.1s;
            flex-shrink: 0;
        }
        button:hover {
            background: var(--main-color);
            color: var(--bg-color);
        }
        button:active {
            transform: translate(2px, 2px);
        }

        /* Log Styling - FIXED SCROLLING */
        #log-container {
            flex: 1;             /* Fill remaining space in panel */
            min-height: 0;       /* CRITICAL: Allows flex item to shrink below content size */
            overflow-y: auto;    /* Enable scrollbar */
            display: flex;
            flex-direction: column-reverse; /* Newest items at bottom/start */
            padding-right: 5px;  /* Space for scrollbar */
        }
        
        .log-entry {
            margin-bottom: 4px;
            border-left: 2px solid var(--dim-color);
            padding-left: 5px;
            font-size: 0.85rem;
            line-height: 1.2;
            flex-shrink: 0; /* Ensure entries don't collapse */
        }
        .log-entry.highlight { border-left-color: var(--main-color); color: #fff; }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-color); border-left: 1px solid var(--dim-color); }
        ::-webkit-scrollbar-thumb { background: var(--main-color); border: 1px solid var(--bg-color); }
        ::-webkit-scrollbar-thumb:hover { background: #fff; }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <div id="ui-layer">
        <!-- LEFT: Control Deck -->
        <div class="panel" style="flex: 0 0 250px;"> <!-- Fixed width for controls -->
            <div class="panel-title">CONTROL_DECK</div>
            <div class="var-row">
                <span class="var-label">LEFT [L]:</span>
                <span id="disp-left" class="var-val">--</span>
            </div>
            <div class="var-row">
                <span class="var-label">RIGHT [R]:</span>
                <span id="disp-right" class="var-val">--</span>
            </div>
            <div class="var-row">
                <span class="var-label">MID [M]:</span>
                <span id="disp-mid" class="var-val">--</span>
            </div>
            <div class="var-row" style="margin-top:10px; color: var(--main-color)">
                <span class="var-label">RELATION:</span>
                <span id="disp-logic" class="var-val">--</span>
            </div>
            <button onclick="resetSystem()">// REBOOT_SYSTEM</button>
        </div>

        <!-- RIGHT: Narrative Log -->
        <div class="panel" style="flex: 1;">
            <div class="panel-title">SYS_LOG</div>
            <div id="log-container"></div>
        </div>
    </div>

<script>
/**
 * DITHERPUNK CYCLIC SEARCH VISUALIZER
 * Single File Implementation
 */

// --- CONFIGURATION ---
const BAR_COUNT = 40;
const ANIMATION_SPEED_MS = 1000; // Base delay between steps
const COLOR_MAIN = '#00FF00';
const COLOR_BG = '#000000';

// --- STATE MANAGEMENT ---
const State = {
    array: [],
    left: 0,
    right: 0,
    mid: -1,
    minFound: -1,
    phase: 'IDLE', // IDLE, CALC, COMPARE, DECIDE, DONE
    lastTick: 0,
    history: [],
    patternCanvas: null
};

// --- DOM ELEMENTS ---
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
const uiLeft = document.getElementById('disp-left');
const uiRight = document.getElementById('disp-right');
const uiMid = document.getElementById('disp-mid');
const uiLogic = document.getElementById('disp-logic');
const logContainer = document.getElementById('log-container');

// --- INIT & UTILS ---

// Create a 4x4 Bayer-like Dither Pattern for "Inactive" bars
function createDitherPattern() {
    const pCan = document.createElement('canvas');
    pCan.width = 4;
    pCan.height = 4;
    const pCtx = pCan.getContext('2d');
    
    pCtx.fillStyle = COLOR_BG;
    pCtx.fillRect(0,0,4,4);
    pCtx.fillStyle = COLOR_MAIN;
    
    // Simple checker pattern
    pCtx.fillRect(0,0,1,1);
    pCtx.fillRect(2,0,1,1);
    pCtx.fillRect(1,1,1,1);
    pCtx.fillRect(3,1,1,1);
    pCtx.fillRect(0,2,1,1);
    pCtx.fillRect(2,2,1,1);
    pCtx.fillRect(1,3,1,1);
    pCtx.fillRect(3,3,1,1);

    return ctx.createPattern(pCan, 'repeat');
}

function resize() {
    canvas.width = canvas.parentElement.clientWidth;
    canvas.height = canvas.parentElement.clientHeight;
    // Re-create pattern on resize to ensure context validity
    State.patternCanvas = createDitherPattern();
    draw();
}

function log(msg, highlight=false) {
    const div = document.createElement('div');
    div.className = `log-entry ${highlight ? 'highlight' : ''}`;
    div.innerHTML = `> ${msg}`;
    // Insert at beginning because of column-reverse
    logContainer.prepend(div);
    
    // Optional: cap log size if performance degrades, though scrolling handles it now
    if(logContainer.children.length > 100) logContainer.lastChild.remove();
}

function generateData() {
    // 1. Generate sorted distinct values
    let arr = [];
    let start = Math.floor(Math.random() * 20) + 10;
    for(let i=0; i<BAR_COUNT; i++) {
        arr.push(start);
        start += Math.floor(Math.random() * 15) + 5;
    }
    
    // 2. Rotate
    const rotation = Math.floor(Math.random() * (BAR_COUNT - 2)) + 1;
    const part1 = arr.slice(rotation);
    const part2 = arr.slice(0, rotation);
    State.array = part1.concat(part2);
    
    State.left = 0;
    State.right = BAR_COUNT - 1;
    State.mid = -1;
    State.minFound = -1;
    State.phase = 'CALC';
    State.lastTick = Date.now();
    
    uiLeft.innerText = State.left;
    uiRight.innerText = State.right;
    uiMid.innerText = "--";
    uiLogic.innerText = "INIT";
    
    logContainer.innerHTML = '';
    log("SYSTEM BOOT SEQUENCE INITIATED...", true);
    log(`DATA GENERATED. SEARCH RANGE: [0, ${BAR_COUNT-1}]`);
}

// --- DRAWING ENGINE ---

function draw() {
    // Clear
    ctx.fillStyle = COLOR_BG;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const W = canvas.width;
    const H = canvas.height;
    
    // Margins
    const marginX = W * 0.1;
    const marginY = H * 0.2;
    const drawW = W - (2 * marginX);
    const drawH = H - (2 * marginY);
    
    const barW = drawW / BAR_COUNT;
    const maxVal = Math.max(...State.array);

    // 1. Draw Bars
    State.array.forEach((val, i) => {
        const barH = (val / maxVal) * drawH;
        const x = marginX + (i * barW);
        const y = H - marginY - barH;

        // Determine State
        let isActive = (i >= State.left && i <= State.right);
        
        // If we found the min, only that one is active green
        if(State.phase === 'DONE') {
            isActive = (i === State.minFound);
        }

        ctx.beginPath();
        if (isActive) {
            ctx.fillStyle = COLOR_MAIN;
        } else {
            ctx.fillStyle = State.patternCanvas;
        }
        
        // Draw Bar
        ctx.fillRect(x + 1, y, barW - 2, barH);
        
        // Value Text
        if (i === State.mid || i === State.left || i === State.right) {
            ctx.fillStyle = isActive ? COLOR_BG : COLOR_MAIN;
            if(!isActive) ctx.font = "10px monospace";
            else ctx.font = "bold 12px monospace";
            
            // Smart text positioning
            if(barH > 20) {
                 ctx.fillText(val, x + 4, y + 15);
            } else {
                 ctx.fillStyle = COLOR_MAIN;
                 ctx.fillText(val, x + 4, y - 5);
            }
        }
    });

    // 2. Draw Pointers (Left, Right)
    const yBase = H - marginY + 10;
    
    // L Pointer
    const xL = marginX + (State.left * barW);
    ctx.strokeStyle = COLOR_MAIN;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(xL, yBase); 
    ctx.lineTo(xL, yBase + 15);
    ctx.lineTo(xL + 10, yBase + 15); // Bracket shape
    ctx.stroke();
    ctx.fillStyle = COLOR_MAIN;
    ctx.fillText("L", xL + 4, yBase + 28);

    // R Pointer
    const xR = marginX + (State.right * barW) + barW; // Right side of bar
    ctx.beginPath();
    ctx.moveTo(xR, yBase);
    ctx.lineTo(xR, yBase + 15);
    ctx.lineTo(xR - 10, yBase + 15);
    ctx.stroke();
    ctx.fillText("R", xR - 10, yBase + 28);

    // 3. Draw Midpoint (Triangle)
    if (State.mid !== -1) {
        const valM = State.array[State.mid];
        const barHM = (valM / maxVal) * drawH;
        const xM = marginX + (State.mid * barW) + (barW/2);
        const yM = H - marginY - barHM - 10;

        ctx.fillStyle = COLOR_MAIN;
        ctx.beginPath();
        ctx.moveTo(xM, yM);
        ctx.moveTo(xM - 6, yM - 10);
        ctx.lineTo(xM + 6, yM - 10);
        ctx.lineTo(xM, yM);
        ctx.fill();
        ctx.fillText("M", xM - 4, yM - 15);
    }

    // 4. Draw Sightline (Compare Phase)
    if (State.phase === 'COMPARE' || State.phase === 'DECIDE') {
        const valM = State.array[State.mid];
        const valR = State.array[State.right];
        
        const hM = (valM / maxVal) * drawH;
        const hR = (valR / maxVal) * drawH;
        
        const xM = marginX + (State.mid * barW) + (barW/2);
        const yM = H - marginY - hM;
        
        const xR = marginX + (State.right * barW) + (barW/2);
        const yR = H - marginY - hR;

        ctx.beginPath();
        ctx.lineWidth = 2;
        
        if (valM > valR) {
            // Broken Logic - Jagged Line
            ctx.setLineDash([5, 5]);
            // Draw an X in the middle
            const midX = (xM + xR) / 2;
            const midY = (yM + yR) / 2;
            
            ctx.moveTo(xM, yM);
            ctx.lineTo(xR, yR);
            ctx.stroke();
            
            // Draw "X" or "!" symbol
            ctx.font = "20px monospace";
            ctx.fillStyle = COLOR_MAIN;
            ctx.fillText("BREAK!", midX - 20, midY - 10);
            
        } else {
            // Sorted Logic - Smooth Dotted
            ctx.setLineDash([2, 2]);
            ctx.moveTo(xM, yM);
            ctx.lineTo(xR, yR);
            ctx.stroke();
            
            const midX = (xM + xR) / 2;
            const midY = (yM + yR) / 2;
            ctx.font = "16px monospace";
            ctx.fillStyle = COLOR_MAIN;
            ctx.fillText("SMOOTH", midX - 20, midY - 10);
        }
        ctx.setLineDash([]);
    }
}

// --- LOGIC LOOP ---

function updateLogic() {
    const now = Date.now();
    
    if (now - State.lastTick < ANIMATION_SPEED_MS) return;

    if (State.phase === 'IDLE') return;

    if (State.phase === 'DONE') {
        return;
    }

    // Main Algorithm Step Machine
    if (State.phase === 'CALC') {
        if (State.left < State.right) {
            State.mid = Math.floor((State.left + State.right) / 2);
            uiMid.innerText = State.mid;
            log(`CALC: Midpoint set to index ${State.mid} (Val: ${State.array[State.mid]})`);
            State.phase = 'COMPARE';
        } else {
            State.minFound = State.left;
            State.phase = 'DONE';
            log(`CONVERGENCE DETECTED. Minimum is at Index ${State.left} with Value ${State.array[State.left]}.`, true);
            uiLogic.innerText = "SUCCESS";
        }
        State.lastTick = now;
        return;
    }

    if (State.phase === 'COMPARE') {
        const valM = State.array[State.mid];
        const valR = State.array[State.right];
        
        if (valM > valR) {
            uiLogic.innerText = "M > R (BROKEN)";
            log(`COMPARE: ${valM} > ${valR}. Sequence breaks. Drop is to the RIGHT.`);
        } else {
            uiLogic.innerText = "M < R (SORTED)";
            log(`COMPARE: ${valM} < ${valR}. Right side sorted. Drop is LEFT or MID.`);
        }
        
        State.phase = 'DECIDE';
        State.lastTick = now;
        return;
    }

    if (State.phase === 'DECIDE') {
        const valM = State.array[State.mid];
        const valR = State.array[State.right];

        if (valM > valR) {
            log(`ACTION: Discarding [${State.left} ... ${State.mid}]. Moving Left -> ${State.mid + 1}.`);
            State.left = State.mid + 1;
        } else {
            log(`ACTION: Discarding [${State.mid + 1} ... ${State.right}]. Moving Right -> ${State.mid}.`);
            State.right = State.mid;
        }

        uiLeft.innerText = State.left;
        uiRight.innerText = State.right;
        uiLogic.innerText = "UPDATING...";
        
        State.phase = 'CALC';
        State.lastTick = now;
        return;
    }
}

function loop() {
    updateLogic();
    draw();
    requestAnimationFrame(loop);
}

function resetSystem() {
    generateData();
}

// --- BOOTSTRAP ---
window.addEventListener('resize', resize);
resize(); // Init pattern
resetSystem(); // Init data
loop(); // Start loop

</script>
</body>
</html>