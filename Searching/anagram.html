<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ANAGRAMMATIC_ENGINE // DITHER_PROTOCOL</title>
<style>
    :root {
        --bg: #050505;
        --fg: #33ff00;
        --fg-dim: #1a8000;
        --fg-ghost: rgba(51, 255, 0, 0.2);
        --err: #ff003c;
        --font-main: 'Courier New', Courier, monospace;
        --ease-out: cubic-bezier(0.23, 1, 0.32, 1);
        
        /* Responsive sizing variables */
        --gap: clamp(0.5rem, 1.5vh, 2rem);
        --border-thick: clamp(2px, 0.4vh, 4px);
        --tile-size: clamp(30px, 5vw, 60px); 
    }

    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg);
        color: var(--fg);
        font-family: var(--font-main);
        height: 100dvh; /* Dynamic viewport height for mobile */
        width: 100vw;
        overflow: hidden; /* Prevent body scroll, handle inside containers */
        display: flex;
        flex-direction: column;
        user-select: none;
    }

    /* --- DITHERPUNK AESTHETICS --- */
    
    .dither-overlay {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        z-index: 50;
        background-image: radial-gradient(var(--fg-dim) 1px, transparent 1px);
        background-size: 4px 4px;
        opacity: 0.3;
    }

    .scanlines {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 51;
    }

    /* CRT Flicker */
    @keyframes flicker {
        0% { opacity: 0.98; }
        5% { opacity: 0.95; }
        10% { opacity: 0.92; }
        15% { opacity: 0.96; }
        100% { opacity: 0.98; }
    }

    .crt-container {
        width: 100%; 
        height: 100%;
        display: flex;
        flex-direction: column;
        padding: var(--gap);
        gap: var(--gap);
        animation: flicker 0.15s infinite;
        position: relative;
        z-index: 10;
    }

    /* --- RESPONSIVE LAYOUT ZONES --- */

    .zone {
        border: var(--border-thick) solid var(--fg);
        position: relative;
        background: rgba(5, 5, 5, 0.85);
        box-shadow: 0 0 10px var(--fg-dim);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        transition: border-color 0.3s;
    }

    .label {
        position: absolute;
        top: 0;
        left: 0;
        background: var(--fg);
        color: var(--bg);
        padding: 2px 8px;
        font-size: clamp(0.7rem, 1.2vw, 1rem);
        font-weight: bold;
        text-transform: uppercase;
        z-index: 5;
    }

    /* FLEX GROW STRATEGY: 
       Zones A and C take 1 part each.
       Zone B (Ledger) takes 2 parts (more space).
    */
    #zone-a { flex: 1; min-height: 15%; }
    #zone-b { 
        flex: 2; 
        min-height: 30%; 
        justify-content: flex-end; /* Bins grow up */
        padding-top: 2rem;
        padding-bottom: 1rem;
        overflow: hidden; /* Manage internal overflow */
    }
    #zone-c { flex: 1; min-height: 15%; }

    .input-container {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        justify-content: center;
        width: 100%;
        max-height: 100%;
        overflow-y: auto;
        padding: 1rem;
    }

    /* Internal Scrolling for Zone B (Ledger) */
    .ledger-scroll-wrapper {
        display: flex;
        flex-direction: row;
        align-items: flex-end;
        justify-content: center; /* Center if few items */
        gap: 1vw;
        width: 100%;
        height: 100%;
        overflow-x: auto; /* Horizontal scroll if too many bins */
        overflow-y: hidden;
        padding: 0 2rem;
        
        /* Custom Scrollbar */
        scrollbar-width: thin;
        scrollbar-color: var(--fg) var(--bg);
    }
    .ledger-scroll-wrapper::-webkit-scrollbar { height: 6px; }
    .ledger-scroll-wrapper::-webkit-scrollbar-track { background: var(--bg); }
    .ledger-scroll-wrapper::-webkit-scrollbar-thumb { background: var(--fg); }

    /* --- UI ELEMENTS --- */

    .tile {
        width: var(--tile-size);
        height: var(--tile-size);
        border: 2px solid var(--fg);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: calc(var(--tile-size) * 0.5);
        font-weight: bold;
        background: var(--bg);
        flex-shrink: 0; /* Don't squash tiles */
        position: relative;
    }

    .tile.ghost {
        position: fixed; /* Must be fixed to fly across zones */
        z-index: 1000;
        pointer-events: none;
        box-shadow: 0 0 15px var(--fg);
    }

    .tile.processed {
        opacity: 0.2;
        border-style: dotted;
    }

    /* Bins in Ledger */
    .bin {
        display: flex;
        flex-direction: column-reverse;
        align-items: center;
        width: var(--tile-size);
        flex-shrink: 0;
        margin-bottom: 5px;
    }

    .bin-label {
        margin-top: 5px;
        font-size: calc(var(--tile-size) * 0.4);
        font-weight: bold;
        text-align: center;
    }

    .block {
        width: 100%;
        height: 8px;
        margin-bottom: 2px;
        background: repeating-linear-gradient(
            45deg,
            var(--fg),
            var(--fg) 2px,
            var(--bg) 2px,
            var(--bg) 4px
        );
        border: 1px solid var(--fg);
    }

    /* --- CONTROLS --- */
    
    .controls {
        background: var(--bg);
        border: var(--border-thick) solid var(--fg);
        padding: 1rem;
        z-index: 100;
        display: flex;
        flex-direction: column;
        
        /* Desktop Positioning */
        position: absolute;
        top: var(--gap);
        right: var(--gap);
        width: clamp(200px, 20vw, 300px);
        max-height: 25vh;
    }

    /* Control Content */
    .btn-group { display: flex; flex-direction: column; gap: 0.5rem; }
    
    button {
        background: var(--fg);
        color: var(--bg);
        border: none;
        padding: 0.8rem;
        font-family: var(--font-main);
        font-weight: bold;
        font-size: clamp(0.8rem, 1vw, 1rem);
        cursor: pointer;
        text-transform: uppercase;
        width: 100%;
    }
    button:hover { background: #ccffcc; color: #000; }

    .status-log {
        font-size: 0.75rem;
        margin-top: 0.5rem;
        height: 100px; /* Fixed height for log area */
        overflow-y: auto;
        border-top: 1px solid var(--fg-dim);
        padding-top: 5px;
        scrollbar-width: none; /* Hide scrollbar for cleaner look */
    }
    
    /* INPUT FIELDS */
    .raw-input {
        background: transparent;
        border: none;
        border-bottom: 2px solid var(--fg);
        color: var(--fg);
        font-family: var(--font-main);
        font-size: clamp(1.2rem, 3vw, 2rem);
        text-align: center;
        width: 100%;
        max-width: 600px;
        outline: none;
        border-radius: 0;
    }

    .count-tag {
        position: absolute; 
        bottom: 5px; 
        right: 10px; 
        font-size: 0.8rem;
        opacity: 0;
        transition: opacity 0.5s;
    }

    /* --- MOBILE / PORTRAIT ADAPTATIONS --- */
    @media (max-width: 800px) or (orientation: portrait) {
        .controls {
            position: relative; /* In flow */
            top: auto; right: auto;
            width: 100%;
            order: -1; /* Move to top of flex container */
            max-height: none;
            flex-direction: row;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem;
        }

        .btn-group { width: 40%; }
        .status-log { 
            width: 60%; 
            height: 3rem; /* Compact log */
            margin-top: 0;
            border-top: none;
            border-left: 1px solid var(--fg-dim);
            padding-left: 0.5rem;
        }

        .zone { margin-bottom: 0; }
        
        /* Adjust Zone ratios for vertical screen */
        #zone-a { flex: 0 0 15%; }
        #zone-c { flex: 0 0 15%; }
        #zone-b { flex: 1 1 auto; } 
        
        .ledger-scroll-wrapper {
            justify-content: flex-start; /* Align start to allow scrolling */
        }
    }

    /* --- ANIMATION STATES --- */
    .glitch-anim { animation: glitch 0.3s steps(2) infinite; }
    @keyframes glitch {
        0% { transform: translate(0); }
        20% { transform: translate(-2px, 2px); }
        40% { transform: translate(-2px, -2px); }
        60% { transform: translate(2px, 2px); }
        80% { transform: translate(2px, -2px); }
        100% { transform: translate(0); }
    }

    .flash-red { animation: flashRed 0.5s; }
    @keyframes flashRed {
        0%, 100% { background: var(--bg); }
        50% { background: var(--err); }
    }

    .error-tile {
        border-color: var(--err) !important;
        color: var(--err) !important;
        animation: glitch 0.2s infinite;
    }
    
    .overlay-msg {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(5,5,5,0.9);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        display: none;
        backdrop-filter: blur(4px);
    }
    .overlay-msg h1 { 
        font-size: clamp(2rem, 5vw, 4rem); 
        margin: 0; 
        text-transform: uppercase; 
        text-align: center;
        padding: 0 1rem;
    }
    .overlay-msg p { margin-top: 1rem; cursor: pointer; border-bottom: 1px solid; }
    .overlay-msg.success h1 { color: var(--fg); text-shadow: 0 0 10px var(--fg); }
    .overlay-msg.fail h1 { color: var(--err); text-shadow: 0 0 10px var(--err); }

</style>
</head>
<body>

<div class="dither-overlay"></div>
<div class="scanlines"></div>

<div class="crt-container">
    
    <!-- CONTROLS -->
    <div class="controls">
        <div class="btn-group">
            <button id="btn-start">INITIATE SEQUENCE</button>
            <button id="btn-reset" style="display:none;">SYSTEM RESET</button>
        </div>
        <div class="status-log" id="log">
            <div class="log-entry">> SYSTEM READY</div>
            <div class="log-entry">> AWAITING INPUT...</div>
        </div>
    </div>

    <!-- ZONE A: SOURCE -->
    <div class="zone" id="zone-a">
        <div class="label">ZONE_A :: SOURCE_STREAM</div>
        <div class="input-container" id="container-a">
            <input type="text" class="raw-input" id="input-a" value="Listen!" placeholder="String 1" autocomplete="off">
        </div>
        <div id="count-a" class="count-tag">LEN: 0</div>
    </div>

    <!-- ZONE B: LEDGER -->
    <div class="zone" id="zone-b">
        <div class="label">ZONE_B :: MEMORY_LEDGER</div>
        <div class="ledger-scroll-wrapper" id="ledger-wrapper">
            <!-- Bins generated here -->
        </div>
    </div>

    <!-- ZONE C: CANDIDATE -->
    <div class="zone" id="zone-c">
        <div class="label">ZONE_C :: CANDIDATE_STREAM</div>
        <div class="input-container" id="container-c">
            <input type="text" class="raw-input" id="input-c" value="Silent" placeholder="String 2" autocomplete="off">
        </div>
        <div id="count-c" class="count-tag">LEN: 0</div>
    </div>

</div>

<!-- RESULTS OVERLAY -->
<div id="result-overlay" class="overlay-msg">
    <h1 id="result-text"></h1>
    <p>CLICK TO RESET</p>
</div>

<script>
/**
 * DITHERPUNK ANAGRAM VISUALIZER
 * Responsive Logic Controller
 */

const log = (msg) => {
    const el = document.getElementById('log');
    const line = document.createElement('div');
    line.className = 'log-entry';
    line.innerText = `> ${msg}`;
    el.prepend(line);
};

const wait = (ms) => new Promise(r => setTimeout(r, ms));

const elements = {
    inputA: document.getElementById('input-a'),
    inputC: document.getElementById('input-c'),
    contA: document.getElementById('container-a'),
    contC: document.getElementById('container-c'),
    zoneB: document.getElementById('ledger-wrapper'), // Point to scroll wrapper
    btnStart: document.getElementById('btn-start'),
    btnReset: document.getElementById('btn-reset'),
    countA: document.getElementById('count-a'),
    countC: document.getElementById('count-c'),
    overlay: document.getElementById('result-overlay'),
    resText: document.getElementById('result-text')
};

// Global State
let tilesA = [];
let tilesC = [];
let binMap = {}; 

/* --- CORE FUNCTIONS --- */

async function initSequence() {
    const valA = elements.inputA.value;
    const valC = elements.inputC.value;

    if(!valA || !valC) {
        log("ERR: NULL INPUT");
        return;
    }

    elements.btnStart.style.display = 'none';
    elements.btnReset.style.display = 'block';
    
    // 1. Transform Inputs to Tiles
    createTiles(valA, elements.contA, tilesA);
    createTiles(valC, elements.contC, tilesC);
    
    await wait(800);

    // 2. Sanitize
    log("PHASE 1: SANITIZATION");
    await sanitizeSequence(tilesA);
    await sanitizeSequence(tilesC);

    // 3. Length Check
    log("PHASE 2: LENGTH VERIFICATION");
    const lenA = tilesA.filter(t => !t.deleted).length;
    const lenC = tilesC.filter(t => !t.deleted).length;

    elements.countA.innerText = `LEN: ${lenA}`;
    elements.countC.innerText = `LEN: ${lenC}`;
    elements.countA.style.opacity = 1;
    elements.countC.style.opacity = 1;

    if (lenA !== lenC) {
        triggerFailure("LENGTH MISMATCH");
        return;
    }
    
    // Green flash for match
    document.body.style.backgroundColor = '#0a2a0a';
    await wait(100);
    document.body.style.backgroundColor = 'var(--bg)';
    log("LENGTH CHECK: PASSED");

    // 4. Inventory Build
    log("PHASE 3: INVENTORY BUILD");
    for (let tile of tilesA) {
        if (tile.deleted) continue;
        await processInventory(tile);
    }

    // 5. Consumption
    log("PHASE 4: CANCELLATION LOOP");
    for (let tile of tilesC) {
        if (tile.deleted) continue;
        const success = await processConsumption(tile);
        if (!success) return; 
    }

    // 6. Success
    triggerSuccess();
}

function createTiles(str, container, list) {
    container.innerHTML = '';
    str.split('').forEach(char => {
        const span = document.createElement('div');
        span.className = 'tile';
        span.innerText = char;
        container.appendChild(span);
        list.push({ el: span, char: char, deleted: false });
    });
}

async function sanitizeSequence(list) {
    for (let item of list) {
        item.el.style.borderColor = 'var(--fg)';
        await wait(50); // Faster scan for UX

        if (/[^a-zA-Z0-9]/.test(item.char)) {
            // Bad char
            item.el.classList.add('glitch-anim');
            item.el.style.borderColor = 'var(--err)';
            item.el.style.color = 'var(--err)';
            await wait(200);
            
            // Collapse effect
            item.el.style.opacity = 0;
            item.el.style.width = 0;
            item.el.style.minWidth = 0;
            item.el.style.margin = 0;
            item.el.style.border = 0;
            item.deleted = true;
        } else {
            // Normalize
            item.char = item.char.toLowerCase();
            item.el.innerText = item.char;
            item.el.style.borderColor = '#fff'; 
        }
        await wait(20);
        if(!item.deleted) item.el.style.borderColor = 'var(--fg)';
    }
}

async function processInventory(item) {
    item.el.style.background = 'var(--fg)';
    item.el.style.color = 'var(--bg)';
    
    const char = item.char;
    let bin = binMap[char];

    if (!bin) {
        bin = document.createElement('div');
        bin.className = 'bin';
        const label = document.createElement('div');
        label.className = 'bin-label';
        label.innerText = char.toUpperCase();
        bin.appendChild(label);
        elements.zoneB.appendChild(bin);
        binMap[char] = { el: bin, count: 0 };
        
        // Ensure new bin is visible
        bin.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'end' });
    }

    await animateGhost(item.el, binMap[char].el);

    binMap[char].count++;
    const block = document.createElement('div');
    block.className = 'block';
    binMap[char].el.appendChild(block);

    item.el.classList.add('processed');
    item.el.style.background = 'var(--bg)';
    item.el.style.color = 'var(--fg)';
}

async function processConsumption(item) {
    item.el.style.background = '#ff9900'; 
    item.el.style.color = 'var(--bg)';
    item.el.style.borderColor = '#ff9900';

    const char = item.char;
    const binObj = binMap[char];

    if (!binObj) {
        log(`ERR: ITEM '${char.toUpperCase()}' NOT FOUND`);
        item.el.classList.add('error-tile');
        triggerFailure(`UNKNOWN ITEM: ${char.toUpperCase()}`);
        return false;
    }

    // Scroll bin into view if offscreen (important for mobile)
    binObj.el.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
    
    await animateGhost(item.el, binObj.el, '#ff9900');

    if (binObj.count <= 0) {
        log(`ERR: DEFICIT FOR '${char.toUpperCase()}'`);
        binObj.el.querySelector('.bin-label').style.color = 'var(--err)';
        triggerFailure(`DEFICIT: ${char.toUpperCase()}`);
        return false;
    }

    binObj.count--;
    const blocks = binObj.el.querySelectorAll('.block');
    const topBlock = blocks[blocks.length - 1];
    topBlock.remove(); 
    
    item.el.classList.add('processed');
    item.el.style.background = 'var(--bg)';
    item.el.style.color = 'var(--fg)';
    item.el.style.borderColor = 'var(--fg)';
    return true;
}

function animateGhost(startEl, targetEl, color = null) {
    return new Promise(resolve => {
        const r1 = startEl.getBoundingClientRect();
        const r2 = targetEl.getBoundingClientRect();

        const ghost = startEl.cloneNode(true);
        ghost.className = 'tile ghost'; // Ensure it picks up ghost styles
        document.body.appendChild(ghost);

        if(color) {
            ghost.style.borderColor = color;
            ghost.style.color = color;
        }

        ghost.style.top = r1.top + 'px';
        ghost.style.left = r1.left + 'px';
        // Force width/height to match exactly for the animation start
        ghost.style.width = r1.width + 'px';
        ghost.style.height = r1.height + 'px';

        const deltaX = (r2.left + r2.width/2) - (r1.left + r1.width/2);
        const deltaY = (r2.top + r2.height) - (r1.top + r1.height/2);

        const anim = ghost.animate([
            { transform: 'translate(0,0)' },
            { transform: `translate(${deltaX}px, ${deltaY}px)` }
        ], {
            duration: 600,
            easing: 'cubic-bezier(0.23, 1, 0.32, 1)',
            fill: 'forwards'
        });

        anim.onfinish = () => {
            ghost.remove();
            resolve();
        };
    });
}

function triggerFailure(reason) {
    document.body.classList.add('flash-red');
    elements.overlay.className = 'overlay-msg fail';
    elements.resText.innerText = "FALSE";
    const sub = document.createElement('p');
    sub.innerText = reason;
    elements.resText.after(sub);
    elements.overlay.style.display = 'flex';
    log(`FATAL: ${reason}`);
}

function triggerSuccess() {
    elements.overlay.className = 'overlay-msg success';
    elements.resText.innerText = "ANAGRAM CONFIRMED";
    elements.overlay.style.display = 'flex';
    log("SUCCESS: INTEGRITY VERIFIED");
}

/* --- EVENT LISTENERS --- */

elements.btnStart.addEventListener('click', initSequence);
elements.btnReset.addEventListener('click', () => location.reload());
elements.overlay.addEventListener('click', () => location.reload());

</script>
</body>
</html>