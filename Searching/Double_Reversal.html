<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ditherpunk Double-Reverse</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --bg: #000000;
            --fg: #00FF41; /* Terminal Green */
            --fg-dim: #004411;
            --font-main: 'VT323', monospace;
            --tape-height: 12vh;
            --slot-size: 5vw;
            --anim-speed: 600ms;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font-main);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- CRT & Dither Effects --- */
        
        /* Scanlines */
        .crt-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 999;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
        }

        /* Text Glow */
        .glow-text {
            text-shadow: 0 0 4px var(--fg), 0 0 10px var(--fg);
        }

        /* Dither Patterns */
        .dither-active {
            /* Inverted */
            background-color: var(--fg);
            color: var(--bg);
        }

        .dither-swapping {
            /* Striped Noise */
            background: repeating-linear-gradient(
                45deg,
                var(--fg),
                var(--fg) 4px,
                var(--bg) 4px,
                var(--bg) 8px
            );
            color: var(--bg);
            text-shadow: 1px 1px 0 var(--fg); /* Outline for legibility */
        }

        .dither-finalized {
            /* Checkerboard */
            background-image: 
                linear-gradient(45deg, var(--fg-dim) 25%, transparent 25%), 
                linear-gradient(-45deg, var(--fg-dim) 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, var(--fg-dim) 75%), 
                linear-gradient(-45deg, transparent 75%, var(--fg-dim) 75%);
            background-size: 4px 4px;
            background-position: 0 0, 0 2px, 2px -2px, -2px 0px;
            color: var(--fg);
            border-color: var(--fg);
        }

        /* --- Layout Zones --- */

        /* Zone B: Pointers (Top 20%) */
        #zone-b {
            height: 20vh;
            width: 100%;
            position: relative;
            display: flex;
            align-items: flex-end;
            justify-content: center;
        }

        /* Zone A: Memory Tape (Center 40%) */
        #zone-a {
            height: 40vh;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* Zone C: Logic (Bottom 40%) */
        #zone-c {
            height: 40vh;
            width: 100%;
            border-top: 2px solid var(--fg);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* --- Components --- */

        .tape-container {
            position: relative;
            display: flex;
            gap: 10px;
            padding: 0 5vw;
        }

        .slot {
            width: var(--slot-size);
            height: var(--slot-size);
            min-width: 40px;
            min-height: 40px;
            border: 2px solid var(--fg-dim);
            position: relative; /* Anchor for absolute tile */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .slot.space-slot {
            border: 2px dashed var(--fg);
        }

        /* The actual character moving around */
        .tile {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            border: 2px solid var(--fg);
            background-color: var(--bg);
            transition: transform var(--anim-speed) cubic-bezier(0.68, -0.55, 0.265, 1.55),
                        background-color 0.2s, color 0.2s;
            z-index: 10;
        }

        .tile.dimmed {
            opacity: 0.2;
        }

        /* Pointers */
        .pointer-track {
            position: absolute;
            bottom: 10px;
            left: 0;
            height: 50px;
            /* width handled by JS to match tape */
        }
        
        .pointer {
            position: absolute;
            font-size: 2rem;
            text-align: center;
            width: var(--slot-size);
            min-width: 40px;
            transition: left 0.4s ease-out;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .pointer span {
            font-size: 1rem;
            margin-top: -5px;
        }

        #scanner-icon {
            font-size: 3rem;
            color: var(--fg);
            position: absolute;
            top: -50px; 
            transition: left 0.3s linear;
            display: none;
            text-shadow: 0 0 10px var(--fg);
        }

        /* SVG Overlay for Arcs */
        #arc-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
        }
        
        path.swap-line {
            fill: none;
            stroke: var(--fg);
            stroke-width: 2;
            stroke-dasharray: 10;
            animation: dash 0.5s linear infinite;
        }

        @keyframes dash {
            to { stroke-dashoffset: -20; }
        }

        /* Console */
        .phase-indicator {
            font-size: 2.5rem;
            text-transform: uppercase;
            border-bottom: 1px solid var(--fg-dim);
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        .console-log {
            flex-grow: 1;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            scrollbar-width: thin;
            scrollbar-color: var(--fg) var(--bg);
        }

        .log-entry {
            margin-bottom: 5px;
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }
        .log-entry::before { content: "> "; color: var(--fg-dim); }

        @keyframes fadeIn { to { opacity: 1; } }

        /* Controls */
        #replay-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg);
            border: 2px solid var(--fg);
            color: var(--fg);
            padding: 10px 20px;
            font-family: var(--font-main);
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 1000;
            text-transform: uppercase;
        }
        #replay-btn:hover {
            background: var(--fg);
            color: var(--bg);
        }

    </style>
</head>
<body>

    <div class="crt-overlay"></div>

    <button id="replay-btn" onclick="init()">Replay System</button>

    <!-- ZONE B: POINTERS -->
    <div id="zone-b">
        <div id="scanner-icon">üëÅ</div>
        <div class="pointer-track" id="pointer-track">
            <!-- Pointers injected here -->
        </div>
    </div>

    <!-- ZONE A: MEMORY TAPE -->
    <div id="zone-a">
        <svg id="arc-layer"></svg>
        <div class="tape-container" id="tape">
            <!-- Slots and Tiles injected here -->
        </div>
    </div>

    <!-- ZONE C: LOGIC -->
    <div id="zone-c">
        <div class="phase-indicator" id="phase-display">SYSTEM IDLE</div>
        <div class="console-log" id="console"></div>
    </div>

    <script>
        // --- Configuration ---
        const INITIAL_TEXT = ['r','a','m',' ','i','s',' ','c','o','s','t','l','y'];
        const delay = (ms) => new Promise(res => setTimeout(res, ms));
        
        // --- State ---
        let state = {
            chars: [], // objects: { char, id, index }
            running: false
        };

        // --- Elements ---
        const tapeEl = document.getElementById('tape');
        const arcLayer = document.getElementById('arc-layer');
        const phaseDisplay = document.getElementById('phase-display');
        const consoleEl = document.getElementById('console');
        const pointerTrack = document.getElementById('pointer-track');
        const scannerIcon = document.getElementById('scanner-icon');

        // --- Initialization ---
        function init() {
            if(state.running) return; // Prevent double click
            
            // Reset DOM
            tapeEl.innerHTML = '';
            pointerTrack.innerHTML = '';
            consoleEl.innerHTML = '';
            arcLayer.innerHTML = '';
            scannerIcon.style.display = 'none';

            // Create Data
            state.chars = INITIAL_TEXT.map((c, i) => ({
                char: c,
                id: i,
                index: i // Logical index
            }));

            // Build Tape
            state.chars.forEach((item, i) => {
                // Slot (Background placeholder)
                const slot = document.createElement('div');
                slot.className = `slot ${item.char === ' ' ? 'space-slot' : ''}`;
                slot.id = `slot-${i}`;
                
                // Tile (Moving element)
                const tile = document.createElement('div');
                tile.className = 'tile glow-text';
                tile.textContent = item.char;
                tile.id = `tile-${item.id}`;
                
                // Append Tile to Slot initially (will move via transform)
                slot.appendChild(tile);
                tapeEl.appendChild(slot);
            });

            log("System Initialized.");
            log("Memory Load: ['r','a','m',' ','i','s',' ','c','o','s','t','l','y']");

            runAlgorithm();
        }

        // --- Core Animation Logic ---

        // Helper to get visual X position of a slot relative to container
        function getSlotX(index) {
            const slot = document.getElementById(`slot-${index}`);
            return slot.offsetLeft;
        }

        // Move a tile visual to a specific slot index
        function moveTileVisual(tileId, targetIndex) {
            const tile = document.getElementById(`tile-${tileId}`);
            const parentSlot = tile.parentElement; // The slot it visually lives in (physically)
            const parentIndex = parseInt(parentSlot.id.split('-')[1]);
            
            const currentX = 0; // It's absolute 0,0 relative to parent
            const targetX = getSlotX(targetIndex) - getSlotX(parentIndex);
            
            tile.style.transform = `translateX(${targetX}px)`;
        }

        // Logical Swap + Visual Swap
        async function swap(idx1, idx2, mode = 'arc') {
            // 1. Identify objects
            const item1 = state.chars.find(c => c.index === idx1);
            const item2 = state.chars.find(c => c.index === idx2);
            
            const tile1 = document.getElementById(`tile-${item1.id}`);
            const tile2 = document.getElementById(`tile-${item2.id}`);

            // 2. Visual State: Swapping
            tile1.classList.add('dither-swapping');
            tile2.classList.add('dither-swapping');

            // 3. Draw Connector (only for global phase)
            let line = null;
            if (mode === 'arc') {
                line = drawArc(idx1, idx2);
            }

            // 4. Animate Move
            moveTileVisual(item1.id, idx2);
            moveTileVisual(item2.id, idx1);

            await delay(700); // Wait for transition

            // 5. Cleanup Visuals
            tile1.classList.remove('dither-swapping');
            tile2.classList.remove('dither-swapping');
            if (line) line.remove();

            // 6. Logical Update (Crucial: Reparenting)
            // We need to physically swap the DOM elements to the new slots 
            // to reset transforms so future calculations work correctly.
            const slot1 = document.getElementById(`slot-${idx1}`);
            const slot2 = document.getElementById(`slot-${idx2}`);

            // Reset transforms
            tile1.style.transition = 'none';
            tile2.style.transition = 'none';
            tile1.style.transform = 'translate(0,0)';
            tile2.style.transform = 'translate(0,0)';
            
            // Swap parents
            slot1.appendChild(tile2);
            slot2.appendChild(tile1);

            // Force reflow
            tile1.offsetHeight; 

            // Restore transition
            tile1.style.transition = '';
            tile2.style.transition = '';

            // Update State Array
            item1.index = idx2;
            item2.index = idx1;
        }

        function drawArc(idx1, idx2) {
            const rect1 = document.getElementById(`slot-${idx1}`).getBoundingClientRect();
            const rect2 = document.getElementById(`slot-${idx2}`).getBoundingClientRect();
            const containerRect = document.getElementById('zone-a').getBoundingClientRect();

            // Centers relative to SVG container
            const x1 = rect1.left + rect1.width/2 - containerRect.left;
            const y1 = rect1.top - containerRect.top;
            const x2 = rect2.left + rect2.width/2 - containerRect.left;
            const y2 = rect2.top - containerRect.top;

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            // Bezier control point
            const cx = (x1 + x2) / 2;
            const cy = y1 - 100; // Arc height

            const d = `M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}`;
            path.setAttribute("d", d);
            path.setAttribute("class", "swap-line");
            arcLayer.appendChild(path);
            return path;
        }

        // --- Pointer Logic ---

        function createPointer(label, type) {
            const p = document.createElement('div');
            p.className = 'pointer glow-text';
            p.innerHTML = `${type === 'up' ? '‚ñ≤' : '‚ñº'}<span>${label}</span>`;
            p.style.color = type === 'start' ? '#00FF41' : '#00AA22';
            pointerTrack.appendChild(p);
            return p;
        }

        function setPointerPos(el, index) {
            if(index >= state.chars.length) return; // Edge case safety
            const slot = document.getElementById(`slot-${index}`);
            // Calculate position relative to track
            // We need the slot's offset relative to the tape, plus tape's offset
            const tapeRect = tapeEl.getBoundingClientRect();
            const slotRect = slot.getBoundingClientRect();
            const trackRect = pointerTrack.getBoundingClientRect();

            // Center of slot relative to screen
            const center = slotRect.left + slotRect.width/2;
            // Relative to track
            const left = center - trackRect.left - (slotRect.width/2); // Centers pointer

            el.style.left = `${left}px`;
        }

        // --- Algorithm Execution ---

        async function runAlgorithm() {
            state.running = true;

            // --- PHASE 1: GLOBAL TRANSPOSITION ---
            phaseDisplay.innerText = "PHASE 1: GLOBAL TRANSPOSITION";
            log("Starting full array reversal...");

            let i = 0;
            let j = state.chars.length - 1;

            const ptrStart = createPointer('START', 'up');
            const ptrEnd = createPointer('END', 'up');

            while (i < j) {
                setPointerPos(ptrStart, i);
                setPointerPos(ptrEnd, j);
                
                log(`Swapping index [${i}] <-> [${j}]`);
                await swap(i, j, 'arc');
                
                i++;
                j--;
                await delay(300);
            }

            ptrStart.remove();
            ptrEnd.remove();

            log("Global reversal complete. Result: 'yltsoc si mar'");
            
            // Invert color effect for phase transition
            document.body.style.filter = "invert(1)";
            await delay(100);
            document.body.style.filter = "none";
            
            // --- PHASE 2: WORD CORRECTION ---
            phaseDisplay.innerText = "PHASE 2: ITERATIVE CORRECTION";
            log("Scanning for words...");

            let start = 0;
            
            // Initialize Scanner Icon
            scannerIcon.style.display = 'block';
            
            while (start < state.chars.length) {
                // 1. Move Start Pointer
                const pStart = createPointer('Start', 'up');
                setPointerPos(pStart, start);

                // 2. Scan for End
                let end = start;
                
                // Animation: Scanner moves
                while (end < state.chars.length) {
                    const charObj = state.chars.find(c => c.index === end);
                    
                    // Move visual scanner
                    const slot = document.getElementById(`slot-${end}`);
                    const slotRect = slot.getBoundingClientRect();
                    const trackRect = document.getElementById('zone-b').getBoundingClientRect();
                    scannerIcon.style.left = `${(slotRect.left + slotRect.width/2) - trackRect.left - 20}px`;
                    scannerIcon.style.top = `30px`; // Align in Zone B

                    await delay(200);

                    if (charObj.char === ' ') break;
                    end++;
                }

                // Edge Case Visual
                if (end === state.chars.length) {
                    log("Edge Case: End of Tape encountered.");
                }

                // 3. Drop End Pointer
                const pEnd = createPointer('End', 'up');
                // Point to the last character of the word, not the space
                setPointerPos(pEnd, end - 1);

                log(`Word found: Index ${start} to ${end - 1}`);

                // 4. Highlight Range & Dim Others
                const wordIndices = [];
                for(let k=start; k<end; k++) wordIndices.push(k);

                state.chars.forEach(c => {
                    const tile = document.getElementById(`tile-${c.id}`);
                    if(wordIndices.includes(c.index)) {
                        tile.classList.add('dither-active');
                        tile.classList.remove('dimmed');
                    } else {
                        tile.classList.add('dimmed');
                        tile.classList.remove('dither-active');
                    }
                });

                await delay(500);

                // 5. Reverse Word (Local Swap)
                let low = start;
                let high = end - 1;

                while (low < high) {
                    await swap(low, high, 'slide'); // Use 'slide' (no arc)
                    low++;
                    high--;
                }

                // 6. Finalize Word
                wordIndices.forEach(idx => {
                    const c = state.chars.find(obj => obj.index === idx);
                    const tile = document.getElementById(`tile-${c.id}`);
                    tile.classList.remove('dither-active');
                    tile.classList.add('dither-finalized');
                });
                
                log("Word corrected.");

                // Cleanup Pointers
                pStart.remove();
                pEnd.remove();

                // Move Start
                start = end + 1;
                
                // Restore Opacity
                document.querySelectorAll('.tile').forEach(t => t.classList.remove('dimmed'));
                
                await delay(500);
            }

            scannerIcon.style.display = 'none';
            phaseDisplay.innerText = "SEQUENCE COMPLETE";
            log("Final Output: 'costly is ram'");
            state.running = false;
        }

        // --- Console Helper ---
        function log(msg) {
            const p = document.createElement('div');
            p.className = 'log-entry';
            p.textContent = msg;
            consoleEl.appendChild(p);
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        // Start immediately
        window.onload = init;
        window.onresize = () => { if(!state.running) init(); }; // Simple responsive fix: reset if resized while idle

    </script>
</body>
</html>