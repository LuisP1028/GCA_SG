<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aligned Ditherpunk Visualizer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --bg: #000000;
            --fg: #00FF41; /* Terminal Green */
            --fg-dim: #004411;
            --font-main: 'VT323', monospace;
            
            /* Responsive Calculations */
            /* Slots: Min 30px, Preferred 6vw, Max 80px */
            --slot-size: clamp(30px, 6vw, 80px); 
            
            /* Font sizes */
            --fs-base: clamp(1rem, 2vw, 1.25rem);
            --fs-large: clamp(1.5rem, 4vw, 2.5rem);
            
            --anim-speed: 600ms;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font-main);
            height: 100dvh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- CRT Overlay --- */
        .crt-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
            z-index: 999;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
        }

        .glow-text {
            text-shadow: 0 0 4px var(--fg), 0 0 10px var(--fg);
        }

        /* --- Layout Zones --- */

        /* Zone B: Pointers & Eye (Top) */
        #zone-b {
            height: 25dvh;
            min-height: 80px;
            width: 100%;
            position: relative;
            z-index: 50;
            /* No flex centering here; absolute positioning is used for children */
        }

        /* Zone A: Memory Tape (Middle) */
        #zone-a {
            height: 20dvh;
            min-height: calc(var(--slot-size) + 20px);
            width: 100%;
            display: flex;
            align-items: center; /* Vertically center the tape */
            justify-content: center; /* Horizontally center the tape */
            position: relative;
            z-index: 40;
        }

        /* Zone C: Logic/Console (Bottom/Fill) */
        #zone-c {
            flex-grow: 1;
            width: 100%;
            border-top: 2px solid var(--fg);
            padding: clamp(10px, 2vw, 20px);
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
        }

        /* --- Tape Components --- */

        .tape-container {
            position: relative;
            display: flex;
            justify-content: center;
            gap: clamp(2px, 0.5vw, 10px);
            padding: 0 2vw;
            /* Ensure the tape doesn't overflow horizontally on very small screens */
            max-width: 100%; 
        }

        .slot {
            width: var(--slot-size);
            height: var(--slot-size);
            flex-shrink: 0;
            border: 2px solid var(--fg-dim);
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .slot.space-slot {
            border: 2px dashed var(--fg);
            opacity: 0.5;
        }

        .tile {
            width: 100%;
            height: 100%;
            position: absolute;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: var(--fs-large);
            border: 2px solid var(--fg);
            background-color: var(--bg);
            transition: transform var(--anim-speed) cubic-bezier(0.68, -0.55, 0.265, 1.55),
                        background-color 0.2s, color 0.2s;
            z-index: 10;
        }

        .tile.dimmed { opacity: 0.2; }

        .dither-active {
            background-color: var(--fg);
            color: var(--bg);
        }

        .dither-swapping {
            background: repeating-linear-gradient(
                45deg, var(--fg), var(--fg) 4px, var(--bg) 4px, var(--bg) 8px
            );
            color: var(--bg);
            text-shadow: 1px 1px 0 var(--fg);
        }

        .dither-finalized {
            background-image: 
                linear-gradient(45deg, var(--fg-dim) 25%, transparent 25%), 
                linear-gradient(-45deg, var(--fg-dim) 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, var(--fg-dim) 75%), 
                linear-gradient(-45deg, transparent 75%, var(--fg-dim) 75%);
            background-size: 4px 4px;
            color: var(--fg);
        }

        /* --- Pointer Components (In Zone B) --- */

        .pointer-track {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }
        
        .pointer {
            position: absolute;
            font-size: var(--fs-large);
            text-align: center;
            min-width: 40px; /* Ensure enough width for text */
            transition: left 0.4s ease-out;
            bottom: 0; /* Align to bottom of Zone B (touching top of Zone A) */
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 55;
        }

        .pointer span {
            font-size: var(--fs-base);
            background: var(--bg);
            padding: 0 4px;
            margin-top: -5px;
        }

        #scanner-icon {
            font-size: calc(var(--fs-large) * 1.5);
            color: var(--fg);
            position: absolute;
            /* Vertically center in Zone B */
            top: 50%;
            transform: translateY(-50%) translateX(-50%); /* Center based on its own width */
            transition: left 0.15s linear; /* Fast, linear movement for scanning */
            display: none;
            text-shadow: 0 0 10px var(--fg);
            z-index: 60;
        }

        /* SVG Overlay */
        #arc-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
            overflow: visible;
        }
        
        path.swap-line {
            fill: none;
            stroke: var(--fg);
            stroke-width: 2;
            stroke-dasharray: 10;
            animation: dash 0.5s linear infinite;
        }

        @keyframes dash { to { stroke-dashoffset: -20; } }

        /* Console */
        .phase-indicator {
            font-size: var(--fs-large);
            text-transform: uppercase;
            border-bottom: 1px solid var(--fg-dim);
            padding-bottom: 5px;
            margin-bottom: 5px;
            flex-shrink: 0;
        }

        .console-log {
            flex-grow: 1;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: var(--fs-base);
            scrollbar-width: thin;
            scrollbar-color: var(--fg) var(--bg);
            padding-bottom: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
            opacity: 0;
            animation: fadeIn 0.3s forwards;
            word-wrap: break-word;
        }
        .log-entry::before { content: "> "; color: var(--fg-dim); }

        @keyframes fadeIn { to { opacity: 1; } }

        /* UI Controls */
        #replay-btn {
            position: fixed;
            top: clamp(10px, 2vh, 20px);
            right: clamp(10px, 2vw, 20px);
            background: rgba(0,0,0,0.8);
            border: 2px solid var(--fg);
            color: var(--fg);
            padding: 8px 16px;
            font-family: var(--font-main);
            font-size: var(--fs-base);
            cursor: pointer;
            z-index: 1000;
            text-transform: uppercase;
            backdrop-filter: blur(2px);
        }
        #replay-btn:hover {
            background: var(--fg);
            color: var(--bg);
        }

    </style>
</head>
<body>

    <div class="crt-overlay"></div>

    <button id="replay-btn" onclick="triggerInit()">Replay System</button>

    <!-- ZONE B: Pointers & Scanner -->
    <div id="zone-b">
        <div id="scanner-icon">üëÅ</div>
        <div class="pointer-track" id="pointer-track">
            <!-- Pointers injected here -->
        </div>
    </div>

    <!-- ZONE A: Memory Tape -->
    <div id="zone-a">
        <svg id="arc-layer"></svg>
        <div class="tape-container" id="tape">
            <!-- Slots and Tiles injected here -->
        </div>
    </div>

    <!-- ZONE C: Logic -->
    <div id="zone-c">
        <div class="phase-indicator" id="phase-display">SYSTEM IDLE</div>
        <div class="console-log" id="console"></div>
    </div>

    <script>
        // --- Configuration ---
        const INITIAL_TEXT = ['r','a','m',' ','i','s',' ','c','o','s','t','l','y'];
        const delay = (ms) => new Promise(res => setTimeout(res, ms));
        
        // --- State ---
        let state = {
            chars: [], 
            running: false,
            abort: false
        };

        let resizeTimeout;

        // --- Elements ---
        const tapeEl = document.getElementById('tape');
        const arcLayer = document.getElementById('arc-layer');
        const phaseDisplay = document.getElementById('phase-display');
        const consoleEl = document.getElementById('console');
        const pointerTrack = document.getElementById('pointer-track');
        const scannerIcon = document.getElementById('scanner-icon');
        const zoneB = document.getElementById('zone-b');

        // --- Initialization ---
        async function triggerInit() {
            if (state.running) {
                state.abort = true;
                await delay(200); 
            }
            init();
        }

        function init() {
            state.running = false;
            state.abort = false;
            
            // Cleanup
            tapeEl.innerHTML = '';
            pointerTrack.innerHTML = '';
            consoleEl.innerHTML = '';
            arcLayer.innerHTML = '';
            scannerIcon.style.display = 'none';
            document.body.style.filter = "none";

            // Create Data
            state.chars = INITIAL_TEXT.map((c, i) => ({
                char: c,
                id: i,
                index: i
            }));

            // Build Tape
            state.chars.forEach((item, i) => {
                const slot = document.createElement('div');
                slot.className = `slot ${item.char === ' ' ? 'space-slot' : ''}`;
                slot.id = `slot-${i}`;
                
                const tile = document.createElement('div');
                tile.className = 'tile glow-text';
                tile.textContent = item.char;
                tile.id = `tile-${item.id}`;
                
                slot.appendChild(tile);
                tapeEl.appendChild(slot);
            });

            log("System Initialized.");
            log("Memory Load: ['r','a','m',' ','i','s',' ','c','o','s','t','l','y']");

            // Wait for paint
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    runAlgorithm();
                });
            });
        }

        // --- Alignment Logic ---
        
        /**
         * Gets the center X coordinate of a specific slot relative to the viewport.
         */
        function getSlotCenterX(index) {
            const slot = document.getElementById(`slot-${index}`);
            if(!slot) return 0;
            const rect = slot.getBoundingClientRect();
            return rect.left + (rect.width / 2);
        }

        /**
         * Aligns a DOM element (pointer/scanner) to the center of a target slot.
         * The element must be a direct child of 'zone-b' or 'pointer-track'.
         */
        function alignElementToSlot(element, slotIndex) {
            if (!element) return;
            
            const targetX = getSlotCenterX(slotIndex);
            
            // Get the container's left edge to calculate relative position
            // Since element is absolute inside zone-b/pointer-track, we need relative X
            const containerRect = pointerTrack.getBoundingClientRect();
            
            // We want the element's center to match targetX
            // element.left = targetX - container.left - (element.width / 2)
            
            // Note: For the scanner, we use transform: translate(-50%), so we just set left to the center point.
            // For pointers, we calculate width offset manually to be safe.
            
            if (element.id === 'scanner-icon') {
                // Scanner uses transform translate(-50%), so just set left to relative center
                const relativeX = targetX - containerRect.left;
                element.style.left = `${relativeX}px`;
            } else {
                // Pointers don't use translate X (to allow transition on left property)
                const elWidth = element.offsetWidth;
                const relativeX = targetX - containerRect.left - (elWidth / 2);
                element.style.left = `${relativeX}px`;
            }
        }

        // --- Visual Logic ---

        function moveTileVisual(tileId, targetIndex) {
            const tile = document.getElementById(`tile-${tileId}`);
            if (!tile) return;
            
            const currentSlot = tile.parentElement;
            const targetSlot = document.getElementById(`slot-${targetIndex}`);
            
            const currentRect = currentSlot.getBoundingClientRect();
            const targetRect = targetSlot.getBoundingClientRect();
            
            const deltaX = targetRect.left - currentRect.left;
            tile.style.transform = `translateX(${deltaX}px)`;
        }

        async function swap(idx1, idx2, mode = 'arc') {
            if(state.abort) return;

            const item1 = state.chars.find(c => c.index === idx1);
            const item2 = state.chars.find(c => c.index === idx2);
            const tile1 = document.getElementById(`tile-${item1.id}`);
            const tile2 = document.getElementById(`tile-${item2.id}`);

            tile1.classList.add('dither-swapping');
            tile2.classList.add('dither-swapping');

            let line = null;
            if (mode === 'arc') line = drawArc(idx1, idx2);

            moveTileVisual(item1.id, idx2);
            moveTileVisual(item2.id, idx1);

            await delay(600);
            if(state.abort) return;

            tile1.classList.remove('dither-swapping');
            tile2.classList.remove('dither-swapping');
            if (line) line.remove();

            // Physical DOM swap
            const slot1 = document.getElementById(`slot-${idx1}`);
            const slot2 = document.getElementById(`slot-${idx2}`);

            tile1.style.transition = 'none';
            tile2.style.transition = 'none';
            tile1.style.transform = 'translate(0,0)';
            tile2.style.transform = 'translate(0,0)';
            
            slot1.appendChild(tile2);
            slot2.appendChild(tile1);

            void tile1.offsetWidth; // Force Reflow

            tile1.style.transition = '';
            tile2.style.transition = '';

            item1.index = idx2;
            item2.index = idx1;
        }

        function drawArc(idx1, idx2) {
            const rect1 = document.getElementById(`slot-${idx1}`).getBoundingClientRect();
            const rect2 = document.getElementById(`slot-${idx2}`).getBoundingClientRect();
            const svgRect = arcLayer.getBoundingClientRect();

            const x1 = (rect1.left + rect1.width/2) - svgRect.left;
            const y1 = (rect1.top) - svgRect.top;
            const x2 = (rect2.left + rect2.width/2) - svgRect.left;
            const y2 = (rect2.top) - svgRect.top;

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            const cx = (x1 + x2) / 2;
            const dist = Math.abs(x1 - x2);
            const arcHeight = Math.min(150, dist / 2 + 20); 
            const cy = y1 - arcHeight;

            const d = `M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}`;
            path.setAttribute("d", d);
            path.setAttribute("class", "swap-line");
            arcLayer.appendChild(path);
            return path;
        }

        function createPointer(label, type) {
            const p = document.createElement('div');
            p.className = 'pointer glow-text';
            p.innerHTML = `${type === 'up' ? '‚ñ≤' : '‚ñº'}<span>${label}</span>`;
            p.style.color = type === 'start' ? '#00FF41' : '#00AA22';
            pointerTrack.appendChild(p);
            return p;
        }

        // --- Main Algorithm ---

        async function runAlgorithm() {
            state.running = true;

            // Phase 1: Global Reversal
            phaseDisplay.innerText = "PHASE 1: GLOBAL REVERSAL";
            log("Algorithm: Two-pointer swap from ends.");

            let i = 0;
            let j = state.chars.length - 1;

            const ptrStart = createPointer('L', 'up');
            const ptrEnd = createPointer('R', 'up');

            // Force initial position calculation
            alignElementToSlot(ptrStart, i);
            alignElementToSlot(ptrEnd, j);
            await delay(400);

            while (i < j) {
                if(state.abort) return;

                log(`Swapping [${i}] <-> [${j}]`);
                await swap(i, j, 'arc');
                
                i++;
                j--;

                alignElementToSlot(ptrStart, i);
                alignElementToSlot(ptrEnd, j);
                await delay(300);
            }

            ptrStart.remove();
            ptrEnd.remove();

            log("Global reversal complete.");
            
            // Screen Flash
            document.body.style.filter = "invert(1)";
            await delay(100);
            document.body.style.filter = "none";
            
            // Phase 2: Word Correction
            phaseDisplay.innerText = "PHASE 2: WORD CORRECTION";
            log("Reversing individual words.");

            let start = 0;
            scannerIcon.style.display = 'block';
            
            while (start < state.chars.length) {
                if(state.abort) return;

                const pStart = createPointer('Start', 'up');
                alignElementToSlot(pStart, start);

                let end = start;
                
                // Scanner Animation Loop
                while (end < state.chars.length) {
                    if(state.abort) return;
                    const charObj = state.chars.find(c => c.index === end);
                    
                    // Move scanner to current slot
                    alignElementToSlot(scannerIcon, end);
                    
                    await delay(150);

                    if (charObj.char === ' ') break;
                    end++;
                }

                const pEnd = createPointer('End', 'up');
                alignElementToSlot(pEnd, end - 1);

                log(`Word found: ${start} to ${end - 1}`);

                // Highlight Word
                const wordIndices = [];
                for(let k=start; k<end; k++) wordIndices.push(k);

                state.chars.forEach(c => {
                    const tile = document.getElementById(`tile-${c.id}`);
                    if(wordIndices.includes(c.index)) {
                        tile.classList.add('dither-active');
                        tile.classList.remove('dimmed');
                    } else {
                        tile.classList.add('dimmed');
                        tile.classList.remove('dither-active');
                    }
                });

                await delay(400);

                // Reverse Word
                let low = start;
                let high = end - 1;

                while (low < high) {
                    if(state.abort) return;
                    
                    // Keep pointers aligned during swap steps
                    alignElementToSlot(pStart, low);
                    alignElementToSlot(pEnd, high);
                    
                    await swap(low, high, 'slide');
                    low++;
                    high--;
                }

                // Finalize Word
                wordIndices.forEach(idx => {
                    const c = state.chars.find(obj => obj.index === idx);
                    const tile = document.getElementById(`tile-${c.id}`);
                    tile.classList.remove('dither-active');
                    tile.classList.add('dither-finalized');
                });
                
                pStart.remove();
                pEnd.remove();
                start = end + 1;
                
                document.querySelectorAll('.tile').forEach(t => t.classList.remove('dimmed'));
                await delay(300);
            }

            scannerIcon.style.display = 'none';
            phaseDisplay.innerText = "SEQUENCE COMPLETE";
            log("Result: 'costly is ram'");
            state.running = false;
        }

        function log(msg) {
            const p = document.createElement('div');
            p.className = 'log-entry';
            p.textContent = msg;
            consoleEl.appendChild(p);
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        // --- Event Listeners ---
        window.onload = triggerInit;

        window.onresize = () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                triggerInit();
            }, 300);
        };

    </script>
</body>
</html>