<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Part I: Arrays // Study Guide</title>
    <style>
        /*
        --- STYLE CONFIGURATION ---
        (Identical to Main Shell)
        */
        :root {
            --bg-color: #000000;
            --text-color: #00ff41;
            --accent-color: #00ff41;
            --dim-color: #003b00;
            --border-color: #00ff41;
            --font-main: 'Courier New', Courier, monospace;
            --font-header: 'Arial Black', Impact, sans-serif;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            line-height: 1.5;
            overflow-x: hidden;
        }

        .dither-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            background-image: radial-gradient(circle, #003b00 1px, transparent 1px);
            background-size: 4px 4px;
            opacity: 0.4;
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(0, 255, 65, 0), rgba(0, 255, 65, 0) 50%, rgba(0, 20, 0, 0.2) 50%, rgba(0, 20, 0, 0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 9999;
        }

        .container {
            max-width: 900px;
            width: 100%;
            margin: 0 auto;
            padding: 40px 20px;
            border-left: 2px dashed var(--dim-color);
            border-right: 2px dashed var(--dim-color);
            background-color: rgba(0, 10, 0, 0.9);
            min-height: 100vh;
        }

        h1 {
            font-family: var(--font-header);
            text-transform: uppercase;
            font-size: 2.5rem;
            border-bottom: 5px solid var(--accent-color);
            margin-bottom: 40px;
            color: var(--accent-color);
            text-align: center;
        }

        strong { color: var(--accent-color); }
        em { font-style: normal; color: #50c878; }

        /* ACCORDION STYLES */
        details.section {
            margin-bottom: 15px;
            border: 1px solid var(--dim-color);
            background: #050505;
        }

        details.section > summary {
            font-family: var(--font-main);
            font-weight: bold;
            padding: 12px;
            background: #0a0a0a;
            color: var(--text-color);
            cursor: pointer;
            list-style: none;
            border-bottom: 1px solid transparent;
            text-transform: uppercase;
            font-size: 1.1rem;
        }

        details.section > summary:hover { background: var(--dim-color); color: var(--accent-color); }
        details.section[open] > summary {
            border-bottom: 1px solid var(--dim-color);
            background: #0f0f0f;
            color: var(--accent-color);
            text-shadow: 0px 0px 5px var(--accent-color);
        }

        .section-content { padding: 20px; }

        .subsection {
            margin-bottom: 25px;
            border-left: 4px solid var(--dim-color);
            padding-left: 15px;
        }

        .subsection-title {
            background: var(--dim-color);
            color: var(--accent-color);
            padding: 2px 6px;
            font-weight: bold;
            text-transform: uppercase;
            display: inline-block;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        p { margin-bottom: 12px; margin-top: 0; text-align: justify; }
        ul { padding-left: 20px; margin-bottom: 15px; }
        li { margin-bottom: 5px; }

        .code-block {
            background: #020a02;
            border: 1px dashed var(--dim-color);
            padding: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            color: var(--accent-color);
            overflow-x: auto;
            white-space: pre-wrap;
        }

        /* EYE BUTTON (Visual Only) */
        .eye-btn {
            position: relative; width: 20px; height: 20px;
            background: #000; border: 1px solid var(--accent-color);
            display: inline-flex; align-items: center; justify-content: center;
            margin-left: 8px; vertical-align: middle; cursor: default;
        }
        .eye-btn svg { width: 100%; height: 100%; fill: var(--accent-color); }
    </style>
</head>
<body>

<div class="dither-layer"></div>
<div class="scanlines"></div>

<div class="container">
    <h1>Part I: Arrays</h1>

    <!-- MAIN CONTENT BUCKET -->
    <div class="part-content">
        
        <!-- ============================================== -->
        <!-- SECTION 1: TRAVERSAL & LOGIC -->
        <!-- ============================================== -->
        <details class="section">
            <summary>1. Traversal & Matrix Logic</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">
                        Array Spiraling
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Arrays/array_spiral.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p><strong>Layer-by-Layer:</strong> Treats the matrix as concentric rectangular rings (shells). You iterate through the top row, right column, bottom row, and left column of the outermost ring, then shrink the boundary.</p>
                    <p><strong>The How:</strong> Read the first row normally, transpose for columns. When reading bottom rows, traverse from <code>[-1]</code> to keep order. <em>Crucial Detail:</em> Stop one cell early when traversing columns/rows to ensure corners aren't counted twice. Mathematically: For a side of length L, process L-1 elements.</p>
                    <div class="code-block">
Analogy: Reading a Map
‚Ä¢ East: Hold map normally.
‚Ä¢ South: Turn head sideways.
‚Ä¢ West: Straighten head back to normal.
                    </div>
                </div>

                <div class="subsection">
                    <span class="subsection-title">Advancing Through an Array (Jump Game)</span>
                    <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Arrays/Greedy_Visual.html'; document.querySelector('.retro-viewport').classList.add('active');">
                        <svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                    </button>
                    
                    <p>The problem asks if you can navigate from the start of a list to the end, where the number at each position represents your maximum ‚Äújump‚Äù length.</p>
                    
                    <p><strong>Naive Approach (Simulating Every Path):</strong> This method creates "parallel universes" for every move. It fails because it creates a branching tree of possibilities that explodes exponentially, causing the program to freeze (Time Limit Exceeded).</p>
                    
                    <p><strong>Optimal Approach (The Greedy Horizon):</strong> Instead of tracking specific paths, we track the boundary. We walk one step at a time asking: <em>"Does the current stone allow me to extend the boundary further?"</em></p>
                    
                    
                        <li><strong>Reach & Horizon:</strong> <em>Reach</em> is your current index + jump capacity ($i + A[i]$). The <em>Horizon</em> is the maximum Reach calculated so far.</li>
                        <li><strong>Gap:</strong> If <code>Current Position > Horizon</code>, you have hit a dead end (a gap in the bridge).</li>
                    
                    
                    
                </div>

            </div>
        </details>

        <!-- ============================================== -->
        <!-- SECTION 2: SAMPLING & RANDOMIZATION -->
        <!-- ============================================== -->
        <details class="section">
            <summary>2. Sampling & Randomization</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">Compute Random Subset</span>
                    <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Arrays/random_subset.html'; document.querySelector('.retro-viewport').classList.add('active');">
                        <svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                    </button>
                    <p>To select ùê§ unique numbers from a massive range ùêß without creating a huge array, use a HashMap to simulate a partial Fisher-Yates shuffle.</p>
                    
                    <p>It is called "virtual" because you never actually build this list. You just assume it exists. The process works like this:</p>
                    
                        <li><strong>The Randomizer:</strong> Generates a random index (e.g., 5).</li>
                        <li><strong>The Virtual Array:</strong> Tells you "Index 5 contains the number 5" (unless the Map says otherwise).</li>
                        <li><strong>The Limit:</strong> Defines how much of the array is still "in play" (the pool of available numbers).</li>
                    
                    <p>So, the virtual array is the data source (initially ordered 0 to N), and the randomizer is just the tool used to grab an index from it.</p>
                
                    <p><strong>Solution:</strong> Imagine a virtual array with fixed points (Value = Index). When you randomly pick an index (e.g., 10), you extract that value. To ensure 10 is never picked again without forcing you to repeatedly generate new random numbers until you find an unused one, you fill the hole immediately. You take the value from the very last available spot in the range (the limit) and move it to Index 10.</p>
                    <p>The HashMap records this swap: <code>Map[10] = ValueAtLimit</code>.</p>
                    <p>If you randomly roll Index 10 again later, the map intercepts and provides the moved value instead. After each pick, you shrink the range size by one. This guarantees that every single random generation lands on a valid, unpicked number, making the process highly efficient.</p>
                </div>

                <div class="subsection">
                    <span class="subsection-title">Sample Online Data (Reservoir Sampling)</span>
                    <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Arrays/Fisher_Yates.html'; document.querySelector('.retro-viewport').classList.add('active');">
                        <svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                    </button>
                    <p><strong>Consider a reservoir array with k slots.</strong> As the input stream (of size n) grows, retention becomes stricter.</p>
                    <ul>
                        <li><strong>The Logic:</strong> For the n-th element, generate a random integer between 1 and n. If the value is ‚â§ k, the element is stored. (Chance = k/n)</li>
                        <li><strong>The Overwrite:</strong> If stored, it replaces an element at a random index to maintain capacity k.</li>
                        <li>Early elements fill the buffer easily but face high overwrite risk. Late elements enter rarely but are rarely replaced. These opposing forces balance out perfectly to give each element a k/n probability of being in the final sample.</li>
                    </ul>
                </div>

                <div class="subsection">
                    <span class="subsection-title">Sample Offline Data (Fisher-Yates)</span>
                    <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Arrays/random_sample_no_replace.html'; document.querySelector('.retro-viewport').classList.add('active');">
                        <svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                    </button>
                    <p><strong>Logic:</strong> Partition the array into "Selected" (Left) and "Unprocessed" (Right).</p>
                    <ol>
                        <li>Initialize pointer at index 0.</li>
                        <li>Generate a random index between the pointer and the end.</li>
                        <li>Swap the element at the random index with the element at the pointer.</li>
                        <li>Increment pointer. Repeat k times.</li>
                    </ol>
                    <p><strong>Use Case:</strong> Defense Ammunition Lot Acceptance (Testing without destroying inventory).</p>
                </div>

            </div>
        </details>

        <!-- ============================================== -->
        <!-- SECTION 3: PERMUTATIONS & ORDERING -->
        <!-- ============================================== -->
        <details class="section">
            <summary>3. Permutations & Ordering</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">Next Permutation</span>
                    <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Arrays/next_permutation.html'; document.querySelector('.retro-viewport').classList.add('active');">
                        <svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                    </button>
                    <p>Rearrange digits to form the <strong>smallest number that is larger</strong> than the current one (lexicographically larger).</p>
                    
                        <li><strong>Suffix:</strong> The tail end of the list.</li>
                        <li><strong>Inversion Point:</strong> The first number (scanning right-to-left) smaller than its right neighbor.</li>
                    
                    <ol>
                        <li><strong>Locate the Inversion Point:</strong> Scan the list from right to left. Stop at the first number smaller than the one to its right. (If no such number exists, the list is at its maximum; reverse it to reset to the minimum).</li>
                        <li><strong>Identify the Successor:</strong> Within the Suffix, find the smallest number that is strictly larger than the Inversion Point.</li>
                        <li><strong>Swap:</strong> Exchange the Inversion Point with the Successor.</li>
                        <li><strong>Minimize the Suffix:</strong> Reverse the Suffix. Since the tail was descending, reversing it creates an ascending sequence. This ensures the new permutation is the smallest possible increment over the previous one.</li>
                    </ol>
                    <p><em>Use Case:</em> Cryptographic auditing (Brute-force key generation).</p>
                </div>

                <div class="subsection">
                    <span class="subsection-title">In-Place Permutations</span>
                    <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Arrays/permutations_array.html'; document.querySelector('.retro-viewport').classList.add('active');">
                        <svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                    </button>
                    <p>Shuffle a list of items (A) according to specific instructions (P) without using an in-memory buffer.</p>
                    <p><strong>Cyclic Permutation:</strong> A chain of moves that loops back to the start (e.g., Position 0 &rarr; 2 &rarr; 1 &rarr; 0). All permutations are made of these disjoint cycles.</p>
                    <p><strong>In-Place:</strong> Modifying the input structure directly without using significant extra memory (O(1) space).</p>
                    <p><strong>Anchor (i):</strong> The main loop index moves sequentially (0, 1, 2‚Ä¶) through the list. It acts as a "holding buffer" for displaced items to ensure every position is processed. We cycle elements through <em>i</em> until the specific cycle closes.</p>
                    <p><strong>Cycle Pointer (next):</strong> A variable that jumps non-sequentially around the array. It follows the chain of instructions, tracing the specific path of a loop until it returns to the start.</p>
                    <p><strong>Sentinel:</strong> Use a sentinel to mark visited spots by subtracting the array length from the index value. Since array indices are non-negative, this allows state tracking without extra storage.</p>
                </div>

                <div class="subsection">
                    <span class="subsection-title">
                        Alternations (Wiggle Sort)
                        <button class="eye-btn" onclick="const v = document.querySelector('.retro-viewport'); v.querySelector('iframe').src = 'Arrays/wiggle_sort.html'; v.classList.add('active');">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </span>
                    <p><strong>The Purpose:</strong> Breaking down optimization problems into smaller subproblems and optimizing them alternately.</p>
                    <p><strong>The Pattern:</strong></p>
                    
                        <li>The 1st number should be smaller than (or equal to) the 2nd.</li>
                        <li>The 2nd number should be bigger than (or equal to) the 3rd.</li>
                        <li>The 3rd number should be smaller than (or equal to) the 4th.</li>
                    
                    <p><strong>Vocabulary:</strong></p>
                    <p><strong>State:</strong> The list A is a mutable object. Its state changes every time the loop runs.</p>
                    <p><strong>Local Optimality:</strong> The algorithm doesn't "look ahead." It looks only at the current pair (i and i+1). It assumes that fixing the current pair won't break the previous pair in a way that matters.</p>
                    
                </div>

            </div>
        </details>

        <!-- ============================================== -->
        <!-- SECTION 4: OPTIMIZATION & DP -->
        <!-- ============================================== -->
        <details class="section">
            <summary>4. Optimization & DP</summary>
            <div class="section-content">
                
                <div class="subsection">
                    <span class="subsection-title">Bidirectional Dynamic Programming</span>
                    <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Arrays/bidirectional_DP.html'; document.querySelector('.retro-viewport').classList.add('active');">
                        <svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                    </button>
                    <p>Optimizing two sequential, non-overlapping events (e.g., Stock Trading).</p>
                    
                    
                        <li><strong>Forward Pass:</strong> Scan left-to-right to calculate the best possible result for the first event ending by each specific split point possible.</li>
                        <li><strong>Backward Pass:</strong> Scan right-to-left to calculate the best result for the second event starting from each specific split point possible, to the right endpoint of the array.</li>
                        <li><strong>Combine:</strong> Sum the two values at every index. By comparing every possible split, you identify the exact moment where the total of the past maximum and future maximum is highest.</li>
                    
                
                </div>

                <div class="subsection">
                    <span class="subsection-title">Maximum Difference</span>
                    <button class="eye-btn" onclick="document.querySelector('.retro-viewport iframe').src='Arrays/max_diff.html'; document.querySelector('.retro-viewport').classList.add('active');">
                        <svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                    </button>
                    <p>The Maximum Difference problem finds the largest value of <code>A[j] - A[i]</code> in an array, where <code>j</code> must come after <code>i</code> (<code>j > i</code>). It's about finding the biggest rise from an earlier element to a later one.</p>
                    <p><strong>Process:</strong> Single-pass greedy traversal. Track <code>min_seen</code> and <code>max_diff</code>. Update <code>min_seen</code> if current value is lower; update <code>max_diff</code> if (current - min_seen) is a new record.</p>
                </div>

                <div class="subsection">
                    <span class="subsection-title">In-Place Deduplication</span>
                    <button class="eye-btn" onclick="const v=document.querySelector('.retro-viewport'); v.querySelector('iframe').src='Arrays/deduplication.html'; v.classList.add('active');">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                    </button>
                    <p><strong>Core idea:</strong> Remove duplicates from a <strong>sorted</strong> array <strong>in place</strong>, keeping only the first occurrence of each value. Uses two pointers and no extra space.</p>
                    <p><strong>Pointers:</strong></p>
                    
                        <li>Reader (<code>i</code>): scans the array looking for new values</li>
                        <li>Writer (<code>write_index</code>): marks the end of the "unique prefix" we're building</li>
                    
                    <p><strong>Steps:</strong></p>
                    <ol>
                        <li>Assume the array is already sorted (duplicates are next to each other).</li>
                        <li>Start with <code>write_index = 1</code> (index 0 is always kept as unique).</li>
                        <li>Loop the reader <code>i</code> from 1 to end of array:
                            
                                <li>If <code>A[i]</code> is different from <code>A[write_index - 1]</code>, it's a new value ‚Üí copy <code>A[i]</code> to <code>A[write_index]</code> and increment <code>write_index</code></li>
                                <li>Otherwise, skip (it's a duplicate)</li>
                            
                        </li>
                        <li>At the end, <code>write_index</code> is the new length of the array with uniques only.</li>
                    </ol>
                  
                    
                </div>

                <div class="subsection">
                    <span class="subsection-title">Enumerate Primes (Sieve)</span>
                    <p>Instead of asking "Is X prime?" for every number (Brute Force), we assume all numbers are prime and progressively eliminate non-primes.</p>
                    <p>Start assuming all numbers are prime. Iterate from 2. If a number is unmarked, it has no smaller factors‚Äîit is prime. Keep it. Then, strike out all its multiples. These are composites "built" by that prime and cannot be fundamental. By systematically eliminating every constructed product, only the indivisible building blocks remain.</p>
                </div>
                    
                    <h3>WHY THIS IS FASTER THAN BRUTE FORCING</h3>
                    <p><strong>The Operation: Division vs. Jumping</strong></p>
                
                    <p><strong>Method A: Trial Division (Brute Force)</strong></p>
                    <p>To check if the number <strong>97</strong> is prime, you have to ask:</p>
                    <ul>
                        <li>Is <strong>97%2==0</strong> ? (Division operation)</li>
                        <li>Is <strong>97%3==0</strong> ? (Division operation)</li>
                        <li>Is <strong>97%4==0</strong> ? ...</li>
                        <li>... all the way up to <strong>‚àö97</strong>.</li>
                    </ul>
                    <p>Computers find division (and modulus) relatively "expensive" (slow). You are doing this heavy math for every single number from 1 to <strong>N</strong>.</p>
                
                    <p><strong>Method B: Eratosthenes Sieve</strong></p>
                    <p>When we confirm <strong>2</strong> is prime, we avoid division entirely. Instead, we stride through the array indices (4, 6, 8...) using simple addition. At each step, we "mark" the index by setting a boolean flag in memory to <strong>False</strong>. This explicitly records the number as composite.</p>
                    <p><strong>Verdict:</strong> Simple addition and memory assignment are computationally cheaper for CPUs than modulo arithmetic.</p>
                </div>

            </div>
        </details>

        <!-- ============================================== -->
        <!-- SECTION 5: THEORY & IMPLEMENTATION -->
        <!-- ============================================== -->
        <details class="section">
            <summary>5. Theory & Implementation</summary>
            <div class="section-content">
                

                <div class="subsection">
                    <span class="subsection-title"> Lexicographic Comparisons</span>
                    <p><strong>Lexicographic:</strong> "Sudden Death" comparison.</p>
                    <ol>
                        <li>Line lists up side-by-side.</li>
                        <li>Compare pairs. If equal, continue.</li>
                        <li>If different, the list with the smaller item is strictly smaller. Comparison ends immediately.</li>
                    </ol>
                </div>

                <div class="subsection">
                    <span class="subsection-title">Array Theory</span>
                    <p><strong>Referential Array:</strong> Stores memory addresses (pointers). Allows variable-length objects in fixed slots.</p>
                    <p><strong>Compact Array:</strong> Stores bits/values directly in slots.</p>
                    <p><strong>Deep vs Shallow Copy:</strong> Shallow references existing objects (aliasing); Deep recursively clones everything.</p>
                </div>

            </div>
        </details>

    </div>
</div>

</body>
</html>