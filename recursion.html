<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Part IV: Recursion // Study Guide</title>
<style>
    /* 
       --- STYLE CONFIGURATION --- 
    */
    :root {
        --bg-color: #000000;
        --text-color: #00ff41;
        --accent-color: #00ff41;
        --dim-color: #003b00;
        --border-color: #00ff41;
        --font-main: 'Courier New', Courier, monospace;
        --font-header: 'Arial Black', Impact, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: var(--font-main);
        line-height: 1.5;
        overflow-x: hidden;
    }

    .dither-layer {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        z-index: -1;
        background-image: radial-gradient(circle, #003b00 1px, transparent 1px);
        background-size: 4px 4px;
        opacity: 0.4;
    }

    .scanlines {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(to bottom, rgba(0, 255, 65, 0), rgba(0, 255, 65, 0) 50%, rgba(0, 20, 0, 0.2) 50%, rgba(0, 20, 0, 0.2));
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 9999;
    }

    .container {
        max-width: 900px;
        width: 100%;
        margin: 0 auto;
        padding: 40px 20px;
        border-left: 2px dashed var(--dim-color);
        border-right: 2px dashed var(--dim-color);
        background-color: rgba(0, 10, 0, 0.9);
        min-height: 100vh;
    }

    h1 {
        font-family: var(--font-header);
        text-transform: uppercase;
        font-size: 2.5rem;
        border-bottom: 5px solid var(--accent-color);
        margin-bottom: 40px;
        color: var(--accent-color);
        text-align: center;
    }

    strong { color: var(--accent-color); text-decoration: underline; }
    em { font-style: normal; color: #50c878; border-bottom: 1px dotted var(--dim-color); }

    /* ACCORDION STYLES */
    details.section {
        margin-bottom: 15px;
        border: 1px solid var(--dim-color);
        background: #050505;
    }

    details.section > summary {
        font-family: var(--font-main);
        font-weight: bold;
        padding: 12px;
        background: #0a0a0a;
        color: var(--text-color);
        cursor: pointer;
        list-style: none;
        border-bottom: 1px solid transparent;
        text-transform: uppercase;
        font-size: 1.1rem;
    }

    details.section > summary:hover { background: var(--dim-color); color: var(--accent-color); }
    details.section[open] > summary {
        border-bottom: 1px solid var(--dim-color);
        background: #0f0f0f;
        color: var(--accent-color);
        text-shadow: 0px 0px 5px var(--accent-color);
    }

    .section-content { padding: 20px; }

    .subsection {
        margin-bottom: 25px;
        border-left: 4px solid var(--dim-color);
        padding-left: 15px;
    }

    .subsection-title {
        background: var(--dim-color);
        color: var(--accent-color);
        padding: 2px 6px;
        font-weight: bold;
        text-transform: uppercase;
        display: inline-block;
        margin-bottom: 10px;
        font-size: 0.9rem;
    }

    p { margin-bottom: 12px; margin-top: 0; text-align: justify; }
    ul { padding-left: 20px; margin-bottom: 15px; }
    li { margin-bottom: 5px; }

    .code-block {
        background: #020a02;
        border: 1px dashed var(--dim-color);
        padding: 10px;
        margin: 10px 0;
        font-family: 'Courier New', monospace;
        color: var(--accent-color);
        overflow-x: auto;
        white-space: pre-wrap;
    }
</style>
</head>
<body>

<div class="dither-layer"></div>
<div class="scanlines"></div>

<div class="container">
    <h1>Part IV: Recursion</h1>

    <div class="part-content">
        
        <details class="section">
            <summary>1. Recursive Philosophy</summary>
            <div class="section-content">
                <p>RECURSION: Recursion defines infinite possibilities through a single finite rule.</p>
                <p>It uses a self-referential function that includes a distinct stopping point and a process that shrinks the problem, ensuring it eventually solves itself.</p>
                
                <div class="subsection">
                    <div class="subsection-title">1. The Termination Condition (The Base Case)</div>
                    <p>This acts as the algorithm’s anchor, preventing infinite loops. It defines the simplest solvable state—like an empty list or single value—offering an immediate, undeniable answer that stops the chain of calls.</p>
                </div>
        
                <div class="subsection">
                    <div class="subsection-title">2. The Decomposition (The Recursive Step)</div>
                    <p>This reduces the problem's size to ensure progress. By isolating one element and calling the function on the remainder, you rely on the "inductive hypothesis": trusting the self-reference to correctly solve the strictly smaller sub-problem.</p>
                </div>
        
                <div class="subsection">
                    <div class="subsection-title">3. The Local Computation (The Atomic Unit)</div>
                    <p>This is the discrete work performed within the current step. It applies immediate logic—like a comparison or math operation—to the single element you isolated, handling the "now" independent of the future recursive results.</p>
                </div>
        
                <div class="subsection">
                    <div class="subsection-title">4. The Synthesis (The Aggregation)</div>
                    <p>As the process unwinds, this completes the inductive step. It combines the result returned by the solved sub-problem with your local computation, building the total solution layer by layer as the function returns.</p>
                </div>
            </div>
        </details>

        <details class="section">
            <summary>2. Backtracking</summary>
            <div class="section-content">
                <div class="subsection">
                    <div class="subsection-title">[RECURSIVE BACKTRACKING] GENERATE EVERY PERMUTATION FOR A GIVEN ARRAY</div>
                    <p>The goal is to take a list of unique numbers (an array of distinct integers) and produce every possible ordering (permutation) of those numbers. If the input has n numbers, you must find all n! (n-factorial) unique arrangements.</p>
                    <p>1 Recursive Backtracking (Optimal Solution A): A "divide and conquer" strategy where you fix the first number, then recursively permute the remaining numbers. This involves swapping elements to place them in the "fixed" position, recursing, and then swapping them back (backtracking) to restore the array to its previous state.</p>
                </div>
                
                <p><strong>THE HOW</strong></p>
                
                <p><strong>Step 1: Initialize the State</strong><br>
                Create a main list to store the final results and define a helper function accepting index i. Index i represents the specific position or "chair" you are currently filling. The function will try placing different available numbers into this slot, moving deeper into the array for each choice.</p>
        
                <p><strong>Step 2: Define the Base Case</strong><br>
                Check if index i points to the last element of the array. If reached, the current arrangement is a complete, valid permutation. Make an exact copy (snapshot) of the array in its current state and add it to your final results list before returning.</p>
        
                <p><strong>Step 3: Iterate Through Candidates (Branching)</strong><br>
                Start a loop using index j, running from the current position i to the end of the array. Here, i is the target slot we need to fill, and j points to every available candidate number in the remaining list that can be moved into that slot.</p>
        
                <p><strong>Step 4: Mutate State (The Swap)</strong><br>
                Inside the loop, swap the value at index i with the value at index j. This action tentatively "fixes" the chosen candidate into the current position i, establishing the starting number for this specific branch of the permutation tree.</p>
        
                <p><strong>Step 5: Recursive Descent (The Sub-problem)</strong><br>
                Call the helper function recursively with the index incremented to i + 1. This instructs the algorithm to keep the current position fixed and solve the sub-problem of arranging all remaining numbers that follow it.</p>
        
                <p><strong>Step 6: Backtrack (State Restoration)</strong><br>
                Immediately after the recursive call returns, swap the values at i and j back to their original positions. This "undo" action restores the array to its previous state, ensuring the next iteration of the loop starts with a clean slate to test the next candidate.</p>
            </div>
        </details>

        <details class="section">
            <summary>3. Dynamic Programming</summary>
            <div class="section-content">
                <!-- Placeholder -->
            </div>
        </details>

    </div>
</div>

</body>
</html>