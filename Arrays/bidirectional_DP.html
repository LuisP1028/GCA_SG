<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ALGO_VIS // STOCK_DP_V2_RESPONSIVE</title>
    <style>
        /* --- IMPORTS & VARS --- */
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --bg-color: #000000;
            --term-green: #00FF00;
            --term-dim: #003300;
            --term-dark: #001100;
            --scan-line: rgba(18, 16, 16, 0.5);
            
            /* Responsive Typography */
            --font-sm: clamp(12px, 1.5vh, 14px);
            --font-md: clamp(14px, 2vh, 18px);
            --font-lg: clamp(18px, 3vh, 24px);
            
            /* Spacing */
            --gap: clamp(5px, 1vh, 15px);
            --pad: clamp(10px, 2vw, 20px);
        }

        /* --- GLOBAL LAYOUT --- */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background-color: var(--bg-color);
            color: var(--term-green);
            font-family: 'VT323', monospace;
            overflow: hidden;
            user-select: none; /* Prevent text selection on touch */
        }

        #terminal-container {
            display: flex;
            flex-direction: column;
            height: 100dvh; /* Dynamic viewport height for mobile bars */
            width: 100vw;
            padding: var(--pad);
            box-sizing: border-box;
            position: relative;
            z-index: 1;
            gap: var(--gap);
        }

        /* --- CRT EFFECTS --- */
        .crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                radial-gradient(circle at center, transparent 60%, black 100%);
            background-size: 100% 4px, 100% 100%;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
        }

        @keyframes flicker {
            0% { opacity: 0.97; }
            50% { opacity: 0.95; }
            100% { opacity: 0.98; }
        }

        #terminal-container {
            animation: flicker 0.15s infinite;
        }

        /* --- UI ELEMENTS --- */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--term-green);
            padding-bottom: 5px;
            text-shadow: 0 0 5px var(--term-green);
            text-transform: uppercase;
            font-size: var(--font-md);
            flex-shrink: 0;
        }

        #system-log {
            color: var(--term-green);
            background: var(--term-dark);
            padding: 5px 10px;
            font-size: var(--font-sm);
            border-left: 4px solid var(--term-green);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 0;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--font-lg);
            flex-shrink: 0;
            flex-wrap: wrap; /* Wrap on tiny screens */
            gap: 10px;
        }

        /* --- CANVAS PANELS --- */
        .panel {
            flex: 1; /* Grow to fill space */
            display: flex;
            flex-direction: column;
            border: 1px solid var(--term-dim);
            background: var(--term-dark);
            box-shadow: 0 0 10px var(--term-dim);
            min-height: 0; /* Important for nested flex scroll/resize */
            overflow: hidden;
        }

        .panel-label {
            background: var(--bg-color);
            color: var(--term-green);
            padding: 2px 5px;
            font-size: var(--font-sm);
            border-bottom: 1px solid var(--term-dim);
            flex-shrink: 0;
            opacity: 0.9;
        }

        .canvas-wrapper {
            flex: 1;
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- UTILS --- */
        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }

        /* Mobile Adjustments */
        @media (max-width: 600px) {
            header span:nth-child(2) { display: none; } /* Hide OS name on mobile */
        }
    </style>
</head>
<body>

    <div class="crt-overlay"></div>

    <div id="terminal-container">
        <header>
            <span>PROTOCOL: MAX_PROFIT_2_TRANS</span>
            <span>OS: DITHER_OS v1.1-R</span>
            <span id="clock">00:00:00</span>
        </header>

        <div id="system-log">SYSTEM_LOG: INITIALIZING...</div>

        <!-- PANEL A -->
        <div class="panel">
            <div class="panel-label">A: MARKET_DATA // PRICE[t]</div>
            <div class="canvas-wrapper">
                <canvas id="canvasA"></canvas>
            </div>
        </div>

        <!-- PANEL B -->
        <div class="panel">
            <div class="panel-label">B: DUAL_SWEEP // L_OPT vs R_OPT</div>
            <div class="canvas-wrapper">
                <canvas id="canvasB"></canvas>
            </div>
        </div>

        <!-- PANEL C -->
        <div class="panel">
            <div class="panel-label">C: TOTAL_YIELD // MAX(L+R)</div>
            <div class="canvas-wrapper">
                <canvas id="canvasC"></canvas>
            </div>
        </div>

        <div class="status-bar">
            <span id="readout-left">L: $00</span>
            <span id="readout-right">R: $00</span>
            <span id="readout-total" style="font-weight:bold; text-shadow: 0 0 8px var(--term-green);">TOT: $00</span>
        </div>
    </div>

    <script>
        /**
         * ------------------------------------------------------------------
         * CONFIGURATION & DATA
         * ------------------------------------------------------------------
         */
        const COLORS = {
            bright: '#00FF00',
            dim: '#004400',
            dark: '#002200',
            bg: '#000000',
            alert: '#AAFF00'
        };

        const prices = [10, 22, 5, 75, 65, 80, 2, 12, 5, 20, 100, 80, 40, 60, 10, 50, 90, 85, 105, 10, 30];
        const n = prices.length;

        // DP State
        let leftProfit = new Array(n).fill(0);
        let rightProfit = new Array(n).fill(0);
        let totalProfit = new Array(n).fill(0);
        let dpr = 1; // Device Pixel Ratio

        // Precompute Algorithm
        function calculateDP() {
            let minPrice = prices[0];
            for (let i = 1; i < n; i++) {
                minPrice = Math.min(minPrice, prices[i]);
                leftProfit[i] = Math.max(leftProfit[i - 1], prices[i] - minPrice);
            }

            let maxPrice = prices[n - 1];
            for (let i = n - 2; i >= 0; i--) {
                maxPrice = Math.max(maxPrice, prices[i]);
                rightProfit[i] = Math.max(rightProfit[i + 1], maxPrice - prices[i]);
            }

            let maxTotal = 0;
            let maxIndex = 0;
            for (let i = 0; i < n; i++) {
                totalProfit[i] = leftProfit[i] + rightProfit[i];
                if (totalProfit[i] > maxTotal) {
                    maxTotal = totalProfit[i];
                    maxIndex = i;
                }
            }
            return { maxTotal, maxIndex };
        }

        const globalOptimum = calculateDP();

        // App State
        const STATE = {
            PHASE: 0, 
            SCANNER_INDEX: 0,
            FWD_PROGRESS: 0,
            BWD_PROGRESS: n - 1,
            SWEEP_PROGRESS: 0,
            GLOBAL_MAX_IDX: globalOptimum.maxIndex
        };

        // DOM Refs
        const cvsA = document.getElementById('canvasA');
        const ctxA = cvsA.getContext('2d');
        const cvsB = document.getElementById('canvasB');
        const ctxB = cvsB.getContext('2d');
        const cvsC = document.getElementById('canvasC');
        const ctxC = cvsC.getContext('2d');

        const elLog = document.getElementById('system-log');
        const elLeft = document.getElementById('readout-left');
        const elRight = document.getElementById('readout-right');
        const elTotal = document.getElementById('readout-total');

        /**
         * ------------------------------------------------------------------
         * RESPONSIVE CANVAS HANDLING
         * ------------------------------------------------------------------
         */
        
        function resizeCanvas(canvas) {
            // Get size of the wrapper div
            const parent = canvas.parentElement;
            const rect = parent.getBoundingClientRect();
            dpr = window.devicePixelRatio || 1;

            // Set display size (css pixels)
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;

            // Set actual memory size (scaled for retina)
            canvas.width = Math.floor(rect.width * dpr);
            canvas.height = Math.floor(rect.height * dpr);
        }

        function resizeAll() {
            resizeCanvas(cvsA);
            resizeCanvas(cvsB);
            resizeCanvas(cvsC);
            // Force redraw on resize
            if(STATE.PHASE === 4) {
                renderFrame();
            }
        }

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resizeAll, 100);
        });
        
        // Initial setup
        resizeAll();

        /**
         * ------------------------------------------------------------------
         * DRAWING HELPERS (SCALED)
         * ------------------------------------------------------------------
         */

        // Coordinate Mapping
        function getX(index, width) {
            const padding = 20 * dpr;
            const effectiveWidth = width - (padding * 2);
            return (index / (n - 1)) * effectiveWidth + padding;
        }

        function getY(value, height, maxVal) {
            const padding = 10 * dpr;
            const effectiveHeight = height - (padding * 2);
            const norm = value / (maxVal * 1.1); 
            return height - (norm * effectiveHeight) - padding;
        }

        function createHatchPattern(ctx) {
            const size = 4 * dpr;
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = size;
            patternCanvas.height = size;
            const pCtx = patternCanvas.getContext('2d');
            
            pCtx.fillStyle = COLORS.dim;
            pCtx.fillRect(0,0,size,size);
            pCtx.fillStyle = COLORS.bright;
            // Scale pixel drawing
            pCtx.fillRect(0, 0, dpr, dpr);
            pCtx.fillRect(size/2, size/2, dpr, dpr);
            return ctx.createPattern(patternCanvas, 'repeat');
        }

        function getTradeDetails(k) {
            // Re-simulate to find indices for visual dots
            let t1_buy = -1, t1_sell = -1, bestProf = 0;
            let curMin = prices[0], curMinIdx = 0;
            for(let i=0; i<=k; i++) {
                if(prices[i] < curMin) { curMin = prices[i]; curMinIdx = i; }
                if(prices[i] - curMin > bestProf) {
                    bestProf = prices[i] - curMin;
                    t1_buy = curMinIdx;
                    t1_sell = i;
                }
            }
            if(t1_buy === -1 && k > 0) { t1_buy=0; t1_sell=0; }

            let t2_buy = -1, t2_sell = -1;
            // Simple approach for suffix: find first pair matching rightProfit
            let minSuffix = prices[k], minSuffixIdx = k;
            for(let i=k; i<n; i++) {
                if(prices[i] < minSuffix) { minSuffix = prices[i]; minSuffixIdx = i; }
                if(prices[i] - minSuffix === rightProfit[k]) {
                     t2_buy = minSuffixIdx;
                     t2_sell = i;
                     break;
                }
            }
            if (rightProfit[k] === 0) { t2_buy = k; t2_sell = k; }
            return { t1_buy, t1_sell, t2_buy, t2_sell };
        }

        /**
         * ------------------------------------------------------------------
         * DRAWING ROUTINES
         * ------------------------------------------------------------------
         */

        function drawGrid(ctx, w, h) {
            ctx.strokeStyle = COLORS.dim;
            ctx.lineWidth = 1 * dpr;
            ctx.setLineDash([2 * dpr, 4 * dpr]);
            
            for(let i=1; i<5; i++) {
                let y = (h / 5) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }
            ctx.setLineDash([]);
        }

        function drawPanelA(scannerIdx) {
            const w = cvsA.width;
            const h = cvsA.height;
            const maxVal = Math.max(...prices);
            
            ctxA.clearRect(0, 0, w, h);
            drawGrid(ctxA, w, h);

            // Past
            ctxA.beginPath();
            ctxA.strokeStyle = COLORS.bright;
            ctxA.lineWidth = 2 * dpr;
            ctxA.moveTo(getX(0, w), getY(prices[0], h, maxVal));
            for (let i = 0; i <= scannerIdx; i++) {
                ctxA.lineTo(getX(i, w), getY(prices[i], h, maxVal));
            }
            ctxA.stroke();

            // Fill Past
            ctxA.lineTo(getX(scannerIdx, w), h);
            ctxA.lineTo(getX(0, w), h);
            ctxA.fillStyle = 'rgba(0, 255, 0, 0.1)';
            ctxA.fill();

            // Future
            if (scannerIdx < n - 1) {
                ctxA.beginPath();
                ctxA.strokeStyle = COLORS.dim;
                ctxA.setLineDash([2 * dpr, 2 * dpr]);
                ctxA.moveTo(getX(scannerIdx, w), getY(prices[scannerIdx], h, maxVal));
                for (let i = scannerIdx + 1; i < n; i++) {
                    ctxA.lineTo(getX(i, w), getY(prices[i], h, maxVal));
                }
                ctxA.stroke();
                ctxA.setLineDash([]);
                
                // Pattern Fill
                ctxA.lineTo(getX(n-1, w), h);
                ctxA.lineTo(getX(scannerIdx, w), h);
                ctxA.fillStyle = createHatchPattern(ctxA);
                ctxA.fill();
            }

            // Scanner Line
            const scanX = getX(scannerIdx, w);
            ctxA.beginPath();
            ctxA.strokeStyle = COLORS.bright;
            ctxA.lineWidth = 1 * dpr;
            ctxA.setLineDash([4 * dpr, 4 * dpr]);
            ctxA.moveTo(scanX, 0);
            ctxA.lineTo(scanX, h);
            ctxA.stroke();
            ctxA.setLineDash([]);

            // Interactive Dots
            if (STATE.PHASE === 4) {
                const trades = getTradeDetails(scannerIdx);
                const drawDot = (idx, type) => {
                    const xx = getX(idx, w);
                    const yy = getY(prices[idx], h, maxVal);
                    ctxA.fillStyle = type === 'buy' ? '#000' : COLORS.alert;
                    ctxA.strokeStyle = COLORS.alert;
                    ctxA.lineWidth = 1 * dpr;
                    ctxA.beginPath();
                    ctxA.arc(xx, yy, 4 * dpr, 0, Math.PI*2);
                    ctxA.fill();
                    ctxA.stroke();
                    
                    ctxA.fillStyle = COLORS.alert;
                    ctxA.font = `${12 * dpr}px VT323`;
                    ctxA.fillText(type.toUpperCase(), xx - (10 * dpr), yy - (10 * dpr));
                };

                if (prices[trades.t1_sell] > prices[trades.t1_buy]) {
                    drawDot(trades.t1_buy, 'buy');
                    drawDot(trades.t1_sell, 'sell');
                }
                if (prices[trades.t2_sell] > prices[trades.t2_buy]) {
                    drawDot(trades.t2_buy, 'buy');
                    drawDot(trades.t2_sell, 'sell');
                }
            }
        }

        function drawPanelB(scannerIdx, drawMaxL, drawMaxR) {
            const w = cvsB.width;
            const h = cvsB.height;
            const maxVal = Math.max(...totalProfit);
            
            ctxB.clearRect(0, 0, w, h);
            drawGrid(ctxB, w, h);

            // Left Profit
            if (drawMaxL > -1) {
                ctxB.beginPath();
                ctxB.strokeStyle = COLORS.bright;
                ctxB.lineWidth = 2 * dpr;
                ctxB.moveTo(getX(0, w), getY(leftProfit[0], h, maxVal));
                let limit = Math.min(drawMaxL, n-1);
                for(let i=0; i<= limit; i++) {
                    ctxB.lineTo(getX(i, w), getY(leftProfit[i], h, maxVal));
                }
                ctxB.stroke();
            }

            // Right Profit
            if (drawMaxR < n) {
                ctxB.beginPath();
                ctxB.strokeStyle = COLORS.dim;
                ctxB.lineWidth = 2 * dpr;
                ctxB.moveTo(getX(n-1, w), getY(rightProfit[n-1], h, maxVal));
                let limit = Math.max(drawMaxR, 0);
                for(let i=n-2; i>= limit; i--) {
                    ctxB.lineTo(getX(i, w), getY(rightProfit[i], h, maxVal));
                }
                ctxB.stroke();
            }

            if (STATE.PHASE >= 3) {
                const x = getX(scannerIdx, w);
                const size = 6 * dpr;
                
                let yL = getY(leftProfit[scannerIdx], h, maxVal);
                ctxB.fillStyle = COLORS.bright;
                ctxB.fillRect(x - size/2, yL - size/2, size, size);

                let yR = getY(rightProfit[scannerIdx], h, maxVal);
                ctxB.fillStyle = COLORS.dim;
                ctxB.fillRect(x - size/2, yR - size/2, size, size);
                
                ctxB.beginPath();
                ctxB.strokeStyle = 'rgba(0, 255, 0, 0.3)';
                ctxB.lineWidth = 1 * dpr;
                ctxB.moveTo(x, 0);
                ctxB.lineTo(x, h);
                ctxB.stroke();
            }
        }

        function drawPanelC(scannerIdx, drawLimit) {
            const w = cvsC.width;
            const h = cvsC.height;
            const maxVal = globalOptimum.maxTotal;

            ctxC.clearRect(0, 0, w, h);
            drawGrid(ctxC, w, h);

            if (drawLimit > -1) {
                ctxC.beginPath();
                ctxC.strokeStyle = COLORS.alert;
                ctxC.lineWidth = 3 * dpr;
                ctxC.shadowBlur = 10 * dpr;
                ctxC.shadowColor = COLORS.bright;
                
                ctxC.moveTo(getX(0, w), getY(totalProfit[0], h, maxVal));
                for(let i=0; i<= Math.min(drawLimit, n-1); i++) {
                    ctxC.lineTo(getX(i, w), getY(totalProfit[i], h, maxVal));
                }
                ctxC.stroke();
                ctxC.shadowBlur = 0;
            }

            // Target
            if (STATE.PHASE === 4 || (STATE.PHASE === 3 && scannerIdx === n-1)) {
                const bestX = getX(globalOptimum.maxIndex, w);
                const bestY = getY(globalOptimum.maxTotal, h, maxVal);
                const r = 10 * dpr;
                const rLine = 15 * dpr;

                ctxC.strokeStyle = COLORS.bright;
                ctxC.lineWidth = 1 * dpr;
                ctxC.beginPath();
                ctxC.arc(bestX, bestY, r, 0, Math.PI*2);
                ctxC.moveTo(bestX - rLine, bestY);
                ctxC.lineTo(bestX + rLine, bestY);
                ctxC.moveTo(bestX, bestY - rLine);
                ctxC.lineTo(bestX, bestY + rLine);
                ctxC.stroke();

                ctxC.fillStyle = COLORS.bright;
                ctxC.font = `${14 * dpr}px VT323`;
                ctxC.fillText("OPT_MAX", bestX + (12 * dpr), bestY - (12 * dpr));
            }
            
            if (STATE.PHASE >= 3) {
                const curX = getX(scannerIdx, w);
                const curY = getY(totalProfit[scannerIdx], h, maxVal);
                const size = 4 * dpr;
                
                ctxC.fillStyle = COLORS.alert;
                ctxC.fillRect(curX-(size/2), curY-(size/2), size, size);
                
                ctxC.beginPath();
                ctxC.strokeStyle = 'rgba(0, 255, 0, 0.3)';
                ctxC.lineWidth = 1 * dpr;
                ctxC.moveTo(curX, 0);
                ctxC.lineTo(curX, h);
                ctxC.stroke();
            }
        }

        /**
         * ------------------------------------------------------------------
         * LOGIC & ANIMATION
         * ------------------------------------------------------------------
         */

        let lastTime = 0;
        const SPEED_DRAW = 30;

        function updateUI(idx) {
            elLeft.innerText = `L: $${leftProfit[idx]}`;
            elRight.innerText = `R: $${rightProfit[idx]}`;
            elTotal.innerText = `TOT: $${totalProfit[idx]}`;
            const now = new Date();
            document.getElementById('clock').innerText = now.toLocaleTimeString();
        }

        function renderFrame() {
            // Helper to render current state based on phase vars
            // Used for resize events in interactive mode
             switch (STATE.PHASE) {
                case 1: 
                    drawPanelA(STATE.FWD_PROGRESS);
                    drawPanelB(STATE.FWD_PROGRESS, STATE.FWD_PROGRESS, n);
                    break;
                case 2:
                    drawPanelA(n-1);
                    drawPanelB(n, n, STATE.BWD_PROGRESS);
                    break;
                case 3:
                    drawPanelA(STATE.SWEEP_PROGRESS);
                    drawPanelB(STATE.SWEEP_PROGRESS, n, 0);
                    drawPanelC(STATE.SWEEP_PROGRESS, STATE.SWEEP_PROGRESS);
                    break;
                case 4:
                    drawPanelA(STATE.SCANNER_INDEX);
                    drawPanelB(STATE.SCANNER_INDEX, n, 0);
                    drawPanelC(STATE.SCANNER_INDEX, n);
                    break;
            }
        }

        function animate(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const delta = timestamp - lastTime;

            if (delta > SPEED_DRAW) {
                lastTime = timestamp;

                switch (STATE.PHASE) {
                    case 0: // Init
                        STATE.PHASE = 1;
                        elLog.innerText = "SYS: ANALYZING_PREFIX (DP_LEFT)...";
                        break;

                    case 1: // Forward
                        if (STATE.FWD_PROGRESS < n) {
                            STATE.FWD_PROGRESS++;
                            drawPanelA(STATE.FWD_PROGRESS);
                            drawPanelB(STATE.FWD_PROGRESS, STATE.FWD_PROGRESS, n);
                        } else {
                            STATE.PHASE = 2;
                            elLog.innerText = "SYS: ANALYZING_SUFFIX (DP_RIGHT)...";
                        }
                        break;

                    case 2: // Backward
                        if (STATE.BWD_PROGRESS >= 0) {
                            STATE.BWD_PROGRESS--;
                            drawPanelA(n-1);
                            drawPanelB(n, n, STATE.BWD_PROGRESS);
                        } else {
                            STATE.PHASE = 3;
                            elLog.innerText = "SYS: AGGREGATING YIELD...";
                            STATE.SWEEP_PROGRESS = 0;
                        }
                        break;

                    case 3: // Sweep
                        if (STATE.SWEEP_PROGRESS < n) {
                            let i = STATE.SWEEP_PROGRESS;
                            drawPanelA(i);
                            drawPanelB(i, n, 0);
                            drawPanelC(i, i);
                            updateUI(i);
                            STATE.SWEEP_PROGRESS++;
                        } else {
                            STATE.PHASE = 4;
                            elLog.innerText = "SYS: TARGET_LOCKED. [INTERACTIVE]";
                            elLog.classList.add('blink');
                            STATE.SCANNER_INDEX = globalOptimum.maxIndex;
                            updateUI(STATE.SCANNER_INDEX);
                            drawPanelA(STATE.SCANNER_INDEX);
                            drawPanelB(STATE.SCANNER_INDEX, n, 0);
                            drawPanelC(STATE.SCANNER_INDEX, n);
                        }
                        break;

                    case 4: // Interactive
                        updateUI(STATE.SCANNER_INDEX);
                        break;
                }
            }
            requestAnimationFrame(animate);
        }

        /**
         * ------------------------------------------------------------------
         * INPUT HANDLING (MOUSE & TOUCH)
         * ------------------------------------------------------------------
         */
        const container = document.getElementById('terminal-container');
        
        function handleInput(clientX) {
            if (STATE.PHASE !== 4) return;
            
            // Map X coordinate to index based on Canvas A rect
            const rect = cvsA.getBoundingClientRect();
            
            // Boundary checks
            if (clientX < rect.left || clientX > rect.right) return;

            const x = clientX - rect.left;
            const padding = 20; // CSS pixels padding estimation
            const w = rect.width - (padding * 2);
            
            let idx = Math.floor(((x - padding) / w) * (n - 1));
            
            // Clamp
            if (idx < 0) idx = 0;
            if (idx >= n) idx = n - 1;

            if (idx !== STATE.SCANNER_INDEX) {
                STATE.SCANNER_INDEX = idx;
                renderFrame();
            }
        }

        container.addEventListener('mousemove', (e) => handleInput(e.clientX));
        container.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                // Prevent scrolling while scrubbing
                e.preventDefault(); 
                handleInput(e.touches[0].clientX);
            }
        }, { passive: false });

        // Start
        requestAnimationFrame(animate);

    </script>
</body>
</html>