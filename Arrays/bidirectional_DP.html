<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DITHER_PUNK // ALGO_VIS</title>
    <style>
        /* --- CORE VARIABLES --- */
        :root {
            /* Default: PROFIT MODE (Green) */
            --bg-color: #050505;
            --primary: #00FF33;
            --secondary: #004411;
            --dim: #002205;
            --scanline: rgba(0, 20, 0, 0.5);
            
            --font-main: 'Courier New', Courier, monospace;
        }

        /* AMBER MODE (Cost Reduction) - Applied via body class */
        body.mode-cost {
            --primary: #FF5500;
            --secondary: #551100;
            --dim: #220500;
            --scanline: rgba(20, 5, 0, 0.5);
        }

        /* --- GLOBAL RESET & LAYOUT --- */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            color: var(--primary);
            font-family: var(--font-main);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
        }

        /* --- CRT OVERLAY EFFECTS --- */
        .crt-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 999;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
        }
        
        /* Slight flicker animation */
        @keyframes flicker {
            0% { opacity: 0.98; }
            5% { opacity: 0.95; }
            10% { opacity: 0.98; }
            100% { opacity: 0.98; }
        }
        #ui-layer {
            position: relative;
            z-index: 10;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
            animation: flicker 0.2s infinite;
        }

        /* --- UI COMPONENTS --- */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--primary);
            padding-bottom: 8px;
            margin-bottom: 10px;
            flex-shrink: 0;
        }

        h1 {
            font-size: clamp(16px, 2.5vh, 24px);
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px var(--primary);
        }

        select {
            background: var(--bg-color);
            color: var(--primary);
            border: 1px solid var(--primary);
            font-family: var(--font-main);
            font-size: 14px;
            padding: 4px;
            text-transform: uppercase;
            cursor: pointer;
            outline: none;
            box-shadow: 0 0 5px var(--secondary);
        }

        select:hover {
            background: var(--secondary);
        }

        /* --- PANEL GRID --- */
        .panel-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 0; /* Important for flex child scrolling */
        }

        .panel {
            flex: 1;
            border: 1px solid var(--secondary);
            background: rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            position: relative;
            min-height: 0;
        }

        .panel-header {
            background: var(--secondary);
            color: var(--bg-color);
            padding: 2px 5px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            display: flex;
            justify-content: space-between;
        }

        .canvas-wrapper {
            flex: 1;
            width: 100%;
            height: 100%;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- FOOTER STATUS --- */
        footer {
            margin-top: 10px;
            border-top: 2px solid var(--primary);
            padding-top: 8px;
            display: flex;
            justify-content: space-between;
            font-size: clamp(14px, 2vh, 18px);
            font-weight: bold;
            flex-shrink: 0;
            text-shadow: 0 0 4px var(--primary);
        }

        .blink { animation: blinker 1s step-end infinite; }
        @keyframes blinker { 50% { opacity: 0; } }

    </style>
</head>
<body>

    <div class="crt-overlay"></div>

    <div id="ui-layer">
        <header>
            <h1>// BI_DIRECT_DP_VIS_v1.0</h1>
            <select id="mode-select">
                <option value="PROFIT">PROTOCOL: MAX_PROFIT</option>
                <option value="COST">PROTOCOL: COST_REDUC</option>
            </select>
        </header>

        <div class="panel-container">
            <!-- PANEL A: INPUT -->
            <div class="panel">
                <div class="panel-header">
                    <span>A :: INPUT_SERIES</span>
                    <span id="lbl-scan">SCANNING...</span>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="cvsA"></canvas>
                </div>
            </div>

            <!-- PANEL B: DUAL SWEEP -->
            <div class="panel">
                <div class="panel-header">
                    <span>B :: DP_SWEEP [L / R]</span>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="cvsB"></canvas>
                </div>
            </div>

            <!-- PANEL C: AGGREGATE -->
            <div class="panel">
                <div class="panel-header">
                    <span>C :: SYNTHESIS [TOTAL]</span>
                    <span class="blink" id="lbl-status">CALCULATING</span>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="cvsC"></canvas>
                </div>
            </div>
        </div>

        <footer>
            <span>L: <span id="val-l">00</span></span>
            <span>R: <span id="val-r">00</span></span>
            <span>TOTAL: <span id="val-t">00</span></span>
        </footer>
    </div>

<script>
/**
 * ============================================================================
 * ENGINE: DITHER_PUNK_VISUALIZER
 * ============================================================================
 */

// --- CONFIG & STATE ---
const CONFIG = {
    dataCount: 40,
    speed: 1, // Frames per step
};

// Raw data generation (Deterministic pseudo-random)
function generateData() {
    let arr = [];
    let val = 50;
    for (let i = 0; i < CONFIG.dataCount; i++) {
        // Create jagged, realistic market movements
        let change = (Math.random() - 0.5) * 30;
        val += change;
        if (val < 5) val = 5;
        if (val > 100) val = 100;
        arr.push(Math.floor(val));
    }
    return arr;
}

// Current App State
let STATE = {
    mode: 'PROFIT', // 'PROFIT' or 'COST'
    phase: 0,       // 0:Idle, 1:LeftScan, 2:RightScan, 3:Combine, 4:Interactive
    progress: 0,    // Animation ticker
    cursor: -1,     // Mouse hover index
    data: generateData(),
    dpLeft: [],
    dpRight: [],
    dpTotal: [],
    maxIdx: 0,
    colors: {}      // Updated on resize/init
};

// --- DOM REFS ---
const els = {
    sel: document.getElementById('mode-select'),
    cvsA: document.getElementById('cvsA'),
    cvsB: document.getElementById('cvsB'),
    cvsC: document.getElementById('cvsC'),
    lblScan: document.getElementById('lbl-scan'),
    lblStatus: document.getElementById('lbl-status'),
    valL: document.getElementById('val-l'),
    valR: document.getElementById('val-r'),
    valT: document.getElementById('val-t'),
    body: document.body
};

const ctxs = {
    A: els.cvsA.getContext('2d'),
    B: els.cvsB.getContext('2d'),
    C: els.cvsC.getContext('2d'),
};

// --- ALGORITHMS ---

function runAlgorithms() {
    const n = STATE.data.length;
    STATE.dpLeft = new Array(n).fill(0);
    STATE.dpRight = new Array(n).fill(0);
    STATE.dpTotal = new Array(n).fill(0);

    if (STATE.mode === 'PROFIT') {
        // Max Profit: Buy Low, Sell High
        
        // 1. Left Pass (Min so far)
        let minPrice = STATE.data[0];
        for (let i = 1; i < n; i++) {
            minPrice = Math.min(minPrice, STATE.data[i]);
            STATE.dpLeft[i] = Math.max(STATE.dpLeft[i-1], STATE.data[i] - minPrice);
        }

        // 2. Right Pass (Max future)
        let maxPrice = STATE.data[n-1];
        for (let i = n-2; i >= 0; i--) {
            maxPrice = Math.max(maxPrice, STATE.data[i]);
            STATE.dpRight[i] = Math.max(STATE.dpRight[i+1], maxPrice - STATE.data[i]);
        }

    } else {
        // Cost Reduction: Start High, End Low
        // Think of it as "Shorting" or "Max Drop"
        
        // 1. Left Pass (Max so far -> Current)
        let maxPrice = STATE.data[0];
        for (let i = 1; i < n; i++) {
            maxPrice = Math.max(maxPrice, STATE.data[i]);
            STATE.dpLeft[i] = Math.max(STATE.dpLeft[i-1], maxPrice - STATE.data[i]);
        }

        // 2. Right Pass (Current -> Min future)
        let minPrice = STATE.data[n-1];
        for (let i = n-2; i >= 0; i--) {
            minPrice = Math.min(minPrice, STATE.data[i]);
            STATE.dpRight[i] = Math.max(STATE.dpRight[i+1], STATE.data[i] - minPrice);
        }
    }

    // Combine
    let globalMax = -1;
    STATE.maxIdx = 0;
    for(let i=0; i<n; i++){
        STATE.dpTotal[i] = STATE.dpLeft[i] + STATE.dpRight[i];
        if(STATE.dpTotal[i] > globalMax) {
            globalMax = STATE.dpTotal[i];
            STATE.maxIdx = i;
        }
    }
}

// --- GRAPHICS & UTILS ---

function getCSSVar(name) {
    return getComputedStyle(document.body).getPropertyValue(name).trim();
}

function updateColors() {
    STATE.colors = {
        primary: getCSSVar('--primary'),
        secondary: getCSSVar('--secondary'),
        dim: getCSSVar('--dim'),
        bg: getCSSVar('--bg-color')
    };
}

// Custom Dither Pattern Generator
function createDitherPattern(ctx) {
    // Create a 2x2 pattern
    const patCanvas = document.createElement('canvas');
    patCanvas.width = 4;
    patCanvas.height = 4;
    const pCtx = patCanvas.getContext('2d');
    
    pCtx.fillStyle = STATE.colors.dim;
    pCtx.fillRect(0,0,4,4);
    
    pCtx.fillStyle = STATE.colors.primary;
    // Checkerboard pixels
    pCtx.fillRect(0,0,1,1);
    pCtx.fillRect(2,2,1,1);
    
    return ctx.createPattern(patCanvas, 'repeat');
}

function resizeCanvas(canvas) {
    const parent = canvas.parentElement;
    const dpr = window.devicePixelRatio || 1;
    const rect = parent.getBoundingClientRect();
    
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    
    return { w: rect.width, h: rect.height };
}

// Coordinate Mappers
const getX = (i, w) => (i / (CONFIG.dataCount - 1)) * w;
// Normalized Y
const getY = (val, h, max) => h - ((val / (max * 1.2)) * (h - 20)) - 10; 

function drawGrid(ctx, w, h) {
    ctx.strokeStyle = STATE.colors.secondary;
    ctx.lineWidth = 1;
    ctx.beginPath();
    // Vertical lines
    for(let i=0; i<w; i+=40) {
        ctx.moveTo(i, 0); ctx.lineTo(i, h);
    }
    // Horizontal lines
    for(let i=0; i<h; i+=40) {
        ctx.moveTo(0, i); ctx.lineTo(w, i);
    }
    ctx.stroke();
}

// --- RENDERING PIPELINE ---

function render() {
    updateColors(); // Ensure colors match CSS if class changed
    
    const dimsA = resizeCanvas(els.cvsA);
    const dimsB = resizeCanvas(els.cvsB);
    const dimsC = resizeCanvas(els.cvsC);
    
    const maxVal = Math.max(...STATE.data);
    const maxDP = Math.max(...STATE.dpTotal); // Use total max for scaling DP charts

    // --- PANEL A: INPUT ---
    const ctxA = ctxs.A;
    ctxA.clearRect(0,0,dimsA.w, dimsA.h);
    drawGrid(ctxA, dimsA.w, dimsA.h);
    
    // Draw Main Line
    ctxA.beginPath();
    ctxA.strokeStyle = STATE.colors.primary;
    ctxA.lineWidth = 2;
    STATE.data.forEach((val, i) => {
        const x = getX(i, dimsA.w);
        const y = getY(val, dimsA.h, maxVal);
        if(i===0) ctxA.moveTo(x,y);
        else ctxA.lineTo(x,y);
    });
    ctxA.stroke();

    // Fill under line with dither
    ctxA.lineTo(dimsA.w, dimsA.h);
    ctxA.lineTo(0, dimsA.h);
    ctxA.fillStyle = createDitherPattern(ctxA);
    ctxA.globalAlpha = 0.5;
    ctxA.fill();
    ctxA.globalAlpha = 1.0;

    // Scanline / Cursor logic
    let activeIdx = -1;
    if(STATE.phase < 4) activeIdx = STATE.progress;
    if(STATE.phase === 4) activeIdx = STATE.cursor;

    // Draw Scanline
    if (activeIdx >= 0) {
        const x = getX(activeIdx, dimsA.w);
        ctxA.strokeStyle = STATE.colors.primary;
        ctxA.setLineDash([2, 4]);
        ctxA.beginPath();
        ctxA.moveTo(x, 0); ctxA.lineTo(x, dimsA.h);
        ctxA.stroke();
        ctxA.setLineDash([]);
        
        // Highlight point
        const y = getY(STATE.data[activeIdx], dimsA.h, maxVal);
        ctxA.fillStyle = STATE.colors.bg;
        ctxA.fillRect(x-4, y-4, 8, 8);
        ctxA.strokeRect(x-4, y-4, 8, 8);
    }

    // --- PANEL B: DP SWEEP ---
    const ctxB = ctxs.B;
    ctxB.clearRect(0,0,dimsB.w, dimsB.h);
    drawGrid(ctxB, dimsB.w, dimsB.h);

    // Left Scan (Solid)
    const drawCurve = (ctx, arr, limit, color, dir) => {
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        
        let start = (dir === 'fwd') ? 0 : arr.length-1;
        let end = limit;
        
        // Determine draw range based on phase
        if (dir === 'fwd') {
             // Draw from 0 to limit
             for(let i=0; i<= Math.min(limit, arr.length-1); i++) {
                 let x = getX(i, dimsB.w);
                 let y = getY(arr[i], dimsB.h, maxDP);
                 if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
             }
        } else {
            // Draw from end down to limit
            for(let i=arr.length-1; i>= Math.max(limit, 0); i--) {
                 let x = getX(i, dimsB.w);
                 let y = getY(arr[i], dimsB.h, maxDP);
                 if(i===arr.length-1) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
        }
        ctx.stroke();
    };

    // Logic for partial drawing based on phase
    let limL = -1, limR = CONFIG.dataCount;
    
    if (STATE.phase === 1) limL = STATE.progress;
    else if (STATE.phase > 1) limL = CONFIG.dataCount - 1;
    
    if (STATE.phase === 2) limR = STATE.progress;
    else if (STATE.phase > 2) limR = 0;

    if (limL > -1) drawCurve(ctxB, STATE.dpLeft, limL, STATE.colors.primary, 'fwd');
    if (limR < CONFIG.dataCount) drawCurve(ctxB, STATE.dpRight, limR, STATE.colors.secondary, 'bwd');
    
    // Cursor Intersect on Panel B
    if (STATE.phase === 4 && STATE.cursor >= 0) {
        const x = getX(STATE.cursor, dimsB.w);
        ctxB.strokeStyle = STATE.colors.primary;
        ctxB.setLineDash([2,2]);
        ctxB.beginPath(); ctxB.moveTo(x,0); ctxB.lineTo(x, dimsB.h); ctxB.stroke();
        
        // Dots
        let yL = getY(STATE.dpLeft[STATE.cursor], dimsB.h, maxDP);
        let yR = getY(STATE.dpRight[STATE.cursor], dimsB.h, maxDP);
        
        ctxB.fillStyle = STATE.colors.primary;
        ctxB.fillRect(x-2, yL-2, 4, 4);
        ctxB.fillStyle = STATE.colors.secondary; // Dimmer for Right
        ctxB.fillRect(x-2, yR-2, 4, 4);
    }


    // --- PANEL C: SYNTHESIS ---
    const ctxC = ctxs.C;
    ctxC.clearRect(0,0,dimsC.w, dimsC.h);
    drawGrid(ctxC, dimsC.w, dimsC.h);

    if (STATE.phase >= 3) {
        let limT = (STATE.phase === 3) ? STATE.progress : CONFIG.dataCount-1;
        
        ctxC.beginPath();
        ctxC.strokeStyle = STATE.colors.primary;
        ctxC.lineWidth = 3;
        
        for(let i=0; i<=limT; i++) {
            let x = getX(i, dimsC.w);
            let y = getY(STATE.dpTotal[i], dimsC.h, maxDP);
            if(i===0) ctxC.moveTo(x,y); else ctxC.lineTo(x,y);
        }
        ctxC.stroke();
        
        // Fill
        ctxC.lineTo(getX(limT, dimsC.w), dimsC.h);
        ctxC.lineTo(0, dimsC.h);
        ctxC.fillStyle = createDitherPattern(ctxC);
        ctxC.fill();

        // Target Global Max (in Phase 4 or if reached)
        if (STATE.phase === 4 || (STATE.phase === 3 && limT === CONFIG.dataCount-1)) {
            const xMax = getX(STATE.maxIdx, dimsC.w);
            const yMax = getY(STATE.dpTotal[STATE.maxIdx], dimsC.h, maxDP);
            
            // Draw Crosshair
            ctxC.strokeStyle = STATE.colors.primary;
            ctxC.lineWidth = 1;
            ctxC.setLineDash([]);
            ctxC.beginPath();
            ctxC.arc(xMax, yMax, 10, 0, Math.PI*2);
            ctxC.moveTo(xMax-15, yMax); ctxC.lineTo(xMax+15, yMax);
            ctxC.moveTo(xMax, yMax-15); ctxC.lineTo(xMax, yMax+15);
            ctxC.stroke();
            
            ctxC.font = '12px Courier New';
            ctxC.fillStyle = STATE.colors.primary;
            ctxC.fillText('OPT_MAX', xMax + 10, yMax - 10);
        }
    }
}

// --- CONTROLLER ---

function reset() {
    STATE.phase = 0;
    STATE.progress = 0;
    STATE.cursor = 0;
    els.lblStatus.innerText = "INITIALIZING...";
    els.lblStatus.classList.remove('blink');
    runAlgorithms();
    STATE.cursor = STATE.maxIdx; // Default cursor to max
    animate();
}

function updateFooter(idx) {
    els.valL.innerText = STATE.dpLeft[idx];
    els.valR.innerText = STATE.dpRight[idx];
    els.valT.innerText = STATE.dpTotal[idx];
}

let animFrame;
function animate() {
    // Animation Logic
    if (STATE.phase === 0) {
        STATE.phase = 1;
        els.lblStatus.innerText = ">> SCAN_LEFT [FWD]";
    } else if (STATE.phase === 1) {
        // Left Scan
        if (STATE.progress < CONFIG.dataCount - 1) {
            STATE.progress++;
            updateFooter(STATE.progress);
        } else {
            STATE.phase = 2;
            STATE.progress = CONFIG.dataCount - 1;
            els.lblStatus.innerText = "<< SCAN_RIGHT [BWD]";
        }
    } else if (STATE.phase === 2) {
        // Right Scan
        if (STATE.progress > 0) {
            STATE.progress--;
            updateFooter(STATE.progress);
        } else {
            STATE.phase = 3;
            STATE.progress = 0;
            els.lblStatus.innerText = ">> SYNTHESIZING...";
        }
    } else if (STATE.phase === 3) {
        // Total Scan
        if (STATE.progress < CONFIG.dataCount - 1) {
            STATE.progress++;
            updateFooter(STATE.progress);
        } else {
            STATE.phase = 4;
            STATE.cursor = STATE.maxIdx;
            els.lblStatus.innerText = "TARGET ACQUIRED. [INTERACTIVE]";
            els.lblStatus.classList.add('blink');
        }
    }
    
    render();
    
    if (STATE.phase < 4) {
        // Slow down animation loop slightly for retro feel
        setTimeout(() => {
            animFrame = requestAnimationFrame(animate);
        }, 20);
    }
}

// --- INTERACTION ---

els.sel.addEventListener('change', (e) => {
    STATE.mode = e.target.value;
    if (STATE.mode === 'COST') {
        els.body.classList.add('mode-cost');
    } else {
        els.body.classList.remove('mode-cost');
    }
    cancelAnimationFrame(animFrame);
    STATE.data = generateData(); // New random data on switch
    reset();
});

// Window Resize
window.addEventListener('resize', () => {
    render();
});

// Mouse / Touch Move
const handleInput = (clientX) => {
    if (STATE.phase !== 4) return;
    const rect = els.cvsA.getBoundingClientRect();
    const x = clientX - rect.left;
    const w = rect.width;
    
    let idx = Math.floor((x / w) * (CONFIG.dataCount - 1));
    idx = Math.max(0, Math.min(idx, CONFIG.dataCount - 1));
    
    if (idx !== STATE.cursor) {
        STATE.cursor = idx;
        updateFooter(idx);
        render();
    }
};

window.addEventListener('mousemove', e => handleInput(e.clientX));
window.addEventListener('touchmove', e => {
    e.preventDefault();
    handleInput(e.touches[0].clientX);
}, {passive: false});

// --- BOOT ---
reset();

</script>
</body>
</html>