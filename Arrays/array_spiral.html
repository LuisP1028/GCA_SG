<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DITHERPUNK SPIRAL</title>
    <style>
        :root {
            --bg-color: #050505;
            --fg-color: #00ff41;
            --dim-color: #003b0f;
            --alert-color: #ff003c;
            --cell-size: clamp(30px, 8vw, 60px);
            --gap: 4px;
        }

        /* --- DITHER PATTERN GENERATION --- */
        /* A CSS radial gradient pattern to simulate dither texture */
        .dither-bg {
            background-image: radial-gradient(var(--fg-color) 15%, transparent 16%),
                              radial-gradient(var(--fg-color) 15%, transparent 16%);
            background-size: 4px 4px;
            background-position: 0 0, 2px 2px;
            opacity: 0.3;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--fg-color);
            font-family: 'Courier New', Courier, monospace;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: grid;
            grid-template-rows: 60px 1fr;
            grid-template-columns: 1fr 250px;
            grid-template-areas: 
                "hud hud"
                "stage sidebar";
        }

        /* --- HUD (HEADS UP DISPLAY) --- */
        #hud {
            grid-area: hud;
            border-bottom: 2px solid var(--fg-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            background: var(--bg-color);
            z-index: 10;
        }

        .hud-group {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .status-box {
            border: 1px solid var(--fg-color);
            padding: 5px 10px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9rem;
            min-width: 200px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Compass Icon Animation */
        #compass-icon {
            display: inline-block;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-size: 1.5rem;
        }

        /* --- SIDEBAR (COLLECTION) --- */
        #sidebar {
            grid-area: sidebar;
            border-left: 2px solid var(--fg-color);
            padding: 10px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .sidebar-header {
            border-bottom: 1px dashed var(--fg-color);
            padding-bottom: 5px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .collected-item {
            font-size: 1.2rem;
            animation: slideIn 0.2s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* --- CENTER STAGE (MATRIX) --- */
        #stage {
            grid-area: stage;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #grid-container {
            display: grid;
            gap: var(--gap);
            padding: 20px;
            position: relative;
            /* Grid template cols/rows set via JS */
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 1px solid var(--fg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
            position: relative;
            transition: background-color 0.2s, color 0.2s;
        }

        /* Cell States */
        .cell.active {
            background-color: var(--fg-color);
            color: var(--bg-color);
            box-shadow: 0 0 15px var(--fg-color);
            z-index: 2;
        }

        .cell.processed {
            color: var(--dim-color);
            border-color: var(--dim-color);
            background-color: black;
        }
        
        /* The "Atkinson" dither overlay for processed cells */
        .cell.processed::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: radial-gradient(var(--dim-color) 20%, transparent 20%);
            background-size: 3px 3px;
            pointer-events: none;
        }

        .cell.warning {
            border-color: var(--alert-color);
            color: var(--alert-color);
            animation: shake 0.2s;
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px); }
            50% { transform: translate(-1px, -1px); }
            100% { transform: translate(1px, 1px); }
        }

        /* --- BOUNDARY BOX --- */
        #boundary-box {
            position: absolute;
            border: 2px dashed var(--fg-color);
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.25, 1, 0.5, 1);
            z-index: 5;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
        }

        /* --- SCANLINE EFFECT OVERLAY --- */
        #scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 999;
            opacity: 0.3;
        }
        
        /* Mobile adjustment */
        @media (max-width: 700px) {
            body {
                grid-template-columns: 1fr;
                grid-template-rows: 60px 1fr 150px;
                grid-template-areas: 
                    "hud"
                    "stage"
                    "sidebar";
            }
            #sidebar {
                border-left: none;
                border-top: 2px solid var(--fg-color);
                flex-direction: row;
                flex-wrap: wrap;
                align-content: flex-start;
            }
        }
    </style>
</head>
<body>

    <div id="scanlines"></div>

    <header id="hud">
        <div class="hud-group">
            <span style="font-weight:900;">>> SYSTEM_READY</span>
        </div>
        
        <div class="hud-group">
            <div class="status-box">
                <span id="compass-icon">↑</span>
                <span id="map-status">MAP: NORMAL</span>
            </div>
            <div class="status-box">
                BOUNDARY: [<span id="boundary-coords">0,0,0,0</span>]
            </div>
        </div>
    </header>

    <main id="stage">
        <div id="grid-container">
            <!-- Grid generated by JS -->
            <div id="boundary-box"></div>
        </div>
    </main>

    <aside id="sidebar">
        <div class="sidebar-header">COLLECTION QUEUE</div>
        <div id="collection-list"></div>
    </aside>

    <script>
        // --- CONFIGURATION ---
        const ROWS = 6;
        const COLS = 6;
        const SPEED = 200; // ms per step

        // --- STATE ---
        let matrix = [];
        let topRow = 0;
        let bottomRow = ROWS - 1;
        let leftCol = 0;
        let rightCol = COLS - 1;
        
        // --- DOM ELEMENTS ---
        const gridContainer = document.getElementById('grid-container');
        const boundaryBox = document.getElementById('boundary-box');
        const collectionList = document.getElementById('collection-list');
        const mapStatus = document.getElementById('map-status');
        const compassIcon = document.getElementById('compass-icon');
        const boundaryCoords = document.getElementById('boundary-coords');

        // --- INITIALIZATION ---
        function init() {
            // 1. Generate Data
            let counter = 1;
            for(let r=0; r<ROWS; r++) {
                let row = [];
                for(let c=0; c<COLS; c++) {
                    row.push(counter < 10 ? `0${counter}` : counter);
                    counter++;
                }
                matrix.push(row);
            }

            // 2. Render Grid
            gridContainer.style.gridTemplateColumns = `repeat(${COLS}, var(--cell-size))`;
            gridContainer.style.gridTemplateRows = `repeat(${ROWS}, var(--cell-size))`;

            matrix.forEach((row, rIndex) => {
                row.forEach((val, cIndex) => {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${rIndex}-${cIndex}`;
                    cell.innerText = val;
                    gridContainer.appendChild(cell);
                });
            });

            // 3. Initial Boundary Visuals
            updateBoundaryVisuals();
            
            // 4. Start Animation
            setTimeout(startSpiral, 1000);
        }

        // --- VISUALIZATION HELPERS ---
        const delay = (ms) => new Promise(res => setTimeout(res, ms));

        function updateHUD(text, rotation, icon) {
            mapStatus.innerText = `MAP: ${text}`;
            compassIcon.style.transform = `rotate(${rotation}deg)`;
            compassIcon.innerText = icon; // ↑ → ↓ ←
        }

        function updateBoundaryText() {
            boundaryCoords.innerText = `${topRow},${bottomRow},${leftCol},${rightCol}`;
        }

        function updateBoundaryVisuals() {
            // Calculates the position of the dashed green box based on indices
            // We use cell size + gap calculations
            // Get CSS variable values
            const styles = getComputedStyle(document.documentElement);
            const cellSize = parseInt(styles.getPropertyValue('--cell-size')) || 50; // fallback if calc fails in js
            // Actually better to get dimensions from a real cell
            const sampleCell = document.querySelector('.cell');
            if(!sampleCell) return;

            const width = sampleCell.offsetWidth;
            const gap = 4; // predefined gap in CSS

            // Calculate pixel positions relative to grid container
            // Top/Left is index * (size + gap)
            // Width/Height is (num_cells * size) + ((num_cells - 1) * gap)
            
            const x = leftCol * (width + gap);
            const y = topRow * (width + gap);
            
            const hItems = (rightCol - leftCol + 1);
            const vItems = (bottomRow - topRow + 1);

            const wPx = (hItems * width) + ((hItems - 1) * gap);
            const hPx = (vItems * width) + ((vItems - 1) * gap);

            // Apply to box
            boundaryBox.style.left = `${x}px`;
            boundaryBox.style.top = `${y}px`;
            boundaryBox.style.width = `${wPx}px`;
            boundaryBox.style.height = `${hPx}px`;

            updateBoundaryText();
        }

        function getCell(r, c) {
            return document.getElementById(`cell-${r}-${c}`);
        }

        async function processCell(r, c) {
            const cell = getCell(r, c);
            
            // Highlight Active
            cell.classList.add('active');
            
            // Wait
            await delay(SPEED);

            // Collect Data
            const val = matrix[r][c];
            const item = document.createElement('div');
            item.className = 'collected-item';
            item.innerText = `> ${val}`;
            collectionList.prepend(item); // Add to top of list

            // Mark Processed
            cell.classList.remove('active');
            cell.classList.add('processed');
        }

        // --- MAIN ALGORITHM ---
        async function startSpiral() {
            
            while (topRow <= bottomRow && leftCol <= rightCol) {
                
                // update boundary visuals at start of ring
                updateBoundaryVisuals();

                // --- PHASE 1: EAST (Top Row) ---
                updateHUD("NORMAL", 0, "↑"); // Map held normally
                
                for (let i = leftCol; i <= rightCol; i++) {
                    await processCell(topRow, i);
                }
                topRow++; // Shrink top boundary
                updateBoundaryVisuals(); // Animate shrink

                // --- PHASE 2: SOUTH (Right Column) ---
                if (leftCol <= rightCol) { // Check mainly for single col edge case
                    updateHUD("SIDEWAYS", 90, "→"); // Turn head right
                    
                    for (let i = topRow; i <= bottomRow; i++) {
                        await processCell(i, rightCol);
                    }
                    rightCol--;
                    updateBoundaryVisuals();
                }

                // --- PHASE 3: WEST (Bottom Row) ---
                if (topRow <= bottomRow) {
                    updateHUD("INVERTED", 180, "↓"); // Map upside down
                    
                    for (let i = rightCol; i >= leftCol; i--) {
                        await processCell(bottomRow, i);
                    }
                    bottomRow--;
                    updateBoundaryVisuals();
                }

                // --- PHASE 4: NORTH (Left Column) ---
                if (leftCol <= rightCol) {
                    updateHUD("VERTICAL", 270, "←"); // Turn head left (reading up)
                    
                    for (let i = bottomRow; i >= topRow; i--) {
                        await processCell(i, leftCol);
                    }
                    leftCol++;
                    updateBoundaryVisuals();
                }
            }

            // Completion
            boundaryBox.style.display = 'none';
            updateHUD("COMPLETE", 0, "✓");
            document.querySelector('.status-box').style.borderColor = "#fff";
        }

        // Handle Resize to fix boundary box alignment
        window.addEventListener('resize', updateBoundaryVisuals);

        // Run
        init();

    </script>
</body>
</html>