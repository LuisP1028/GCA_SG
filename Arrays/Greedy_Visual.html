<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JUMP_GAME_VISUALIZER // DITHERPUNK_RESPONSIVE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --term-green: #00FF00;
            --term-bg: #050a05;
            --term-dim: rgba(0, 255, 0, 0.1);
            --ui-border-color: var(--term-green);
            
            /* Responsive Font Sizes */
            --font-sm: clamp(10px, 1.5vmin, 14px);
            --font-md: clamp(12px, 2vmin, 18px);
            --font-lg: clamp(16px, 3vmin, 24px);
        }

        * {
            box-sizing: border-box;
            user-select: none; /* Prevent selection on mobile tap */
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: var(--term-green);
            font-family: 'VT323', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* CRT Scanline Effect Overlay - Full Screen */
        .scanlines {
            position: fixed;
            inset: 0;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 100;
        }

        /* 
           The Game Container matches the 16:9 internal resolution aspect ratio.
           It scales using vmin to fit ANY screen (mobile or desktop) completely visible.
        */
        #game-wrapper {
            position: relative;
            width: 95vmin; 
            aspect-ratio: 16/9;
            border: 2px solid var(--ui-border-color);
            box-shadow: 0 0 3vmin var(--term-dim);
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* Crisp pixel art scaling */
            image-rendering: -moz-crisp-edges;
            image-rendering: pixelated;
        }

        /* UI Overlays - positioned relatively within the game wrapper */
        .ui-box {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid var(--term-green);
            padding: 1vmin;
            text-transform: uppercase;
            box-shadow: 0.5vmin 0.5vmin 0px rgba(0, 255, 0, 0.3);
            font-size: var(--font-md);
            z-index: 50;
        }

        #stats-box {
            top: 4%;
            right: 4%;
            width: 25%;
            display: flex;
            flex-direction: column;
            gap: 0.5vmin;
        }

        #log-box {
            bottom: 4%;
            left: 4%;
            right: 4%;
            height: 20%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            border-top: 2px double var(--term-green);
            font-size: var(--font-sm);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
        }
        
        .stat-val {
            color: #EEFFEE;
            text-shadow: 0 0 5px #EEFFEE;
            font-weight: bold;
        }

        .log-entry {
            opacity: 0.7;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .log-entry.new {
            color: #fff;
            opacity: 1;
        }
        
        /* Danger Mode Animation */
        @keyframes strobe-red {
            0% { border-color: #FF0055; box-shadow: 0 0 20px #FF0055; }
            50% { border-color: #000; }
            100% { border-color: #FF0055; box-shadow: 0 0 20px #FF0055; }
        }
        
        .danger-mode {
            animation: strobe-red 0.2s infinite;
        }

        /* Mobile specific adjustments if needed */
        @media (orientation: portrait) {
            #game-wrapper {
                width: 95vw; /* Use width priority in portrait */
            }
        }

    </style>
</head>
<body>

    <div class="scanlines"></div>

    <div id="game-wrapper">
        <canvas id="mainCanvas"></canvas>
        
        <!-- Stats UI -->
        <div id="stats-box" class="ui-box">
            <div class="stat-row"><span>IDX:</span> <span id="ui-index" class="stat-val">0</span></div>
            <div class="stat-row"><span>PWR:</span> <span id="ui-power" class="stat-val">-</span></div>
            <div class="stat-row"><span>MAX:</span> <span id="ui-horizon" class="stat-val">0</span></div>
        </div>

        <!-- Log UI -->
        <div id="log-box" class="ui-box">
            <div id="log-content"></div>
        </div>
    </div>

<script>
/**
 * DITHERPUNK GREEDY ALGORITHM VISUALIZER
 * Logic: Jump Game (Greedy)
 * Visuals: 320x180 Internal Buffer -> Scaled via CSS
 */

// --- CONFIGURATION ---
// We keep internal resolution low for the specific aesthetic
const INTERNAL_WIDTH = 320;
const INTERNAL_HEIGHT = 180;

// Palette (R, G, B)
const PALETTE = {
    BLACK:   { r: 0,   g: 10,  b: 0 },
    GREEN:   { r: 0,   g: 255, b: 0 },   
    CYAN:    { r: 0,   g: 255, b: 255 }, 
    PINK:    { r: 255, g: 0,   b: 85 }, 
    WHITE:   { r: 238, g: 255, b: 238 }
};

// Game Data
// Generate random jump game data
const NUMS = Array.from({length: 6}, () => Math.floor(Math.random() * 4) + 1); 
// Ensure end is reachable-ish or distinct
NUMS[NUMS.length-1] = 0; 
NUMS[0] = Math.max(1, NUMS[0]); // Ensure start isn't 0

// --- SETUP CANVAS ---
const mainCanvas = document.getElementById('mainCanvas');
const ctx = mainCanvas.getContext('2d', { willReadFrequently: true });
const bufferCanvas = document.createElement('canvas');
const bCtx = bufferCanvas.getContext('2d', { willReadFrequently: true });

// Set internal resolution logic
mainCanvas.width = INTERNAL_WIDTH;
mainCanvas.height = INTERNAL_HEIGHT;
bufferCanvas.width = INTERNAL_WIDTH;
bufferCanvas.height = INTERNAL_HEIGHT;

// --- STATE MANAGEMENT ---
const STATE = {
    START: 0, SEEK: 1, CHECK: 2, CALCULATE: 3, EXTEND: 4, LOOP: 5, SUCCESS: 6, FAIL: 7
};

let game = {
    state: STATE.START,
    idx: 0,
    horizon: 0,        
    prevHorizon: 0,    
    
    // Animation
    t: 0,
    carX: 0,
    startCarX: 0,
    targetCarX: 0,
    horizonX: 0,
    startHorizonX: 0,
    
    // Geometry (Calculated in Init)
    groundY: 120,
    spacing: 0, 
    startX: 30
};

// --- DOM UI ---
const uiIndex = document.getElementById('ui-index');
const uiPower = document.getElementById('ui-power');
const uiHorizon = document.getElementById('ui-horizon');
const logContent = document.getElementById('log-content');
const wrapper = document.getElementById('game-wrapper');

function log(msg) {
    const div = document.createElement('div');
    div.className = 'log-entry new';
    div.innerText = `> ${msg}`;
    logContent.appendChild(div);
    if(logContent.children.length > 4) {
        logContent.removeChild(logContent.children[0]);
        // Remove 'new' highlight from older logs
        if(logContent.children[0]) logContent.children[0].classList.remove('new');
    }
}

// --- INITIALIZATION ---
function init() {
    game.idx = 0;
    game.horizon = 0; 
    game.state = STATE.SEEK;
    
    // Dynamic Spacing Calculation to fit screen
    // We have INTERNAL_WIDTH pixels. Let's leave some margin.
    const margin = 30;
    const availableWidth = INTERNAL_WIDTH - (margin * 2);
    // Calculate spacing based on array length
    game.startX = margin;
    game.spacing = availableWidth / (Math.max(NUMS.length - 1, 1));
    
    game.carX = game.startX;
    game.horizonX = game.startX;

    game.positions = NUMS.map((_, i) => game.startX + (i * game.spacing));
    
    log("SYSTEM INIT... OK");
    log(`DATA: [${NUMS.join(' ')}]`);
    
    requestAnimationFrame(loop);
}

// --- CORE UTILS ---
function lerp(start, end, amt) {
    return (1 - amt) * start + amt * end;
}

// --- DITHERING ENGINE ---
function applyDither() {
    const imageData = bCtx.getImageData(0, 0, INTERNAL_WIDTH, INTERNAL_HEIGHT);
    const data = imageData.data;
    const w = INTERNAL_WIDTH;
    const h = INTERNAL_HEIGHT;

    const getClosestColor = (r, g, b) => {
        let minDist = Infinity;
        let closest = PALETTE.BLACK;
        for (let key in PALETTE) {
            const c = PALETTE[key];
            const dist = (r-c.r)**2 + (g-c.g)**2 + (b-c.b)**2; // Squared dist is faster
            if (dist < minDist) {
                minDist = dist;
                closest = c;
            }
        }
        return closest;
    };

    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const i = (y * w + x) * 4;
            const oldR = data[i], oldG = data[i+1], oldB = data[i+2];
            const c = getClosestColor(oldR, oldG, oldB);
            
            data[i] = c.r; data[i+1] = c.g; data[i+2] = c.b;

            const errR = oldR - c.r, errG = oldG - c.g, errB = oldB - c.b;

            // Atkinson Diffusion (Inline for perf)
            const distribute = (dx, dy, f) => {
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                    const ni = (ny * w + nx) * 4;
                    data[ni] += errR * f;
                    data[ni+1] += errG * f;
                    data[ni+2] += errB * f;
                }
            };

            distribute(1, 0, 0.125); distribute(2, 0, 0.125);
            distribute(-1, 1, 0.125); distribute(0, 1, 0.125); distribute(1, 1, 0.125);
            distribute(0, 2, 0.125);
        }
    }
    ctx.putImageData(imageData, 0, 0);
}

// --- DRAWING ---
function drawScene() {
    // Clear
    bCtx.fillStyle = `rgb(${PALETTE.BLACK.r},${PALETTE.BLACK.g},${PALETTE.BLACK.b})`;
    bCtx.fillRect(0, 0, INTERNAL_WIDTH, INTERNAL_HEIGHT);

    // 1. Ground
    bCtx.fillStyle = `rgb(${PALETTE.GREEN.r},${PALETTE.GREEN.g},${PALETTE.GREEN.b})`;
    bCtx.fillRect(0, game.groundY, INTERNAL_WIDTH, 2);
    
    // 2. Posts
    bCtx.textAlign = 'center';
    bCtx.font = '10px monospace';
    
    NUMS.forEach((val, i) => {
        let px = game.positions[i];
        
        // Post
        let active = i <= game.horizon;
        bCtx.fillStyle = active ? 
            `rgb(${PALETTE.GREEN.r},${PALETTE.GREEN.g},${PALETTE.GREEN.b})` : 
            `rgb(40, 40, 40)`; 
        bCtx.fillRect(px - 1, game.groundY, 2, 10);
        
        // Label
        bCtx.fillText(i, px, game.groundY + 20);

        // Canister
        let isCurrent = (i === game.idx && game.state !== STATE.SEEK);
        bCtx.fillStyle = isCurrent ? `rgb(${PALETTE.WHITE.r},${PALETTE.WHITE.g},${PALETTE.WHITE.b})` : bCtx.fillStyle;
        bCtx.fillRect(px - 6, game.groundY - 25, 12, 14);
        
        // Value
        bCtx.fillStyle = `rgb(${PALETTE.BLACK.r},${PALETTE.BLACK.g},${PALETTE.BLACK.b})`;
        bCtx.fillText(val, px, game.groundY - 16);
    });

    // 3. Jump Arc
    if (game.state === STATE.CALCULATE || game.state === STATE.EXTEND) {
        let startX = game.positions[game.idx];
        let jump = NUMS[game.idx];
        // Visual clamp logic
        let targetIndex = Math.min(game.idx + jump, NUMS.length - 1);
        
        // If jump goes beyond array, extrapolate X
        let endX;
        if (game.idx + jump >= NUMS.length) {
             endX = game.positions[NUMS.length-1] + ((game.idx + jump - (NUMS.length-1)) * game.spacing);
        } else {
             endX = game.positions[targetIndex];
        }

        bCtx.beginPath();
        bCtx.moveTo(startX, game.groundY - 25);
        bCtx.quadraticCurveTo((startX + endX)/2, game.groundY - 80, endX, game.groundY);
        bCtx.strokeStyle = `rgb(${PALETTE.CYAN.r},${PALETTE.CYAN.g},${PALETTE.CYAN.b})`;
        bCtx.lineWidth = 2;
        bCtx.stroke();
    }

    // 4. Car
    bCtx.fillStyle = `rgb(${PALETTE.GREEN.r},${PALETTE.GREEN.g},${PALETTE.GREEN.b})`;
    let cx = game.carX - 8;
    let cy = game.groundY - 10;
    bCtx.fillRect(cx, cy, 16, 8); 
    bCtx.fillRect(cx + 4, cy - 4, 8, 4); 
    bCtx.fillStyle = `rgb(${PALETTE.BLACK.r},${PALETTE.BLACK.g},${PALETTE.BLACK.b})`;
    bCtx.fillRect(cx + 2, cy + 6, 2, 2); bCtx.fillRect(cx + 12, cy + 6, 2, 2);

    // 5. Horizon Line
    bCtx.fillStyle = `rgb(${PALETTE.WHITE.r},${PALETTE.WHITE.g},${PALETTE.WHITE.b})`;
    bCtx.fillRect(game.horizonX, game.groundY - 100, 2, 100);
    // Glitchy glow
    if (Math.random() > 0.7) bCtx.fillRect(game.horizonX - 1, game.groundY - 100, 4, 100);

    // 6. Overlays
    if (game.state === STATE.FAIL) {
        bCtx.fillStyle = `rgba(${PALETTE.PINK.r},${PALETTE.PINK.g},${PALETTE.PINK.b}, 0.5)`;
        bCtx.fillRect(0, 0, INTERNAL_WIDTH, INTERNAL_HEIGHT);
        bCtx.fillStyle = `rgb(${PALETTE.PINK.r},${PALETTE.PINK.g},${PALETTE.PINK.b})`;
        bCtx.font = "30px monospace";
        bCtx.fillText("DEAD END", INTERNAL_WIDTH/2, INTERNAL_HEIGHT/2);
    }
    if (game.state === STATE.SUCCESS) {
         if (Math.floor(Date.now() / 100) % 2 === 0) {
            bCtx.fillStyle = `rgba(${PALETTE.GREEN.r},${PALETTE.GREEN.g},${PALETTE.GREEN.b}, 0.3)`;
            bCtx.fillRect(0, 0, INTERNAL_WIDTH, INTERNAL_HEIGHT);
         }
         bCtx.fillStyle = `rgb(${PALETTE.WHITE.r},${PALETTE.WHITE.g},${PALETTE.WHITE.b})`;
         bCtx.font = "30px monospace";
         bCtx.fillText("COMPLETE", INTERNAL_WIDTH/2, INTERNAL_HEIGHT/2);
    }
}

// --- UPDATE LOOP ---
function update() {
    uiIndex.innerText = game.idx;
    uiPower.innerText = (game.idx < NUMS.length) ? NUMS[game.idx] : "-";
    uiHorizon.innerText = game.horizon;

    switch (game.state) {
        case STATE.SEEK:
            if (game.t === 0) {
                game.startCarX = game.carX;
                game.targetCarX = game.positions[game.idx];
            }
            game.t += 0.05;
            game.carX = lerp(game.startCarX, game.targetCarX, Math.min(game.t, 1));
            if (game.t >= 1) { game.t = 0; game.state = STATE.CHECK; }
            break;

        case STATE.CHECK:
            if (game.t === 0) {
                if (game.idx > game.horizon) {
                    log(`FAIL: IDX ${game.idx} UNREACHABLE`);
                    wrapper.classList.add('danger-mode');
                    game.state = STATE.FAIL;
                } else {
                    log(`CHECK IDX ${game.idx}: SAFE`);
                    setTimeout(() => { game.state = STATE.CALCULATE; }, 400);
                }
                game.t = 1;
            }
            break;

        case STATE.CALCULATE:
            if (game.idx >= NUMS.length - 1) {
                log("DESTINATION REACHED");
                game.state = STATE.SUCCESS;
                return;
            }
            if (game.t === 0) { // On Enter
                let reach = game.idx + NUMS[game.idx];
                log(`JUMP: ${NUMS[game.idx]} -> REACH: ${reach}`);
                game.t = 1;
                setTimeout(() => { game.state = STATE.EXTEND; game.t = 0; }, 600);
            }
            break;

        case STATE.EXTEND:
            let potential = game.idx + NUMS[game.idx];
            let maxH = Math.max(game.horizon, potential);
            
            // Calculate pixel target for visual horizon
            let targetIdx = Math.min(maxH, NUMS.length + 1); // Extrapolate visual bounds
            let targetX = game.startX + (targetIdx * game.spacing);

            if (game.t === 0) {
                game.startHorizonX = game.horizonX;
                if (maxH > game.horizon) {
                    log(`UPDATE HORIZON: ${game.horizon} -> ${maxH}`);
                    game.horizon = maxH;
                } else {
                    game.state = STATE.LOOP;
                    return;
                }
            }
            game.t += 0.05;
            game.horizonX = lerp(game.startHorizonX, targetX, Math.min(game.t, 1));
            if (game.t >= 1) { game.t = 0; game.state = STATE.LOOP; }
            break;

        case STATE.LOOP:
            game.idx++;
            game.state = STATE.SEEK;
            break;
    }
}

// --- MAIN LOOP ---
function loop() {
    update();
    drawScene();
    applyDither();
    requestAnimationFrame(loop);
}

// Start
init();

</script>
</body>
</html>