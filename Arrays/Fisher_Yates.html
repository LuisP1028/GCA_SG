<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DITHERPUNK // RESERVOIR SAMPLING // RESPONSIVE</title>
    <style>
        /* --- CORE VARS & RESET --- */
        :root {
            --bg-color: #000000;
            --fg-color: #00FF41;
            --dim-color: #003300;
            --font-stack: 'Courier New', 'Courier', monospace;
            
            /* Responsive Units */
            --unit-size: clamp(40px, 8vmin, 80px); /* Base size for slots/packets */
            --gap-size: clamp(5px, 1vmin, 15px);
            --font-xs: clamp(8px, 2vmin, 12px);
            --font-sm: clamp(10px, 2.5vmin, 14px);
            --font-md: clamp(12px, 3vmin, 16px);
            --font-lg: clamp(16px, 4vmin, 24px);
            
            --border-style: 2px solid var(--fg-color);
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-color);
            color: var(--fg-color);
            font-family: var(--font-stack);
            margin: 0; padding: 0;
            height: 100dvh; /* Dynamic viewport height for mobile */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            font-size: var(--font-md);
            text-shadow: 0 0 2px var(--dim-color);
        }

        /* --- VISUAL FX --- */
        .dither-pattern {
            background-image: radial-gradient(var(--fg-color) 15%, transparent 16%),
                              radial-gradient(var(--fg-color) 15%, transparent 16%);
            background-size: 4px 4px;
            background-position: 0 0, 2px 2px;
        }

        .dither-sparse {
            background-image: radial-gradient(var(--fg-color) 10%, transparent 11%),
                              radial-gradient(var(--fg-color) 10%, transparent 11%);
            background-size: 8px 8px;
            background-position: 0 0, 4px 4px;
        }

        .scanline {
            position: fixed;
            inset: 0;
            background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.4) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.6;
        }

        /* --- LAYOUT STRUCTURE --- */
        .dashboard {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            padding: var(--gap-size);
            gap: var(--gap-size);
        }

        /* HEADER */
        header {
            border: var(--border-style);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 5px 15px;
            height: clamp(50px, 10vh, 70px);
            flex-shrink: 0;
        }

        .stat-box { display: flex; gap: var(--gap-size); align-items: center; width: 100%; }
        .stat-item { display: flex; flex-direction: column; min-width: 0; }
        .label { font-size: var(--font-xs); color: var(--fg-color); opacity: 0.8; white-space: nowrap; }
        .value { font-size: var(--font-lg); font-weight: bold; }

        .prob-container {
            flex-grow: 1;
            margin-left: var(--gap-size);
            border: 1px solid var(--fg-color);
            height: clamp(10px, 2vh, 20px);
            background: var(--dim-color);
            position: relative;
        }
        .prob-bar { height: 100%; width: 100%; background-color: var(--fg-color); transition: width 0.2s ease; }

        /* MAIN STAGE */
        main {
            flex: 1;
            display: flex;
            flex-direction: column; /* Mobile Default */
            gap: var(--gap-size);
            border: var(--border-style);
            position: relative;
            padding: var(--gap-size);
            overflow: hidden;
        }

        @media (min-width: 768px) {
            main { flex-direction: row; }
            #stream-panel, #void-panel { width: 20%; flex-direction: column; }
            #buffer-container { flex: 1; order: 0; }
            #stream-panel { order: -1; border-right: 1px dashed var(--dim-color); border-bottom: none; }
            #void-panel { order: 1; border-left: 1px dashed var(--dim-color); border-top: none; }
        }

        h2 {
            margin: 0 0 10px 0;
            padding: 2px;
            background: var(--fg-color);
            color: var(--bg-color);
            font-size: var(--font-xs);
            text-align: center;
            text-transform: uppercase;
        }

        /* PANELS */
        .panel { display: flex; position: relative; }

        #stream-panel {
            height: 15%; /* Mobile height */
            align-items: center;
            justify-content: center;
            border-bottom: 1px dashed var(--dim-color);
        }
        @media (min-width: 768px) { #stream-panel { height: auto; } }

        #buffer-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }
        
        #gate-zone {
            height: clamp(60px, 15vh, 100px);
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 1px dashed var(--dim-color);
            margin-bottom: 10px;
        }

        #rng-box {
            width: clamp(80px, 20vw, 120px);
            height: clamp(40px, 10vh, 60px);
            border: 4px double var(--fg-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #000;
            z-index: 10;
        }

        /* RESPONSIVE GRID */
        #buffer-grid {
            flex-grow: 1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(var(--unit-size), 1fr));
            grid-auto-rows: var(--unit-size);
            gap: var(--gap-size);
            align-content: start;
            justify-content: center;
            overflow-y: auto;
            padding: 5px;
        }

        .slot {
            width: 100%;
            height: 100%;
            aspect-ratio: 1;
            border: 1px dashed var(--dim-color);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        .slot.active-target {
            border-color: var(--fg-color);
            box-shadow: 0 0 10px var(--fg-color);
        }
        .slot-idx {
            position: absolute; bottom: 2px; right: 4px;
            font-size: var(--font-xs); color: var(--dim-color);
        }

        #void-panel {
            height: 15%; /* Mobile height */
            align-items: center;
            justify-content: flex-end; /* Mobile: items pile right */
            flex-direction: row; 
            border-top: 1px dashed var(--dim-color);
            overflow: hidden;
        }
        @media (min-width: 768px) { 
            #void-panel { flex-direction: column-reverse; justify-content: flex-start; } 
        }

        /* --- ENTITIES --- */
        .packet {
            /* Packets are sized relative to the slots */
            width: calc(var(--unit-size) * 0.8);
            height: calc(var(--unit-size) * 0.8);
            border: 2px solid var(--fg-color);
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: var(--font-lg);
            font-weight: bold;
            position: absolute; /* Default for animation flight */
            z-index: 100;
            box-shadow: 4px 4px 0px var(--dim-color);
            will-change: transform, top, left;
        }

        /* When docked inside a slot */
        .slot .packet {
            position: relative;
            top: auto !important;
            left: auto !important;
            transform: none !important;
            width: 80%;
            height: 80%;
            box-shadow: 2px 2px 0px var(--dim-color);
        }

        .packet-bg { position: absolute; inset: 0; z-index: 1; }
        .packet-content { z-index: 2; background: #000; padding: 2px; }

        .packet.voided {
            border-style: dotted; color: var(--dim-color); box-shadow: none;
        }
        .packet.voided .dither-bg { opacity: 0.3; }

        /* --- FOOTER CONTROLS --- */
        footer {
            border: var(--border-style);
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            padding: 10px;
            flex-shrink: 0;
        }
        @media (min-width: 600px) {
            footer { display: flex; align-items: center; justify-content: center; gap: 20px; }
        }

        button {
            background: #000;
            color: var(--fg-color);
            border: 1px solid var(--fg-color);
            padding: 10px 0;
            font-family: var(--font-stack);
            font-size: var(--font-sm);
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 2px 2px 0 var(--dim-color);
            width: 100%;
        }
        @media (min-width: 600px) { button { width: auto; padding: 10px 20px; } }
        
        button:hover:not(:disabled) { background: var(--fg-color); color: #000; }
        button:active:not(:disabled) { transform: translate(2px, 2px); box-shadow: none; }
        button:disabled { border-color: var(--dim-color); color: var(--dim-color); cursor: not-allowed; }

        .slider-container {
            grid-column: span 2;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        @media (min-width: 600px) { .slider-container { width: 150px; grid-column: auto; } }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 15px; width: 10px;
            background: var(--fg-color); cursor: pointer; margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 2px; cursor: pointer; background: var(--dim-color);
        }

    </style>
</head>
<body>

<div class="scanline"></div>

<div class="dashboard">
    <!-- STATS -->
    <header>
        <div class="stat-box">
            <div class="stat-item">
                <span class="label">N (TOTAL)</span>
                <span class="value" id="stat-n">0</span>
            </div>
            <div class="stat-item">
                <span class="label">K (SIZE)</span>
                <span class="value" id="stat-k">5</span>
            </div>
            <div class="stat-item" style="flex-grow: 1; display:flex; flex-direction:row; align-items:center; min-width: 0;">
                <span class="label" style="margin-right:5px;">PROB</span>
                <div class="prob-container">
                    <div class="prob-bar dither-pattern" id="prob-bar"></div>
                </div>
            </div>
        </div>
    </header>

    <!-- MAIN GRID -->
    <main>
        <!-- STREAM (Source) -->
        <div class="panel" id="stream-panel">
            <h2>INPUT</h2>
            <!-- Spawns here -->
        </div>

        <!-- BUFFER (Processing) -->
        <div class="panel" id="buffer-container">
            <div id="gate-zone">
                <div id="rng-box">
                    <span class="label">RNG (1..N)</span>
                    <span class="value" id="rng-value">--</span>
                </div>
            </div>
            <h2>VIP MEMORY</h2>
            <div id="buffer-grid">
                <!-- Slots -->
            </div>
        </div>

        <!-- VOID (Trash) -->
        <div class="panel" id="void-panel">
            <h2>NULL/VOID</h2>
            <!-- Rejects -->
        </div>
    </main>

    <!-- CONTROLS -->
    <footer>
        <button id="btn-play">INIT</button>
        <button id="btn-pause" disabled>PAUSE</button>
        <button id="btn-step" disabled>STEP</button>
        <button id="btn-reset">RESET</button>
        
        <div class="slider-container">
            <span class="label">CLOCK SPEED</span>
            <input type="range" id="speed-slider" min="100" max="2000" value="1000" step="100">
        </div>
    </footer>
</div>

<script>
/**
 * RESPONSIVE RESERVOIR SAMPLING CONTROLLER
 * Uses "Reparenting" strategy to handle resizing during pause states.
 */

const K_SIZE = 5;
let buffer = []; 
let n_processed = 0;
let isRunning = false;
let isPaused = false;
let animationSpeed = 1000; 

// References
const elStatN = document.getElementById('stat-n');
const elStatK = document.getElementById('stat-k');
const elProbBar = document.getElementById('prob-bar');
const elStream = document.getElementById('stream-panel');
const elBufferGrid = document.getElementById('buffer-grid');
const elVoid = document.getElementById('void-panel');
const elRngValue = document.getElementById('rng-value');
const elRngBox = document.getElementById('rng-box');

// Buttons
const btnPlay = document.getElementById('btn-play');
const btnPause = document.getElementById('btn-pause');
const btnStep = document.getElementById('btn-step');
const btnReset = document.getElementById('btn-reset');
const slider = document.getElementById('speed-slider');

// --- INIT ---
function initGrid() {
    elBufferGrid.innerHTML = '';
    elStatK.textContent = K_SIZE;
    for(let i=0; i<K_SIZE; i++) {
        const slot = document.createElement('div');
        slot.classList.add('slot');
        slot.id = `slot-${i}`;
        const idx = document.createElement('span');
        idx.classList.add('slot-idx');
        idx.innerText = i;
        slot.appendChild(idx);
        elBufferGrid.appendChild(slot);
    }
}

// --- UTILS ---
const sleep = ms => new Promise(r => setTimeout(r, ms));

function getRect(el) {
    const rect = el.getBoundingClientRect();
    return {
        left: rect.left,
        top: rect.top,
        width: rect.width,
        height: rect.height,
        cx: rect.left + rect.width / 2,
        cy: rect.top + rect.height / 2
    };
}

// --- ENTITY MANAGEMENT ---

function createEntity(id) {
    const el = document.createElement('div');
    el.classList.add('packet');
    el.id = `packet-${id}`;
    
    // Aesthetic internals
    const bg = document.createElement('div');
    bg.className = 'packet-bg dither-pattern';
    el.appendChild(bg);

    const content = document.createElement('span');
    content.className = 'packet-content';
    content.innerText = id;
    el.appendChild(content);

    // Initial State: Fixed position over the stream panel
    document.body.appendChild(el);
    
    const streamRect = getRect(elStream);
    const elRect = getRect(el); // Need size of created element
    
    // Center in Stream Panel
    el.style.left = (streamRect.cx - elRect.width/2) + 'px';
    // Start slightly above visible area if possible, or top of panel
    el.style.top = (streamRect.top) + 'px'; 
    
    return el;
}

/**
 * Moves an entity from its current screen position to the center of a target element.
 * Handles the logic for responsive "flight".
 */
async function moveEntityTo(entity, targetEl, duration = 500) {
    // 1. Get current absolute position
    const startRect = getRect(entity);
    
    // 2. Get target absolute position
    const targetRect = getRect(targetEl);
    
    // 3. Calculate Deltas
    // We align centers
    const finalLeft = targetRect.cx - (startRect.width / 2);
    const finalTop = targetRect.cy - (startRect.height / 2);

    // 4. Apply Transition
    entity.style.transition = `all ${duration}ms cubic-bezier(0.2, 0.8, 0.2, 1)`;
    entity.style.left = `${finalLeft}px`;
    entity.style.top = `${finalTop}px`;

    await sleep(duration);
    
    // Remove transition for future instant snaps
    entity.style.transition = 'none';
}

/**
 * THE CRITICAL "REPARENT" FUNCTION
 * Moves an element from absolute body space into a DOM container
 * to preserve layout flow on window resize.
 */
function dockEntity(entity, parentSlot) {
    // Append acts as a move. 
    // The CSS rules `.slot .packet` take over here to force relative positioning.
    parentSlot.appendChild(entity);
    // Clear inline styles that were used for flight
    entity.style.left = '';
    entity.style.top = '';
    entity.style.position = ''; 
    entity.style.width = ''; // Let CSS control size
    entity.style.height = '';
}

/**
 * THE "UNDOCK" FUNCTION
 * Pulls an element out of the flow back to absolute body space
 * so it can fly away.
 */
function undockEntity(entity) {
    const rect = getRect(entity);
    document.body.appendChild(entity); // Move to body
    
    entity.style.position = 'absolute';
    entity.style.left = `${rect.left}px`;
    entity.style.top = `${rect.top}px`;
    entity.style.width = `${rect.width}px`; // Freeze size for flight
    entity.style.height = `${rect.height}px`;
}

// --- ANIMATION LOGIC ---

async function runRngAnimation(max) {
    elRngBox.style.borderColor = 'var(--fg-color)';
    elRngValue.style.color = 'var(--fg-color)';
    
    const cycles = 8;
    const tick = Math.max(50, animationSpeed / 10);
    
    for(let i=0; i<cycles; i++) {
        elRngValue.innerText = Math.floor(Math.random() * max) + 1;
        await sleep(tick);
    }
    
    const finalRoll = Math.floor(Math.random() * max) + 1;
    elRngValue.innerText = finalRoll;
    
    // UI Feedback
    if (finalRoll <= K_SIZE) {
        elRngBox.style.background = 'var(--fg-color)';
        elRngValue.style.color = 'black';
        await sleep(200);
        elRngBox.style.background = 'black';
        elRngValue.style.color = 'var(--fg-color)';
    } else {
        elRngBox.style.borderColor = 'var(--dim-color)';
        elRngValue.style.color = 'var(--dim-color)';
    }

    return finalRoll;
}

async function processNextStep() {
    if (isPaused) return;

    n_processed++;
    updateStats();

    // 1. SPAWN (Absolute on Body)
    const packet = createEntity(n_processed);
    
    // 2. MOVE TO GATE
    await moveEntityTo(packet, elRngBox, animationSpeed);
    
    // 3. DECISION LOGIC
    if (n_processed <= K_SIZE) {
        // --- FILL PHASE ---
        elRngValue.innerText = "FILL";
        await sleep(animationSpeed * 0.2);
        
        const targetSlot = document.getElementById(`slot-${n_processed-1}`);
        buffer.push({ id: n_processed, el: packet });
        
        await moveEntityTo(packet, targetSlot, animationSpeed);
        dockEntity(packet, targetSlot); // Snap into Grid flow

    } else {
        // --- RESERVOIR PHASE ---
        const roll = await runRngAnimation(n_processed);
        
        if (roll <= K_SIZE) {
            // ACCEPT
            const slotIndex = roll - 1;
            const victimData = buffer[slotIndex];
            const targetSlot = document.getElementById(`slot-${slotIndex}`);

            // Highlight Target
            targetSlot.classList.add('active-target');
            await sleep(animationSpeed * 0.3);

            // Eject Victim
            const victimEl = victimData.el;
            undockEntity(victimEl); // Lift from grid
            
            victimEl.classList.add('voided');
            victimEl.querySelector('.packet-bg').className = 'packet-bg dither-sparse';
            
            // Move Victim to Void
            // We don't await this fully so new guy can slide in
            moveEntityTo(victimEl, elVoid, animationSpeed).then(() => {
                dockEntity(victimEl, elVoid); // Pile up in void
            });
            
            // Insert New
            buffer[slotIndex] = { id: n_processed, el: packet };
            await moveEntityTo(packet, targetSlot, animationSpeed);
            dockEntity(packet, targetSlot);
            
            targetSlot.classList.remove('active-target');

        } else {
            // REJECT
            packet.classList.add('voided');
            packet.querySelector('.packet-bg').className = 'packet-bg dither-sparse';
            
            await moveEntityTo(packet, elVoid, animationSpeed);
            dockEntity(packet, elVoid);
        }
    }

    // Cleanup Void
    if (elVoid.children.length > 5) {
        // Keep only recent rejects to prevent DOM bloating
        elVoid.removeChild(elVoid.children[0]);
    }
}

function updateStats() {
    elStatN.innerText = n_processed;
    const prob = n_processed === 0 ? 1 : Math.min(1, K_SIZE / n_processed);
    elProbBar.style.width = `${prob * 100}%`;
}

// --- LOOP & HANDLERS ---

async function loop() {
    while (isRunning) {
        if (!isPaused) {
            await processNextStep();
        } else {
            await sleep(100);
        }
    }
}

btnPlay.addEventListener('click', () => {
    if(!isRunning) {
        isRunning = true;
        isPaused = false;
        btnPlay.innerText = "RUNNING";
        btnPlay.disabled = true;
        btnPause.disabled = false;
        btnStep.disabled = true;
        loop();
    }
});

btnPause.addEventListener('click', () => {
    isPaused = !isPaused;
    if(isPaused) {
        btnPause.innerText = "RESUME";
        btnPlay.innerText = "PAUSED";
        btnStep.disabled = false;
    } else {
        btnPause.innerText = "PAUSE";
        btnPlay.innerText = "RUNNING";
        btnStep.disabled = true;
    }
});

btnStep.addEventListener('click', async () => {
    if(isPaused) {
        btnStep.disabled = true;
        await processNextStep();
        btnStep.disabled = false;
    }
});

btnReset.addEventListener('click', () => location.reload());

slider.addEventListener('input', (e) => {
    // Slider: 100 (Fast) -> 2000 (Slow). 
    // Invert logic for UI feel: Right = Faster? Standard is Left=Slow, Right=Fast.
    // Let's keep existing logic: Value is MS.
    animationSpeed = parseInt(e.target.value);
});

// Start
initGrid();

</script>
</body>
</html>