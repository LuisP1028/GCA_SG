<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DITHERPUNK_DEDUPE_PROTOCOL // RESPONSIVE</title>
    <style>
        :root {
            --bg: #000000;
            --term-green: #00FF00;
            --dim-green: #003300;
            --font-main: 'Courier New', Courier, monospace;
            
            /* Responsive Sizing Variables */
            --cell-size: clamp(40px, 10vw, 80px);
            --border-width: clamp(2px, 0.5vw, 4px);
            --gap-size: clamp(0.5rem, 2vw, 1rem);
            --pad-size: clamp(1rem, 3vw, 2rem);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            color: var(--term-green);
            font-family: var(--font-main);
            height: 100dvh; /* Dynamic viewport height for mobile browsers */
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;

            /* CSS-Only Dither Texture */
            background-image: 
                radial-gradient(circle, var(--dim-green) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(0,0,0,0.95), rgba(0,0,0,0.2) 20%, rgba(0,0,0,0.95));
            background-size: 4px 4px, 100% 100%;
        }

        /* CRT Scanline Overlay */
        body::after {
            content: " ";
            display: block;
            position: absolute;
            inset: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 999;
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
        }

        /* --- LAYOUT ARCHITECTURE --- */

        /* Header: Fixed height content, shrinks if needed */
        header {
            flex: 0 0 auto;
            border-bottom: var(--border-width) solid var(--term-green);
            padding: var(--gap-size) var(--pad-size);
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        h1 {
            margin: 0;
            font-size: clamp(1.2rem, 5vw, 2.5rem);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            text-shadow: 0 0 5px var(--term-green);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .subtitle {
            font-size: clamp(0.6rem, 2vw, 0.9rem);
            color: var(--dim-green);
            margin-top: 0.5rem;
        }

        /* Main Stage: Takes all available space */
        main {
            flex: 1 1 auto;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Manage internal scroll */
            padding: var(--gap-size) var(--pad-size);
        }

        /* Controls: Flex wrap for small screens */
        #controls {
            flex: 0 0 auto;
            display: flex;
            flex-wrap: wrap;
            gap: var(--gap-size);
            margin-bottom: var(--gap-size);
            justify-content: flex-start;
        }

        button {
            background: #000;
            color: var(--term-green);
            border: var(--border-width) solid var(--term-green);
            padding: 0.5em 1em;
            font-family: var(--font-main);
            font-size: clamp(0.8rem, 2.5vw, 1.1rem);
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 4px 4px 0 var(--dim-green);
            transition: transform 0.1s, box-shadow 0.1s;
            flex-grow: 1; /* Buttons expand on mobile */
            flex-basis: 0;
            min-width: 120px;
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--dim-green);
        }

        button:disabled {
            border-color: var(--dim-green);
            color: var(--dim-green);
            box-shadow: none;
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* The Scrollable Stage Area */
        #stage-wrapper {
            flex: 1 1 auto; /* Grow to fill space */
            border: var(--border-width) solid var(--dim-green);
            background: rgba(0, 20, 0, 0.5);
            overflow-x: auto;
            overflow-y: hidden; /* No vertical scroll on stage */
            display: flex; /* Flex to center content vertically */
            flex-direction: column;
            justify-content: center; /* Vertical Center */
            position: relative;
        }

        /* Container for the boxes - allows horizontal scrolling */
        #array-container {
            display: flex;
            gap: calc(var(--gap-size) / 2);
            padding: 40px var(--pad-size); /* Top padding for overlay/pointers */
            width: max-content; /* Force width to fit content */
            margin: 0 auto; /* Center horizontally if smaller than screen */
            min-width: 100%; /* Ensure it spans at least screen width */
            justify-content: center; /* Center items if they don't overflow */
        }
        
        /* If content overflows, flex-start prevents it from being cut off on the left */
        @media (max-width: 768px) {
            #array-container {
                justify-content: flex-start;
            }
        }

        /* --- VISUAL ELEMENTS --- */

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: var(--border-width) solid var(--term-green);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: clamp(1rem, 4vw, 2rem);
            font-weight: bold;
            position: relative;
            background: #000;
            flex-shrink: 0; /* Never squash cells */
        }

        .cell::after {
            content: attr(data-index);
            position: absolute;
            bottom: -25px;
            font-size: clamp(0.6rem, 1.5vw, 0.8rem);
            color: var(--dim-green);
            font-family: var(--font-main);
        }

        /* Logic States */
        .cell.garbage {
            color: var(--dim-green);
            border-color: var(--dim-green);
            background-image: repeating-linear-gradient(45deg, #000, #000 2px, #001100 2px, #001100 4px);
        }
        
        .cell.garbage-content {
            text-decoration: line-through;
            opacity: 0.5;
        }

        .cell.active-write {
            box-shadow: 0 0 10px var(--term-green);
            z-index: 2;
        }

        .cell.active-read {
            border-style: dashed;
        }

        /* Pointers */
        .pointer-label {
            position: absolute;
            top: -120%; /* Relative to cell size */
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(0.7rem, 2vw, 1rem);
            font-weight: bold;
            text-align: center;
            white-space: nowrap;
        }
        
        /* Log: Fixed height or percentage of bottom */
        #log {
            flex: 0 0 15vh;
            min-height: 80px;
            max-height: 150px;
            border-top: var(--border-width) solid var(--term-green);
            background: #000500;
            padding: var(--gap-size);
            overflow-y: auto;
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            line-height: 1.4;
        }

        .log-entry { margin-bottom: 4px; word-wrap: break-word; }
        .log-entry::before { content: "> "; color: var(--dim-green); }
        .log-hl { color: #FFF; text-shadow: 0 0 5px #FFF; }

        /* Animation Layer (Fixed to Viewport) */
        #animation-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100dvh;
            pointer-events: none;
            z-index: 1000;
        }

        .flying-number {
            position: fixed; /* Crucial for window-agnostic movement */
            border: var(--border-width) solid var(--term-green);
            background: #000;
            color: var(--term-green);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1rem, 4vw, 2rem);
            font-weight: bold;
            z-index: 1001;
            box-shadow: 0 0 15px var(--term-green);
        }

        .comparison-overlay {
            position: fixed;
            color: #FFF;
            font-weight: bold;
            font-size: clamp(1.5rem, 5vw, 3rem);
            text-shadow: 2px 2px 0 #000;
            z-index: 1002;
            transform: translateX(-50%);
        }

        /* Scrollbars */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #000; border: 1px solid var(--dim-green); }
        ::-webkit-scrollbar-thumb { background: var(--term-green); }
    </style>
</head>
<body>

    <header>
        <h1>DITHERPUNK_DEDUPE</h1>
        <div class="subtitle">SYS.MEM.ALLOC // RESPONSIVE // V2.0</div>
    </header>

    <main>
        <div id="controls">
            <button id="btn-step">STEP</button>
            <button id="btn-auto">AUTO</button>
            <button id="btn-reset">RESET</button>
        </div>

        <div id="stage-wrapper">
            <div id="array-container">
                <!-- Cells generated here -->
            </div>
        </div>
    </main>

    <div id="animation-layer"></div>

    <div id="log">
        <div class="log-entry">SYSTEM READY. WAITING FOR INPUT...</div>
    </div>

<script>
    // --- CONFIGURATION ---
    const INITIAL_ARRAY = [0, 0, 1, 1, 1, 2, 2, 3, 4, 4];
    const ANIMATION_SPEED = 600; // ms

    // --- STATE ---
    let array = [];
    let writePtr = 1;
    let readPtr = 1;
    let state = 'IDLE'; // IDLE, ANIMATING, FINISHED
    let autoInterval = null;

    // --- DOM ELEMENTS ---
    const container = document.getElementById('array-container');
    const animLayer = document.getElementById('animation-layer');
    const logBox = document.getElementById('log');
    const stageWrapper = document.getElementById('stage-wrapper');
    const btnStep = document.getElementById('btn-step');
    const btnAuto = document.getElementById('btn-auto');
    const btnReset = document.getElementById('btn-reset');

    // --- UTILS ---
    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    const log = (msg, highlight = false) => {
        const div = document.createElement('div');
        div.className = 'log-entry';
        div.innerHTML = highlight ? `<span class="log-hl">${msg}</span>` : msg;
        logBox.appendChild(div);
        logBox.scrollTop = logBox.scrollHeight;
    };

    // Ensure element is visible in scroll container
    const scrollIntoViewIfNeeded = (index) => {
        const cell = document.getElementById(`cell-${index}`);
        if(!cell) return;
        
        const cellRect = cell.getBoundingClientRect();
        const wrapperRect = stageWrapper.getBoundingClientRect();

        // Simple check if out of bounds horizontally
        if (cellRect.right > wrapperRect.right || cellRect.left < wrapperRect.left) {
            cell.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
    };

    // --- INITIALIZATION ---
    function init() {
        array = [...INITIAL_ARRAY];
        writePtr = 1;
        readPtr = 1;
        state = 'IDLE';
        stopAuto();
        render();
        log("MEMORY INITIALIZED. POINTERS RESET.");
        log(`ARRAY LOADED: [${array.join(', ')}]`);
        updateControls();
    }

    function render() {
        container.innerHTML = '';
        
        array.forEach((val, idx) => {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.index = idx;
            cell.id = `cell-${idx}`;
            cell.innerText = val;

            // Pointer Labels
            if (state !== 'FINISHED') {
                if (idx === writePtr) {
                    const label = document.createElement('div');
                    label.className = 'pointer-label';
                    label.innerText = 'WRT';
                    label.style.bottom = '100%'; 
                    cell.appendChild(label);
                    cell.classList.add('active-write');
                }
                if (idx === readPtr) {
                    const label = document.createElement('div');
                    label.className = 'pointer-label';
                    label.innerText = 'READ';
                    // Offset Reader label slightly higher if they collide
                    label.style.top = idx === writePtr ? '-50px' : '-35px'; 
                    cell.appendChild(label);
                    cell.classList.add('active-read');
                }
            }

            if (state === 'FINISHED' && idx >= writePtr) {
                cell.classList.add('garbage');
                cell.innerText = Math.random() > 0.5 ? '#' : '%';
            } else if (state !== 'FINISHED' && idx < readPtr && idx >= writePtr) {
                cell.classList.add('garbage', 'garbage-content');
            }

            container.appendChild(cell);
        });
    }

    // --- CORE LOGIC ---

    async function step() {
        if (state === 'FINISHED' || state === 'ANIMATING') return;
        state = 'ANIMATING';
        updateControls();

        // Scroll to action
        scrollIntoViewIfNeeded(readPtr);

        // Check bounds
        if (readPtr >= array.length) {
            log("SCAN COMPLETE. TRUNCATING TAIL...", true);
            state = 'FINISHED';
            render();
            updateControls();
            return;
        }

        // 1. COMPARE PHASE
        const prevVal = array[writePtr - 1];
        const currVal = array[readPtr];
        
        const cellWritePrev = document.getElementById(`cell-${writePtr - 1}`);
        const cellRead = document.getElementById(`cell-${readPtr}`);

        // Get Viewport-Relative Coordinates for Comparison
        const rect1 = cellWritePrev.getBoundingClientRect();
        const rect2 = cellRead.getBoundingClientRect();
        
        const midX = (rect1.right + rect2.left) / 2;
        const topY = Math.min(rect1.top, rect2.top) - 60; // Float above

        const operator = document.createElement('div');
        operator.className = 'comparison-overlay';
        const isMatch = (prevVal === currVal);
        operator.innerText = isMatch ? "==" : "!=";
        operator.style.color = isMatch ? 'var(--dim-green)' : '#FFF';
        
        // Position fixed
        operator.style.left = midX + 'px';
        operator.style.top = topY + 'px';
        
        animLayer.appendChild(operator);
        log(`COMPARING: Arr[${readPtr}](${currVal}) vs Arr[${writePtr-1}](${prevVal})`);

        await delay(ANIMATION_SPEED); 
        operator.remove();

        // 2. ACTION PHASE
        if (isMatch) {
            log(`>> DUPLICATE DETECTED. SKIPPING INDEX ${readPtr}.`);
            readPtr++;
            render();
            state = 'IDLE';
            if (readPtr >= array.length) checkFinish();
            else updateControls();
        } else {
            log(`>> NEW UNIQUE: ${currVal}. OVERWRITING INDEX ${writePtr}.`, true);
            
            const startCell = document.getElementById(`cell-${readPtr}`);
            const endCell = document.getElementById(`cell-${writePtr}`);
            
            if (startCell && endCell && readPtr !== writePtr) {
                const sRect = startCell.getBoundingClientRect();
                const eRect = endCell.getBoundingClientRect();

                const flyer = document.createElement('div');
                flyer.className = 'flying-number';
                flyer.innerText = currVal;
                
                // Set initial fixed position matching the source cell
                flyer.style.width = sRect.width + 'px';
                flyer.style.height = sRect.height + 'px';
                flyer.style.left = sRect.left + 'px';
                flyer.style.top = sRect.top + 'px';
                
                animLayer.appendChild(flyer);

                // Force layout reflow
                flyer.getBoundingClientRect();

                // Animate to target
                flyer.style.transition = `all ${ANIMATION_SPEED/1000}s cubic-bezier(0.68, -0.55, 0.27, 1.55)`;
                flyer.style.left = eRect.left + 'px';
                flyer.style.top = eRect.top + 'px';
                
                await delay(ANIMATION_SPEED);
                flyer.remove();
                
                // Flash effect
                endCell.style.backgroundColor = '#FFF';
                endCell.style.color = '#000';
                setTimeout(() => {
                    endCell.style.backgroundColor = '';
                    endCell.style.color = '';
                }, 200);
            }

            array[writePtr] = array[readPtr];
            writePtr++;
            readPtr++;
            render();
            state = 'IDLE';
            
            if (readPtr >= array.length) checkFinish();
            else updateControls();
        }
    }

    async function checkFinish() {
        if (readPtr >= array.length) {
            await delay(300);
            log("END OF ARRAY REACHED.");
            step();
        }
    }

    // --- CONTROLS ---
    function updateControls() {
        const busy = state === 'ANIMATING';
        const finished = state === 'FINISHED';
        btnStep.disabled = busy || finished;
        btnAuto.disabled = (busy && !autoInterval) || finished;
        if (finished) {
            btnAuto.innerText = "AUTO";
            stopAuto();
        }
    }

    function stopAuto() {
        if (autoInterval) {
            clearInterval(autoInterval);
            autoInterval = null;
            btnAuto.innerText = "AUTO";
        }
    }

    btnStep.addEventListener('click', () => { stopAuto(); step(); });

    btnAuto.addEventListener('click', () => {
        if (autoInterval) {
            stopAuto();
        } else {
            btnAuto.innerText = "STOP";
            step();
            autoInterval = setInterval(() => {
                if (state === 'IDLE') step();
            }, ANIMATION_SPEED + 500);
        }
    });

    btnReset.addEventListener('click', init);
    window.addEventListener('resize', () => {
        // Redraw on resize to fix pointer label positions if they shifted
        if(state !== 'ANIMATING') render(); 
    });

    init();

</script>
</body>
</html>