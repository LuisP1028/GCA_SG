<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DITHERPUNK: Composite Deduplication</title>
    <style>
        /* -----------------------------------------------------------
           1. AESTHETIC DIRECTIVE: GREEN-SCREEN DITHERPUNK
           ----------------------------------------------------------- */
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        :root {
            --neon-green: #00FF41;
            --dim-green: #008F11;
            --void-black: #050505;
            --bright-white: #EEFFEE;
            --scanline-color: rgba(0, 255, 65, 0.05);
            --font-main: 'Share Tech Mono', monospace;
            --slot-size: 100px;
            --gap-size: 10px;
        }

        * {
            box-sizing: border-box;
            user-select: none;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--void-black);
            font-family: var(--font-main);
            color: var(--neon-green);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* --- Global Filters & Overlays --- */
        .crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 999;
            background: 
                /* Scanlines */
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                /* Vignette */
                radial-gradient(circle at center, transparent 60%, black 100%);
            background-size: 100% 4px, 100% 100%;
            animation: flicker 0.15s infinite;
        }

        .dither-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 998;
            opacity: 0.15;
            background-image: radial-gradient(var(--neon-green) 1px, transparent 1px);
            background-size: 3px 3px;
        }

        @keyframes flicker {
            0% { opacity: 0.97; }
            50% { opacity: 1.0; }
            100% { opacity: 0.98; }
        }

        /* --- Layout --- */
        .interface-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90%;
            max-width: 1200px;
            z-index: 10;
        }

        h1 {
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px var(--neon-green);
            margin-bottom: 2rem;
            text-align: center;
            border-bottom: 1px solid var(--neon-green);
            padding-bottom: 10px;
            width: 100%;
        }

        /* --- The Stage --- */
        .stage {
            position: relative;
            width: 100%;
            height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 2rem;
        }

        /* --- The Wall (Array) --- */
        .array-container {
            display: flex;
            gap: var(--gap-size);
            padding: 20px;
            border: 1px dashed var(--dim-green);
            position: relative;
        }

        /* --- Composite Objects (Slots) --- */
        .slot {
            width: 100px;
            height: 120px;
            border: 2px solid var(--neon-green);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
            position: relative;
            background-color: var(--void-black);
            opacity: 0.5; /* Unprocessed State */
        }

        .slot-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .slot-payload {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        /* --- States --- */
        .slot.committed {
            opacity: 1.0;
            background-color: var(--neon-green);
            color: var(--void-black);
            box-shadow: 0 0 15px var(--neon-green);
            border-color: var(--neon-green);
        }

        .slot.duplicate {
            opacity: 0.3;
            border-style: dashed;
            text-decoration: line-through;
            filter: grayscale(100%);
        }

        .slot.comparing {
            border-color: var(--bright-white);
            box-shadow: 0 0 10px var(--bright-white) inset;
            color: var(--bright-white);
        }

        .slot.garbage {
            opacity: 0;
            transform: scale(0.8);
        }

        /* --- The Pointers --- */
        .pointer-track {
            position: absolute;
            left: 0;
            width: 100%;
            height: 30px;
            pointer-events: none;
        }

        .track-top { top: -40px; }
        .track-bottom { bottom: -40px; }

        .pointer {
            position: absolute;
            width: 0;
            height: 0;
            transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
            filter: drop-shadow(0 0 5px var(--neon-green));
            left: 0; /* Will be translated via JS */
        }

        /* Write Pointer: Inverted Filled Triangle pointing Down */
        .write-pointer {
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 20px solid var(--neon-green);
        }
        .write-label {
            position: absolute;
            top: -25px;
            left: -30px;
            width: 60px;
            text-align: center;
            font-size: 0.8rem;
        }

        /* Read Pointer: Hollow Outlined Triangle pointing Up */
        .read-pointer {
            /* CSS Hollow Triangle Hack */
            width: 20px;
            height: 20px;
            border-left: 2px solid var(--neon-green);
            border-top: 2px solid var(--neon-green);
            transform: rotate(45deg); /* Base shape, will adjust via wrapper if needed */
            /* Actually, simpler approach for hollow triangle pointing UP */
            transform: none;
            width: 0; height: 0;
            border: none;
        }
        
        /* Using pseudo-element for the hollow look to ensure cleanliness */
        .read-pointer::after {
            content: '';
            position: absolute;
            top: 0;
            left: -15px;
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 20px solid var(--neon-green);
            z-index: 1;
        }
        .read-pointer::before {
            content: '';
            position: absolute;
            top: 4px; /* Offset to create thickness */
            left: -11px;
            width: 0;
            height: 0;
            border-left: 11px solid transparent;
            border-right: 11px solid transparent;
            border-bottom: 15px solid var(--void-black);
            z-index: 2;
        }

        .read-label {
            position: absolute;
            bottom: -25px;
            left: -30px;
            width: 60px;
            text-align: center;
            font-size: 0.8rem;
        }

        /* --- Floating Clone for Animation --- */
        .floating-clone {
            position: fixed;
            z-index: 100;
            pointer-events: none;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* --- Controls & Logs --- */
        .controls {
            margin-top: 1rem;
            display: flex;
            gap: 20px;
        }

        button {
            background: transparent;
            border: 2px solid var(--neon-green);
            color: var(--neon-green);
            font-family: var(--font-main);
            font-size: 1.2rem;
            padding: 10px 30px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        button:hover {
            background: var(--neon-green);
            color: var(--void-black);
            box-shadow: 0 0 15px var(--neon-green);
        }

        button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            box-shadow: none;
            background: transparent;
            color: var(--neon-green);
        }

        .log-panel {
            margin-top: 20px;
            width: 100%;
            height: 100px;
            border: 1px solid var(--dim-green);
            background: rgba(0, 20, 5, 0.8);
            padding: 10px;
            font-size: 0.9rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column-reverse; /* New logs at bottom visual trick */
        }
        
        .log-entry {
            margin-bottom: 4px;
            border-bottom: 1px solid rgba(0, 255, 65, 0.1);
        }
        .log-entry::before { content: "> "; }

    </style>
</head>
<body>

    <!-- Visual Filters -->
    <div class="crt-overlay"></div>
    <div class="dither-overlay"></div>

    <div class="interface-container">
        <h1>Ditherpunk Deduplication // Two-Pointer</h1>

        <!-- The Visualization Stage -->
        <div class="stage">
            <div class="array-container" id="array-container">
                <!-- Pointers live relative to this container -->
                <div class="pointer-track track-top">
                    <div class="pointer write-pointer" id="write-ptr">
                        <div class="write-label">WRITE</div>
                    </div>
                </div>
                
                <!-- Slots will be injected here via JS -->

                <div class="pointer-track track-bottom">
                    <div class="pointer read-pointer" id="read-ptr">
                        <div class="read-label">READ</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button id="btn-start" onclick="runVisualization()">> EXECUTE</button>
            <button id="btn-reset" onclick="resetSystem()">> RESET</button>
        </div>

        <!-- Terminal Log -->
        <div class="log-panel" id="terminal-log">
            <div class="log-entry">System ready. Awaiting input.</div>
        </div>
    </div>

    <script>
        /* -----------------------------------------------------------
           4. ANIMATION LOGIC & DATA STRUCTURES
           ----------------------------------------------------------- */
        
        // Initial Data Configuration
        const INITIAL_DATA = [
            { name: "CHARLIE", id: 1 },
            { name: "ALICE", id: 2 },
            { name: "BOB", id: 3 },
            { name: "ALICE", id: 4 },
            { name: "CHARLIE", id: 5 },
            { name: "ALICE", id: 6 },
            { name: "DAVID", id: 7},
            { name: "BOB", id: 8}
        ];

        let currentData = [];
        let isRunning = false;
        
        // DOM Elements
        const container = document.getElementById('array-container');
        const writePtr = document.getElementById('write-ptr');
        const readPtr = document.getElementById('read-ptr');
        const logPanel = document.getElementById('terminal-log');
        const btnStart = document.getElementById('btn-start');

        // Helper: Logging
        function log(msg) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = msg;
            // Insert at top of content (flex-direction reverses it visually)
            logPanel.prepend(entry);
        }

        // Helper: Delay
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Setup: Render Array
        function renderBoard(data) {
            // Remove existing slots but keep pointers
            const slots = document.querySelectorAll('.slot');
            slots.forEach(s => s.remove());

            data.forEach((item, index) => {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.id = `slot-${index}`;
                
                // Top Half: Name
                const nameDiv = document.createElement('div');
                nameDiv.className = 'slot-name';
                nameDiv.textContent = item.name;

                // Bottom Half: Payload
                const payDiv = document.createElement('div');
                payDiv.className = 'slot-payload';
                payDiv.textContent = `#ID:${item.id}`;

                slot.appendChild(nameDiv);
                slot.appendChild(payDiv);
                container.appendChild(slot);
            });

            // Initialize pointers off-screen or at 0
            updatePointerPos(writePtr, 0);
            updatePointerPos(readPtr, 0);
        }

        // Helper: Update Pointer Position (Transform X)
        function updatePointerPos(pointerEl, index) {
            const slots = document.querySelectorAll('.slot');
            if (!slots[index]) return;
            
            const slotRect = slots[index].getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            
            // Calculate center of slot relative to container
            const relativeX = (slotRect.left - containerRect.left) + (slotRect.width / 2);
            
            // Center the pointer (pointer is centered by css shape, translate centers it)
            // Note: pointer absolute left is 0.
            pointerEl.style.transform = `translate(${relativeX - 15}px, 0)`; // -15 is approx half pointer width adjustment
        }

        // Helper: Handle Window Resize
        window.addEventListener('resize', () => {
            // Re-calculate pointer positions based on current logical indices if running
            // For simplicity in this demo, we just reset strictly visual alignment
            // In a full app, we'd store `state.writeIndex` globaly.
        });

        /* --- THE ALGORITHM VISUALIZATION --- */

        async function runVisualization() {
            if (isRunning) return;
            isRunning = true;
            btnStart.disabled = true;

            // --- Phase 1: Sort ---
            log("Initializing Sort Protocol...");
            await delay(500);

            // Logic Sort
            currentData.sort((a, b) => a.name.localeCompare(b.name));
            
            // Visual Sort "Glitch" Update
            renderBoard(currentData);
            log("Array Sorted. Locality established.");
            await delay(1000);

            // --- Phase 2: Initialization ---
            const slots = document.querySelectorAll('.slot');
            let write = 1;
            let read = 1;

            // Commit Index 0
            slots[0].classList.add('committed');
            log(`Index 0 [${currentData[0].name}] committed as Base.`);
            
            updatePointerPos(writePtr, 1);
            updatePointerPos(readPtr, 1);
            await delay(1000);

            // --- Phase 3: The Loop ---
            while (read < currentData.length) {
                // visual reference
                const readSlot = document.getElementById(`slot-${read}`);
                const compareSlot = document.getElementById(`slot-${write - 1}`);

                // Update pointers
                updatePointerPos(writePtr, write);
                updatePointerPos(readPtr, read);
                await delay(500);

                // Highlight Comparison
                readSlot.classList.add('comparing');
                compareSlot.classList.add('comparing');
                
                const valRead = currentData[read];
                const valPrev = currentData[write - 1];

                log(`Comparing [${valRead.name}] vs [${valPrev.name}]...`);
                await delay(800);

                // Remove highlight
                readSlot.classList.remove('comparing');
                compareSlot.classList.remove('comparing');

                // --- Scenario A: Duplicate ---
                if (valRead.name === valPrev.name) {
                    log("Duplicate detected. Marking obsolete.");
                    readSlot.classList.add('duplicate');
                    await delay(500);
                } 
                // --- Scenario B: Unique ---
                else {
                    log("Unique value found. Committing...");
                    
                    // The Overwrite Animation
                    // 1. Create Clone at Read Position
                    const clone = readSlot.cloneNode(true);
                    const rectRead = readSlot.getBoundingClientRect();
                    const rectWrite = document.getElementById(`slot-${write}`).getBoundingClientRect();
                    
                    // Style clone
                    clone.classList.add('floating-clone', 'committed'); // Make it look like final state
                    clone.style.width = rectRead.width + 'px';
                    clone.style.height = rectRead.height + 'px';
                    clone.style.left = rectRead.left + 'px';
                    clone.style.top = rectRead.top + 'px';
                    clone.style.margin = 0;
                    document.body.appendChild(clone);

                    // Force reflow
                    clone.getBoundingClientRect();

                    // 2. Animate to Write Position
                    const deltaX = rectWrite.left - rectRead.left;
                    clone.style.transform = `translateX(${deltaX}px)`;

                    await delay(600); // Wait for CSS transition

                    // 3. Update DOM at Write Index
                    const writeSlot = document.getElementById(`slot-${write}`);
                    
                    // Logic Update
                    currentData[write] = currentData[read];
                    
                    // Visual Update (Text)
                    writeSlot.querySelector('.slot-name').textContent = valRead.name;
                    writeSlot.querySelector('.slot-payload').textContent = `#ID:${valRead.id}`;
                    
                    // Visual Update (Style)
                    writeSlot.classList.remove('duplicate', 'garbage'); // Clean any previous state
                    writeSlot.classList.add('committed');

                    // Cleanup Clone
                    clone.remove();
                    
                    write++;
                }

                read++;
            }

            // --- Phase 4: Truncation ---
            log("Traversal complete. Initiating Garbage Collection...");
            await delay(1000);

            for (let i = write; i < currentData.length; i++) {
                const s = document.getElementById(`slot-${i}`);
                if (s) s.classList.add('garbage');
            }

            log(`Memory optimized. New Length: ${write}`);
            btnStart.disabled = false;
            isRunning = false;
        }

        function resetSystem() {
            if (isRunning) return; // Prevent reset during run
            log("System Reset.");
            currentData = JSON.parse(JSON.stringify(INITIAL_DATA)); // Deep copy
            renderBoard(currentData);
            
            // Reset styles manually since renderBoard is clean, 
            // but we want to ensure pointers reset visually too
            const slots = document.querySelectorAll('.slot');
            slots.forEach(s => s.className = 'slot'); // remove committed/duplicate
            
            updatePointerPos(writePtr, 0);
            updatePointerPos(readPtr, 0);
        }

        // Initial Boot
        resetSystem();

    </script>
</body>
</html>