<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DITHERPUNK: Composite Deduplication</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        :root {
            /* --- Colors --- */
            --neon-green: #00FF41;
            --dim-green: #008F11;
            --void-black: #050505;
            --bright-white: #EEFFEE;
            
            /* --- Responsive Dimensions using CLAMP --- */
            /* Minimum 60px, Preferred 10vw, Max 140px */
            --slot-w: clamp(60px, 10vw, 140px);
            /* Aspect ratio roughly maintained */
            --slot-h: clamp(72px, 12vw, 168px); 
            --gap-size: clamp(5px, 1vw, 20px);
            
            /* --- Typography --- */
            --font-main: 'Share Tech Mono', monospace;
            --text-base: clamp(0.8rem, 1.5vw, 1.1rem);
            --text-lg: clamp(1.2rem, 3vw, 2rem);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--void-black);
            font-family: var(--font-main);
            color: var(--neon-green);
            overflow: hidden; /* Main scroll hidden, inner scroll allowed */
        }

        /* --- Global Filters & Overlays --- */
        .crt-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 999;
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                radial-gradient(circle at center, transparent 60%, black 100%);
            background-size: 100% 4px, 100% 100%;
            animation: flicker 0.15s infinite;
        }

        .dither-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 998;
            opacity: 0.15;
            background-image: radial-gradient(var(--neon-green) 1px, transparent 1px);
            background-size: 3px 3px;
        }

        @keyframes flicker {
            0% { opacity: 0.97; }
            50% { opacity: 1.0; }
            100% { opacity: 0.98; }
        }

        /* --- Main Layout --- */
        .interface-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 2rem;
            max-width: 1600px;
            margin: 0 auto;
            z-index: 10;
        }

        header {
            width: 100%;
            text-align: center;
            margin-bottom: 2vh;
        }

        h1 {
            font-size: var(--text-lg);
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px var(--neon-green);
            margin: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--neon-green);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- The Stage (Scrollable Container) --- */
        .stage {
            position: relative;
            width: 100%;
            /* Allocate enough height for slots + pointers */
            min-height: calc(var(--slot-h) + 120px); 
            display: flex;
            align-items: center;
            /* Allow horizontal scroll on mobile */
            overflow-x: auto; 
            overflow-y: hidden;
            padding: 40px 20px;
            
            /* Custom Scrollbar */
            scrollbar-width: thin;
            scrollbar-color: var(--dim-green) var(--void-black);
        }

        /* Hide scrollbar for cleaner look where possible */
        .stage::-webkit-scrollbar { height: 6px; }
        .stage::-webkit-scrollbar-track { background: var(--void-black); }
        .stage::-webkit-scrollbar-thumb { background: var(--dim-green); border-radius: 3px; }

        /* --- The Array (Relative Anchor) --- */
        .array-container {
            display: flex;
            gap: var(--gap-size);
            padding: 10px;
            border: 1px dashed var(--dim-green);
            position: relative;
            /* Ensure it takes up width, but centers if smaller than screen */
            margin: 0 auto; 
            min-width: max-content; 
        }

        /* --- Composite Objects (Slots) --- */
        .slot {
            width: var(--slot-w);
            height: var(--slot-h);
            border: 2px solid var(--neon-green);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            background-color: var(--void-black);
            opacity: 0.5;
            transition: all 0.3s ease;
            /* Prevent shrinking */
            flex-shrink: 0; 
        }

        .slot-name {
            font-size: calc(var(--text-base) * 1.2);
            font-weight: bold;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            text-align: center;
            word-break: break-all;
        }

        .slot-payload {
            font-size: calc(var(--text-base) * 0.7);
            opacity: 0.8;
            font-family: monospace;
        }

        /* --- States --- */
        .slot.committed {
            opacity: 1.0;
            background-color: var(--neon-green);
            color: var(--void-black);
            box-shadow: 0 0 15px var(--neon-green);
            border-color: var(--neon-green);
        }

        .slot.duplicate {
            opacity: 0.3;
            border-style: dashed;
            text-decoration: line-through;
            filter: grayscale(100%);
        }

        .slot.comparing {
            border-color: var(--bright-white);
            box-shadow: 0 0 15px var(--bright-white) inset;
            color: var(--bright-white);
        }

        .slot.garbage {
            opacity: 0;
            transform: scale(0.8);
        }

        /* --- The Pointers --- */
        .pointer-track {
            position: absolute;
            left: 0;
            width: 100%;
            height: 0;
            pointer-events: none;
        }

        .track-top { top: -20px; }
        .track-bottom { bottom: -20px; }

        .pointer {
            position: absolute;
            width: 0;
            height: 0;
            transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
            filter: drop-shadow(0 0 5px var(--neon-green));
            left: 0; 
            z-index: 20;
        }

        /* Pointer shapes scaled via em/calc */
        .write-pointer {
            border-left: 0.6em solid transparent;
            border-right: 0.6em solid transparent;
            border-top: 0.8em solid var(--neon-green);
            font-size: clamp(16px, 2vw, 24px); /* Scales shape */
        }
        
        .read-pointer {
            /* CSS Hollow Triangle Hack */
            width: 0.8em;
            height: 0.8em;
            font-size: clamp(16px, 2vw, 24px); /* Scales shape */
            position: relative;
        }

        .read-pointer::after {
            content: '';
            position: absolute;
            top: 0;
            left: -0.6em;
            width: 0;
            height: 0;
            border-left: 0.6em solid transparent;
            border-right: 0.6em solid transparent;
            border-bottom: 0.8em solid var(--neon-green);
        }
        
        .read-pointer::before {
            content: '';
            position: absolute;
            top: 0.2em;
            left: -0.4em;
            width: 0;
            height: 0;
            border-left: 0.4em solid transparent;
            border-right: 0.4em solid transparent;
            border-bottom: 0.6em solid var(--void-black);
            z-index: 2;
        }

        .pointer-label {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: max-content;
            font-size: 0.6rem;
            letter-spacing: 1px;
            font-weight: bold;
        }
        
        .write-label { top: -1.5em; }
        .read-label { bottom: -1.5em; }

        /* --- Floating Clone for Animation --- */
        .floating-clone {
            position: fixed;
            z-index: 100;
            pointer-events: none;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            margin: 0 !important;
        }

        /* --- Controls & Logs --- */
        .controls {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
        }

        button {
            background: transparent;
            border: 2px solid var(--neon-green);
            color: var(--neon-green);
            font-family: var(--font-main);
            font-size: var(--text-base);
            padding: 0.5em 1.5em;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            white-space: nowrap;
        }

        button:hover:not(:disabled) {
            background: var(--neon-green);
            color: var(--void-black);
            box-shadow: 0 0 15px var(--neon-green);
        }

        button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            border-color: var(--dim-green);
            color: var(--dim-green);
        }

        .log-panel {
            margin-top: 2rem;
            width: 100%;
            flex-grow: 1; /* Take remaining height */
            max-height: 200px;
            min-height: 100px;
            border: 1px solid var(--dim-green);
            background: rgba(0, 20, 5, 0.8);
            padding: 10px;
            font-size: calc(var(--text-base) * 0.9);
            overflow-y: auto;
            display: flex;
            flex-direction: column-reverse; 
        }
        
        .log-entry {
            margin-bottom: 4px;
            border-bottom: 1px solid rgba(0, 255, 65, 0.1);
            word-wrap: break-word;
        }
        .log-entry::before { content: "> "; color: var(--dim-green); }

    </style>
</head>
<body>

<!-- Visual Filters -->
<div class="crt-overlay"></div>
<div class="dither-overlay"></div>

<div class="interface-container">
    <header>
        <h1>Ditherpunk Deduplication</h1>
    </header>

    <!-- The Visualization Stage -->
    <div class="stage" id="stage-viewport">
        <div class="array-container" id="array-container">
            
            <div class="pointer-track track-top">
                <div class="pointer write-pointer" id="write-ptr">
                    <div class="pointer-label write-label">WRITE</div>
                </div>
            </div>
            
            <!-- Slots Injected Here -->

            <div class="pointer-track track-bottom">
                <div class="pointer read-pointer" id="read-ptr">
                    <div class="pointer-label read-label">READ</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <button id="btn-start" onclick="runVisualization()">> EXECUTE</button>
        <button id="btn-reset" onclick="resetSystem()">> RESET</button>
    </div>

    <!-- Terminal Log -->
    <div class="log-panel" id="terminal-log">
        <div class="log-entry">System ready. Awaiting input.</div>
    </div>
</div>

<script>
    /* -----------------------------------------------------------
       LOGIC & RESPONSIVENESS
       ----------------------------------------------------------- */
    
    // Initial Data
    const INITIAL_DATA = [
        { name: "CHARLIE", id: 1 },
        { name: "ALICE", id: 2 },
        { name: "BOB", id: 3 },
        { name: "ALICE", id: 4 },
        { name: "CHARLIE", id: 5 },
        { name: "ALICE", id: 6 },
        { name: "DAVID", id: 7},
        { name: "BOB", id: 8}
    ];

    // Global State to handle Resizing
    let state = {
        data: [],
        isRunning: false,
        writeIdx: 0,
        readIdx: 0,
        stage: 'IDLE' // IDLE, SORTING, RUNNING, DONE
    };
    
    // DOM Elements
    const container = document.getElementById('array-container');
    const writePtr = document.getElementById('write-ptr');
    const readPtr = document.getElementById('read-ptr');
    const logPanel = document.getElementById('terminal-log');
    const btnStart = document.getElementById('btn-start');

    // Helper: Logging
    function log(msg) {
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        entry.textContent = msg;
        logPanel.prepend(entry);
    }

    // Helper: Delay
    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Setup: Render Array
    function renderBoard(data) {
        // Clear slots, keep pointers
        const slots = document.querySelectorAll('.slot');
        slots.forEach(s => s.remove());

        data.forEach((item, index) => {
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.id = `slot-${index}`;
            
            const nameDiv = document.createElement('div');
            nameDiv.className = 'slot-name';
            nameDiv.textContent = item.name;

            const payDiv = document.createElement('div');
            payDiv.className = 'slot-payload';
            payDiv.textContent = `#${item.id}`;

            slot.appendChild(nameDiv);
            slot.appendChild(payDiv);
            container.appendChild(slot);
        });

        // Snap pointers to current state indices
        updatePointerPos(writePtr, state.writeIdx);
        updatePointerPos(readPtr, state.readIdx);
    }

    // Core Logic: Pointer Positioning
    // Uses getBoundingClientRect to be strictly responsive to layout engine
    function updatePointerPos(pointerEl, index) {
        const slots = document.querySelectorAll('.slot');
        
        // Safety check
        if (!slots[index] || index < 0) {
            // If out of bounds, maybe hide or clamp?
            // For this algo, we stick to last valid or 0
            if(slots.length > 0) index = 0; 
            else return; 
        }

        const targetSlot = slots[index];
        const containerRect = container.getBoundingClientRect();
        const slotRect = targetSlot.getBoundingClientRect();

        // Calculate center relative to the container
        // Pointer left=0 is at container left=0.
        const centerX = (slotRect.left - containerRect.left) + (slotRect.width / 2);
        
        pointerEl.style.transform = `translate(${centerX}px, 0)`;
        
        // Auto-scroll on mobile if pointer goes off screen
        ensureVisible(targetSlot);
    }

    function ensureVisible(element) {
        const viewport = document.getElementById('stage-viewport');
        const rect = element.getBoundingClientRect();
        const viewRect = viewport.getBoundingClientRect();

        // Simple check if outside horizontal view
        if (rect.right > viewRect.right) {
            viewport.scrollBy({ left: rect.width + 20, behavior: 'smooth' });
        } else if (rect.left < viewRect.left) {
            viewport.scrollBy({ left: -(rect.width + 20), behavior: 'smooth' });
        }
    }

    // Event: Resize Handler
    // Debounced slightly for performance
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            if (state.data.length > 0) {
                updatePointerPos(writePtr, state.writeIdx);
                updatePointerPos(readPtr, state.readIdx);
            }
        }, 50);
    });

    /* --- THE ALGORITHM --- */

    async function runVisualization() {
        if (state.isRunning) return;
        state.isRunning = true;
        state.stage = 'SORTING';
        btnStart.disabled = true;

        // --- Phase 1: Sort ---
        log("Sorting...");
        await delay(500);

        state.data.sort((a, b) => a.name.localeCompare(b.name));
        renderBoard(state.data);
        log("Sort complete.");
        await delay(800);

        // --- Phase 2: Init Pointers ---
        state.stage = 'RUNNING';
        
        // Index 0 is implicitly committed
        document.getElementById('slot-0').classList.add('committed');
        
        state.writeIdx = 1;
        state.readIdx = 1;

        updatePointerPos(writePtr, state.writeIdx);
        updatePointerPos(readPtr, state.readIdx);
        await delay(800);

        // --- Phase 3: Loop ---
        while (state.readIdx < state.data.length) {
            // Update pointers visually
            updatePointerPos(writePtr, state.writeIdx);
            updatePointerPos(readPtr, state.readIdx);

            const readSlot = document.getElementById(`slot-${state.readIdx}`);
            const compareSlot = document.getElementById(`slot-${state.writeIdx - 1}`); // Compare against last written

            await delay(400);

            // Highlight
            readSlot.classList.add('comparing');
            compareSlot.classList.add('comparing');
            
            const valRead = state.data[state.readIdx];
            const valPrev = state.data[state.writeIdx - 1];

            log(`CMP: [${valRead.name}] vs [${valPrev.name}]`);
            await delay(700);

            readSlot.classList.remove('comparing');
            compareSlot.classList.remove('comparing');

            // Logic
            if (valRead.name === valPrev.name) {
                readSlot.classList.add('duplicate');
                log("Duplicate. Skip.");
                await delay(400);
            } else {
                log("Unique. Writing...");
                
                // Animation: Clone readSlot and move to writeSlot
                await animateOverwrite(readSlot, document.getElementById(`slot-${state.writeIdx}`));

                // Data Update
                state.data[state.writeIdx] = state.data[state.readIdx];
                
                // DOM Update
                const writeSlot = document.getElementById(`slot-${state.writeIdx}`);
                writeSlot.querySelector('.slot-name').textContent = valRead.name;
                writeSlot.querySelector('.slot-payload').textContent = `#${valRead.id}`;
                writeSlot.classList.remove('duplicate', 'garbage');
                writeSlot.classList.add('committed');
                
                state.writeIdx++;
            }
            state.readIdx++;
        }

        // --- Phase 4: Cleanup ---
        log("Optimization complete. Truncating...");
        updatePointerPos(writePtr, state.writeIdx); // Final position
        await delay(500);

        for (let i = state.writeIdx; i < state.data.length; i++) {
            const s = document.getElementById(`slot-${i}`);
            if (s) s.classList.add('garbage');
        }

        state.stage = 'DONE';
        state.isRunning = false;
        btnStart.disabled = false;
        log(`Final Length: ${state.writeIdx}`);
    }

    // Helper: Animation Logic
    function animateOverwrite(sourceEl, targetEl) {
        return new Promise(resolve => {
            const clone = sourceEl.cloneNode(true);
            const sRect = sourceEl.getBoundingClientRect();
            const tRect = targetEl.getBoundingClientRect();

            // Setup fixed clone
            clone.classList.add('floating-clone', 'committed');
            clone.style.width = sRect.width + 'px';
            clone.style.height = sRect.height + 'px';
            clone.style.left = sRect.left + 'px';
            clone.style.top = sRect.top + 'px';
            
            document.body.appendChild(clone);
            
            // Trigger reflow
            clone.getBoundingClientRect();

            // Calculate delta
            const deltaX = tRect.left - sRect.left;
            const deltaY = tRect.top - sRect.top; // Should be 0 usually, but robustness helps

            clone.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

            setTimeout(() => {
                clone.remove();
                resolve();
            }, 600); // Match CSS transition time
        });
    }

    function resetSystem() {
        if (state.isRunning) return;
        
        log("--- SYSTEM RESET ---");
        state.data = JSON.parse(JSON.stringify(INITIAL_DATA));
        state.writeIdx = 0;
        state.readIdx = 0;
        state.stage = 'IDLE';

        renderBoard(state.data);
        
        // Reset Visual Styles
        const slots = document.querySelectorAll('.slot');
        slots.forEach(s => s.className = 'slot'); 
    }

    // Boot
    resetSystem();

</script>
</body>
</html>