<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DITHERPUNK // FREQ_SORT</title>
    <style>
        :root {
            --void: #050505;
            --term: #33FF00;
            --term-dim: #1a8000;
            --font-stack: 'VT323', 'Courier New', monospace;
            --scanline: rgba(51, 255, 0, 0.05);
        }

        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        * { box-sizing: border-box; }

        body {
            background-color: var(--void);
            color: var(--term);
            font-family: var(--font-stack);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            text-transform: uppercase;
        }

        /* --- UTILS --- */
        .scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 999;
        }

        /* --- LAYOUT --- */
        #app-container {
            display: grid;
            grid-template-rows: 60px 1fr 200px; /* Header, Main, Controls */
            height: 100%;
            width: 100%;
            padding: 20px;
            gap: 20px;
        }

        /* HEADER / NARRATIVE ZONE C */
        header {
            border: 1px solid var(--term);
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--void);
            position: relative;
        }

        #narrative-log {
            font-size: 1.2rem;
            white-space: pre;
        }
        
        #narrative-log::after {
            content: '█';
            animation: blink 1s infinite;
        }

        /* MAIN ZONE A */
        #zone-main {
            border: 1px solid var(--term);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }

        .array-track {
            display: flex;
            gap: 10px;
            padding: 20px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }

        .slot {
            width: 60px;
            height: 80px;
            border: 1px dashed var(--term-dim);
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.5s;
        }

        /* AVATAR */
        .avatar {
            width: 50px;
            height: 70px;
            border: 2px solid var(--term);
            background: var(--void);
            color: var(--term);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            position: relative; /* For FLIP */
            z-index: 2;
        }

        .avatar.locked {
            background: var(--term);
            color: var(--void);
        }

        .avatar.inspecting {
            box-shadow: 0 0 15px var(--term);
        }

        /* TOOLTIP */
        .tooltip {
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--void);
            border: 1px solid var(--term);
            padding: 5px;
            font-size: 0.8rem;
            white-space: nowrap;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }
        .avatar.inspecting .tooltip { opacity: 1; }

        /* ZONE B: CONTROL PANEL */
        #zone-controls {
            border: 1px solid var(--term);
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 10px;
            padding: 10px;
        }

        .panel-box {
            border: 1px solid var(--term-dim);
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .panel-title {
            border-bottom: 1px solid var(--term);
            margin-bottom: 10px;
            font-weight: bold;
        }

        /* FREQUENCY TABLE */
        .freq-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 1.1rem;
        }
        .freq-count { font-weight: bold; }

        /* OFFSET MAP */
        .offset-map {
            display: flex;
            align-items: flex-end;
            height: 100%;
            gap: 2px;
            position: relative;
        }
        
        .offset-col {
            flex: 1;
            border: 1px dotted var(--term-dim);
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            position: relative;
        }

        .pointer-arrow {
            color: var(--term);
            font-size: 1.5rem;
            opacity: 0.2;
            transition: all 0.3s;
        }

        /* --- POINTER STATES --- */
        .pointer-arrow.source { color: #FFFF00; opacity: 1; transform: translateY(-5px); }
        .pointer-arrow.target { color: #33FF00; opacity: 1; transform: translateY(-5px); }
        .pointer-arrow.done   { color: #333; opacity: 0.1; }

        /* --- DITHER PATTERNS (Generated via CSS) --- */
        /* Pattern 0: Checker */
        .dither-0 {
            background-image: linear-gradient(45deg, var(--term) 25%, transparent 25%), 
                              linear-gradient(-45deg, var(--term) 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, var(--term) 75%), 
                              linear-gradient(-45deg, transparent 75%, var(--term) 75%);
            background-size: 4px 4px;
            background-position: 0 0, 0 2px, 2px -2px, -2px 0px;
            opacity: 0.3;
        }
        /* Pattern 1: Horizontal Lines */
        .dither-1 {
            background: repeating-linear-gradient(
                0deg,
                var(--term),
                var(--term) 1px,
                transparent 1px,
                transparent 4px
            );
            opacity: 0.3;
        }
        /* Pattern 2: Vertical Lines */
        .dither-2 {
            background: repeating-linear-gradient(
                90deg,
                var(--term),
                var(--term) 1px,
                transparent 1px,
                transparent 4px
            );
            opacity: 0.3;
        }
        /* Pattern 3: Dots */
        .dither-3 {
            background-image: radial-gradient(var(--term) 1px, transparent 1px);
            background-size: 4px 4px;
            opacity: 0.3;
        }

        /* --- PARTICLES --- */
        .particle {
            position: fixed;
            width: 10px;
            height: 10px;
            background: var(--term);
            pointer-events: none;
            z-index: 100;
        }

        /* SCANNER BAR */
        .scanner-bar {
            position: absolute;
            top: 0; left: 0;
            width: 60px; height: 80px; /* matches slot */
            border: 2px solid var(--term);
            box-shadow: 0 0 10px var(--term);
            pointer-events: none;
            transition: transform 0.3s cubic-bezier(0.22, 1, 0.36, 1);
            opacity: 0;
            z-index: 50;
        }

        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>
    <div class="scanlines"></div>

    <div id="app-container">
        <!-- Zone C: Header / Narrative -->
        <header>
            <div id="narrative-log">> SYSTEM_INIT...</div>
            <div style="font-size: 0.8rem">MEM: 64KB OK</div>
        </header>

        <!-- Zone A: Main Array -->
        <div id="zone-main">
            <div id="scanner" class="scanner-bar"></div>
            <div class="array-track" id="array-container">
                <!-- Slots injected via JS -->
            </div>
        </div>

        <!-- Zone B: Controls -->
        <div id="zone-controls">
            <div class="panel-box">
                <div class="panel-title">FREQUENCY_TABLE</div>
                <div id="freq-table"></div>
            </div>
            <div class="panel-box">
                <div class="panel-title">OFFSET_MAP / POINTERS</div>
                <div class="offset-map" id="offset-map"></div>
            </div>
        </div>
    </div>

    <script>
        /**
         * CORE CONFIGURATION
         */
        const CONFIG = {
            data: [10, 20, 10, 30, 20, 10, 40, 30, 20, 10], // The dataset
            delay: {
                step: 600,
                move: 800,
                scan: 200
            }
        };

        // Utility: Async Wait
        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // Utility: FLIP Animation Helper
        class Flipper {
            constructor() {
                this.positions = new Map();
            }
            
            read(elements) {
                elements.forEach(el => {
                    const id = el.getAttribute('data-id');
                    this.positions.set(id, el.getBoundingClientRect());
                });
            }

            async play(elements, duration = 500) {
                elements.forEach(el => {
                    const id = el.getAttribute('data-id');
                    if (!this.positions.has(id)) return;

                    const first = this.positions.get(id);
                    const last = el.getBoundingClientRect();

                    const dx = first.left - last.left;
                    const dy = first.top - last.top;

                    // Invert
                    if (dx !== 0 || dy !== 0) {
                        el.style.transition = 'none';
                        el.style.transform = `translate(${dx}px, ${dy}px)`;
                    }
                });

                // Force reflow
                document.body.offsetHeight;

                // Play
                const promises = [];
                elements.forEach(el => {
                    const id = el.getAttribute('data-id');
                    if (!this.positions.has(id)) return;
                    
                    el.style.transition = `transform ${duration}ms cubic-bezier(0.22, 1, 0.36, 1)`;
                    el.style.transform = `translate(0, 0)`;
                    
                    promises.push(new Promise(r => {
                        el.addEventListener('transitionend', r, { once: true });
                        setTimeout(r, duration + 50); // Fallback
                    }));
                });

                return Promise.all(promises);
            }
        }

        /**
         * APP CONTROLLER
         */
        class App {
            constructor() {
                this.narrative = document.getElementById('narrative-log');
                this.container = document.getElementById('array-container');
                this.freqTable = document.getElementById('freq-table');
                this.offsetMap = document.getElementById('offset-map');
                this.scanner = document.getElementById('scanner');

                this.uniqueAges = [...new Set(CONFIG.data)].sort((a,b) => a - b);
                this.patternMap = {}; // Age -> CSS Class
                
                // Assign patterns
                this.uniqueAges.forEach((age, i) => {
                    this.patternMap[age] = `dither-${i % 4}`;
                });

                // State
                this.arr = CONFIG.data.map((age, idx) => ({ id: `item-${idx}`, age, locked: false }));
                this.counts = {};
                this.pointers = {}; 
                this.offsets = {};

                this.renderInitialState();
                this.run();
            }

            log(text) {
                // Typewriter effect simulation
                this.narrative.innerText = `> ${text}`;
            }

            renderInitialState() {
                this.container.innerHTML = '';
                this.arr.forEach((item, idx) => {
                    const slot = document.createElement('div');
                    slot.className = 'slot';
                    slot.id = `slot-${idx}`;
                    
                    const av = document.createElement('div');
                    av.className = 'avatar';
                    av.setAttribute('data-id', item.id);
                    av.innerText = item.age;
                    av.innerHTML += `<div class="tooltip">AGE:${item.age}</div>`;
                    
                    slot.appendChild(av);
                    this.container.appendChild(slot);
                });

                // Init Freq Table
                this.freqTable.innerHTML = '';
                this.uniqueAges.forEach(age => {
                    const row = document.createElement('div');
                    row.className = 'freq-row';
                    row.innerHTML = `<span>AGE [${age}]</span><span class="freq-count" id="count-${age}">00</span>`;
                    this.freqTable.appendChild(row);
                });
            }

            /* --- PHASE 1: FREQUENCY SCAN --- */
            async phaseScan() {
                this.log("INIT SEQUENCE: FREQUENCY SCAN...");
                this.scanner.style.opacity = 1;

                for (let i = 0; i < this.arr.length; i++) {
                    const slot = document.getElementById(`slot-${i}`);
                    const avatar = slot.querySelector('.avatar');
                    const age = this.arr[i].age;

                    // Move Scanner
                    const sRect = slot.getBoundingClientRect();
                    const containerRect = document.getElementById('zone-main').getBoundingClientRect();
                    
                    // Relative positioning for scanner inside zone-main
                    this.scanner.style.transform = `translate(${sRect.left - containerRect.left}px, ${sRect.top - containerRect.top}px)`;

                    await wait(CONFIG.delay.scan);

                    // Particle Effect
                    this.spawnParticle(avatar, document.getElementById(`count-${age}`));
                    
                    // Logic update
                    this.counts[age] = (this.counts[age] || 0) + 1;
                    document.getElementById(`count-${age}`).innerText = String(this.counts[age]).padStart(2, '0');
                }
                
                this.scanner.style.opacity = 0;
                await wait(500);
            }

            spawnParticle(fromEl, toEl) {
                const p = document.createElement('div');
                p.className = 'particle';
                const fR = fromEl.getBoundingClientRect();
                const tR = toEl.getBoundingClientRect();

                p.style.left = fR.left + fR.width/2 + 'px';
                p.style.top = fR.top + fR.height/2 + 'px';
                document.body.appendChild(p);

                // Force layout
                p.offsetHeight;

                p.style.transition = 'all 0.4s ease-in';
                p.style.left = tR.left + 'px';
                p.style.top = tR.top + 'px';
                p.style.opacity = 0;

                setTimeout(() => p.remove(), 400);
            }

            /* --- PHASE 2: OFFSET CALC & RESERVATION --- */
            async phaseOffsets() {
                this.log("CALCULATING MEMORY OFFSETS...");
                await wait(500);

                let cumulative = 0;
                this.offsetMap.innerHTML = '';

                for (let age of this.uniqueAges) {
                    const count = this.counts[age];
                    const startIdx = cumulative;
                    this.offsets[age] = startIdx;
                    this.pointers[age] = startIdx; // Init Write Pointers
                    
                    // 1. VISUALIZE TERRITORY (Dither Patterns)
                    this.log(`RESERVING ${count} SLOTS FOR AGE ${age}`);
                    
                    for(let i=0; i<count; i++) {
                        const slotIdx = startIdx + i;
                        const slot = document.getElementById(`slot-${slotIdx}`);
                        slot.classList.add(this.patternMap[age]);
                        await wait(50);
                    }

                    // 2. CREATE VISUAL POINTERS IN ZONE B
                    const col = document.createElement('div');
                    col.className = 'offset-col';
                    col.innerHTML = `
                        <div class="pointer-arrow" id="arrow-${age}">▲</div>
                        <div style="font-size:0.7rem">${age}</div>
                    `;
                    this.offsetMap.appendChild(col);

                    cumulative += count;
                }
                await wait(1000);
            }

            /* --- PHASE 3: SWAP LOOP --- */
            async phaseSwap() {
                this.log("EXECUTING IN-PLACE SORT ROUTINE...");
                const flipper = new Flipper();
                const completedGroups = new Set();

                // Iterate through each region based on unique ages order
                for (let ageGroup of this.uniqueAges) {
                    
                    // While the pointer for this group hasn't reached the end of the group
                    const groupEnd = this.offsets[ageGroup] + this.counts[ageGroup];

                    while (this.pointers[ageGroup] < groupEnd) {
                        
                        // Current Write Pointer Index
                        let currIdx = this.pointers[ageGroup];
                        let currItem = this.arr[currIdx];

                        // Set Pointers: Source active, Target unknown yet
                        this.updatePointerVisuals(ageGroup, null, completedGroups);

                        // If item is already correct, just lock and move on
                        if (currItem.age === ageGroup) {
                            this.log(`INDEX ${currIdx}: ALREADY CORRECT.`);
                            this.markLocked(currIdx);
                            this.pointers[ageGroup]++;
                            continue;
                        }

                        // INSPECT
                        this.log(`INSPECTING INDEX ${currIdx}. FOUND AGE ${currItem.age}.`);
                        const avatarEl = document.querySelector(`[data-id='${currItem.id}']`);
                        avatarEl.classList.add('inspecting');
                        avatarEl.querySelector('.tooltip').innerText = `TARGET: ZONE ${currItem.age}`;
                        await wait(CONFIG.delay.step);

                        // CALCULATE TARGET
                        const targetAge = currItem.age;
                        const targetIdx = this.pointers[targetAge];
                        
                        // Set Pointers: Source active, Target highlighted
                        this.updatePointerVisuals(ageGroup, targetAge, completedGroups);

                        this.log(`SWAPPING ${currIdx} <-> ${targetIdx}`);

                        // THE PHYSICAL SWAP (FLIP)
                        const allAvatars = document.querySelectorAll('.avatar');
                        flipper.read(allAvatars); // Record Start

                        // Perform Swap in Data
                        this.swapData(currIdx, targetIdx);

                        // Perform Swap in DOM
                        this.swapDom(currIdx, targetIdx);

                        await flipper.play(allAvatars, CONFIG.delay.move); // Animate

                        // UPDATE STATE
                        // The item we moved to targetIdx is now in its correct place.
                        this.markLocked(targetIdx);
                        this.pointers[targetAge]++;
                        
                        // Cleanup visual styles
                        avatarEl.classList.remove('inspecting');

                        await wait(CONFIG.delay.step);
                    }
                    
                    // Group is complete
                    completedGroups.add(ageGroup);
                }
                
                // Final state update
                this.updatePointerVisuals(null, null, completedGroups);
            }

            updatePointerVisuals(sourceAge, targetAge, completedSet) {
                // Reset all
                document.querySelectorAll('.pointer-arrow').forEach(el => {
                    el.classList.remove('source', 'target', 'done');
                });

                // Apply Done
                if (completedSet) {
                    completedSet.forEach(age => {
                        const el = document.getElementById(`arrow-${age}`);
                        if(el) el.classList.add('done');
                    });
                }

                // Apply Source (Current Iterator)
                if (sourceAge !== null && sourceAge !== undefined) {
                    const el = document.getElementById(`arrow-${sourceAge}`);
                    if(el) {
                        el.classList.remove('done');
                        el.classList.add('source');
                    }
                }

                // Apply Target (Destination)
                if (targetAge !== null && targetAge !== undefined) {
                    const el = document.getElementById(`arrow-${targetAge}`);
                    if(el) {
                        el.classList.remove('done');
                        el.classList.add('target');
                    }
                }
            }

            swapData(i, j) {
                const temp = this.arr[i];
                this.arr[i] = this.arr[j];
                this.arr[j] = temp;
            }

            swapDom(i, j) {
                const slotI = document.getElementById(`slot-${i}`);
                const slotJ = document.getElementById(`slot-${j}`);
                const avI = slotI.querySelector('.avatar');
                const avJ = slotJ.querySelector('.avatar');

                // Simply append switches them because they are nodes
                slotI.appendChild(avJ);
                slotJ.appendChild(avI);
            }

            markLocked(idx) {
                const slot = document.getElementById(`slot-${idx}`);
                const av = slot.querySelector('.avatar');
                av.classList.add('locked');
            }

            /* --- PHASE 4: CLEANUP --- */
            async phaseCleanup() {
                this.log("SORT COMPLETE. VERIFYING INTEGRITY...");
                document.querySelectorAll('.pointer-arrow').forEach(el => el.classList.remove('active', 'source', 'target'));
                
                await wait(500);
                
                // Flash Effect
                const avatars = document.querySelectorAll('.avatar');
                avatars.forEach(av => {
                    av.style.transition = '0.1s';
                    av.style.background = 'var(--term)';
                    av.style.color = 'var(--void)';
                });
                
                await wait(200);

                avatars.forEach(av => {
                    av.style.background = ''; // Revert to locked style
                    av.style.color = ''; 
                });

                this.log("SYSTEM HALTED. DATA SORTED.");
            }

            async run() {
                await wait(1000);
                await this.phaseScan();
                await this.phaseOffsets();
                await this.phaseSwap();
                await this.phaseCleanup();
            }
        }

        // Boot
        window.onload = () => {
            new App();
        };

    </script>
</body>
</html>