<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SET_INTERSECTION // DITHERPUNK_VISUALIZER</title>
    <style>
        :root {
            --bg: #050505;
            --fg: #00FF41;
            
            /* Responsive Calculations */
            /* Cells will be between 40px and 80px depending on viewport width */
            --cell-size: clamp(40px, 8vw, 80px);
            --gap: clamp(8px, 1.5vw, 20px);
            
            --font-base: clamp(16px, 2vw, 20px);
            --font-lg: clamp(1.2rem, 4vw, 2.5rem);
        }

        /* --- GLOBAL RESET & CRT BASE --- */
        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            padding: clamp(10px, 5vh, 40px);
            background-color: var(--bg);
            color: var(--fg);
            font-family: 'Courier New', 'VT323', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Allow scrolling on small screens if content overflows vertically */
            overflow-x: hidden;
            overflow-y: auto; 
            text-transform: uppercase;
        }

        /* CRT Scanline Overlay - Fixed to cover viewport regardless of scroll */
        body::after {
            content: "";
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(
                rgba(18, 16, 16, 0) 50%, 
                rgba(0, 0, 0, 0.25) 50%
            ), linear-gradient(
                90deg, 
                rgba(255, 0, 0, 0.06), 
                rgba(0, 255, 0, 0.02), 
                rgba(0, 0, 255, 0.06)
            );
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
            z-index: 999;
        }

        h1 {
            text-shadow: 0 0 5px var(--fg);
            margin: 0 0 2rem 0;
            font-size: var(--font-lg);
            border-bottom: 2px solid var(--fg);
            padding-bottom: 10px;
            width: 100%;
            max-width: 1000px;
            text-align: center;
            flex-shrink: 0;
        }

        /* --- LAYOUT ZONES --- */
        .main-interface {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1200px; /* Cap width for ultrawides */
            position: relative;
            z-index: 10;
            flex-grow: 1;
            justify-content: center;
        }

        .zone {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 1vh 0;
            min-height: calc(var(--cell-size) * 2); /* Reserve space for pointers */
        }

        .label {
            position: absolute;
            left: 5%; /* Responsive positioning */
            font-weight: bold;
            font-size: var(--font-base);
            transform: translateY(-50%);
            top: 50%;
        }

        /* Mobile adjustment for labels */
        @media (max-width: 600px) {
            .label {
                position: static;
                margin-right: 1rem;
                width: 40px;
            }
            .zone {
                justify-content: flex-start;
            }
        }

        /* --- ARRAYS & CELLS --- */
        .array-container {
            display: flex;
            gap: var(--gap);
            position: relative;
            /* Ensure pointer tracks align with this container */
            padding: 0 10px; 
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 2px solid var(--fg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: calc(var(--cell-size) * 0.5); /* Font scales with cell */
            font-weight: bold;
            background-color: var(--bg);
            transition: all 0.2s;
            position: relative;
            flex-shrink: 0; /* Prevent squishing */
        }

        /* STATE: Active (Comparing) - Inverted */
        .cell.active {
            background-color: var(--fg);
            color: var(--bg);
            box-shadow: 0 0 15px var(--fg);
        }

        /* STATE: Processed - Dithered Pattern */
        .cell.processed {
            color: var(--fg);
            border-color: var(--fg);
            background-image: repeating-linear-gradient(
                45deg,
                var(--bg),
                var(--bg) 4px,
                var(--fg) 4px,
                var(--fg) 5px
            );
            opacity: 0.7;
        }

        /* STATE: Match - Blinking */
        .cell.match {
            animation: blink-invert 0.5s linear infinite;
            border: 4px double var(--fg);
        }

        @keyframes blink-invert {
            0% { background-color: var(--bg); color: var(--fg); }
            50% { background-color: var(--fg); color: var(--bg); }
            100% { background-color: var(--bg); color: var(--fg); }
        }

        /* --- POINTERS --- */
        /* Pointers are now absolutely positioned relative to the array-container's parent (the zone) */
        .pointer-container {
            position: relative;
            width: fit-content;
            margin: 0 auto;
        }

        .pointer-track {
            position: absolute;
            left: 0;
            width: 100%;
            height: 0; /* Don't take up flow space */
        }

        .pointer {
            position: absolute;
            width: var(--cell-size);
            text-align: center;
            font-size: calc(var(--cell-size) * 0.4);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.2s;
            will-change: transform;
            height: 30px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* --- COMPARISON OPERATOR --- */
        .operator-zone {
            height: clamp(40px, 10vh, 80px);
            min-height: auto;
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: bold;
            text-shadow: 0 0 10px var(--fg);
        }

        /* --- RESULT AREA --- */
        .result-container {
            min-height: var(--cell-size);
            min-width: calc(var(--cell-size) * 3); /* Minimum width for aesthetics */
            display: flex;
            gap: var(--gap);
            border: 1px dashed var(--fg);
            padding: 10px;
            justify-content: center;
            position: relative;
            flex-wrap: wrap; /* Allow wrapping if results get long */
        }

        .result-container::before {
            content: "LAST_INSERT";
            position: absolute;
            top: -1.2em;
            right: 0;
            font-size: 0.7rem;
            background: var(--bg);
            padding: 0 5px;
        }

        /* Floating number animation class */
        .floater {
            position: fixed;
            z-index: 50;
            border: 2px solid var(--fg);
            background: var(--fg);
            color: var(--bg);
            width: var(--cell-size);
            height: var(--cell-size);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: calc(var(--cell-size) * 0.5);
            transition: top 0.8s ease-in-out, left 0.8s ease-in-out;
            pointer-events: none;
        }

        /* X Overlay for Duplicate */
        .duplicate-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(2rem, 5vw, 4rem);
            color: var(--fg);
            background: repeating-linear-gradient(
                135deg,
                rgba(0,0,0,0.8),
                rgba(0,0,0,0.8) 10px,
                var(--fg) 10px,
                var(--fg) 11px
            );
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 20;
        }
        .duplicate-overlay.visible {
            opacity: 1;
        }

        /* --- LOG TERMINAL --- */
        .log-terminal {
            margin-top: 2rem;
            width: 100%;
            max-width: 800px;
            height: 15vh;
            min-height: 100px;
            border: 2px solid var(--fg);
            background: #000;
            padding: 10px;
            overflow-y: auto;
            font-size: clamp(0.8rem, 1.5vw, 1rem);
            display: flex;
            flex-direction: column-reverse; 
        }

        .log-entry { margin-bottom: 4px; line-height: 1.4; }
        .log-entry::before { content: "> "; }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg); border-left: 1px solid var(--fg); }
        ::-webkit-scrollbar-thumb { background: var(--fg); }

        /* --- CONTROLS --- */
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            padding-bottom: 20px;
        }

        button {
            background: var(--bg);
            color: var(--fg);
            border: 2px solid var(--fg);
            padding: 10px 20px;
            font-family: inherit;
            font-size: var(--font-base);
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 4px 4px 0 var(--fg);
            transition: transform 0.1s, box-shadow 0.1s;
            flex: 0 1 auto;
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--fg);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-image: repeating-linear-gradient(45deg, var(--bg), var(--bg) 2px, var(--fg) 2px, var(--fg) 3px);
            box-shadow: none;
            transform: translate(2px, 2px);
        }

    </style>
</head>
<body>

    <h1>SET_INTERSECTION<span style="font-size:0.5em; vertical-align: top;">[v2.1]</span></h1>

    <div class="main-interface">
        
        <!-- Zone 1: Array A -->
        <div class="zone">
            <div class="label">A []</div>
            <div class="pointer-container">
                <div class="pointer-track" style="top: -120%;"> <!-- Relative top -->
                    <div id="ptr-i" class="pointer" style="left: 0;">v<br>i</div>
                </div>
                <div class="array-container" id="container-a">
                    <!-- Cells generated by JS -->
                </div>
            </div>
        </div>

        <!-- Comparison Zone -->
        <div class="zone operator-zone">
            <div class="label">CMP</div>
            <div id="operator-display"></div>
        </div>

        <!-- Zone 2: Array B -->
        <div class="zone">
            <div class="label">B []</div>
            <div class="pointer-container">
                <div class="array-container" id="container-b">
                    <!-- Cells generated by JS -->
                </div>
                <div class="pointer-track" style="bottom: -120%;">
                    <div id="ptr-j" class="pointer" style="left: 0;">^<br>j</div>
                </div>
            </div>
        </div>

        <!-- Spacer -->
        <div style="height: 2vh;"></div>

        <!-- Zone 3: Result -->
        <div class="zone">
            <div class="label">RES</div>
            <div class="result-container" id="container-res">
                <div class="duplicate-overlay" id="dup-overlay">X</div>
                <!-- Result cells go here -->
            </div>
        </div>

        <!-- Zone 4: Log -->
        <div class="log-terminal" id="logger">
            <div class="log-entry">System Initialized. Ready.</div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button id="btn-step" onclick="visualizer.next()">STEP EXECUTION</button>
            <button id="btn-reset" onclick="visualizer.init()">SYSTEM RESET</button>
        </div>
    </div>

    <script>
        class DitherVisualizer {
            constructor() {
                this.arrayA = [1, 3, 3, 5];
                this.arrayB = [3, 3, 5, 7];
                this.i = 0;
                this.j = 0;
                this.result = [];
                
                this.state = 'IDLE'; 
                
                // DOM Elements
                this.elContainerA = document.getElementById('container-a');
                this.elContainerB = document.getElementById('container-b');
                this.elContainerRes = document.getElementById('container-res');
                this.elPtrI = document.getElementById('ptr-i');
                this.elPtrJ = document.getElementById('ptr-j');
                this.elOp = document.getElementById('operator-display');
                this.elLog = document.getElementById('logger');
                this.elBtnStep = document.getElementById('btn-step');
                this.elDupOverlay = document.getElementById('dup-overlay');

                // Bind resize to update pointers dynamically
                window.addEventListener('resize', () => {
                    requestAnimationFrame(() => this.updatePointers());
                });

                this.init();
            }

            log(msg) {
                const div = document.createElement('div');
                div.className = 'log-entry';
                div.innerText = msg;
                this.elLog.prepend(div);
            }

            renderArray(container, data) {
                container.innerHTML = '';
                data.forEach(val => {
                    const el = document.createElement('div');
                    el.className = 'cell';
                    el.innerText = val;
                    container.appendChild(el);
                });
            }

            // COMPLETELY REWRITTEN FOR RESPONSIVENESS
            // Uses DOM geometry instead of hardcoded constants
            updatePointers() {
                const updatePointer = (index, arrayLen, container, ptrEl) => {
                    if (index < arrayLen) {
                        const targetCell = container.children[index];
                        if (targetCell) {
                            // Calculate position relative to the container
                            const cellLeft = targetCell.offsetLeft;
                            // Center the pointer: cell left + half cell width - half pointer width
                            const pos = cellLeft; 
                            
                            ptrEl.style.transform = `translateX(${pos}px)`;
                            ptrEl.style.opacity = 1;
                        }
                    } else {
                        // If index is out of bounds, fade out or move to end
                        ptrEl.style.opacity = 0;
                    }
                };

                updatePointer(this.i, this.arrayA.length, this.elContainerA, this.elPtrI);
                updatePointer(this.j, this.arrayB.length, this.elContainerB, this.elPtrJ);
            }

            init() {
                this.i = 0;
                this.j = 0;
                this.result = [];
                this.state = 'IDLE';
                
                this.renderArray(this.elContainerA, this.arrayA);
                this.renderArray(this.elContainerB, this.arrayB);
                
                // Reset Result Container but keep overlay
                this.elContainerRes.innerHTML = '';
                this.elContainerRes.appendChild(this.elDupOverlay);
                this.elDupOverlay.classList.remove('visible');
                
                this.elOp.innerText = '';
                this.elLog.innerHTML = '';
                this.log("System Initialized. Arrays Loaded.");
                
                this.elBtnStep.disabled = false;
                
                // Wait for layout to settle (CSS clamp/flex)
                requestAnimationFrame(() => this.updatePointers());
            }

            getCell(arrName, index) {
                if(arrName === 'A') return this.elContainerA.children[index];
                if(arrName === 'B') return this.elContainerB.children[index];
                return null;
            }

            next() {
                if (this.i >= this.arrayA.length || this.j >= this.arrayB.length) {
                    this.log("End of Array reached. Execution Complete.");
                    this.elOp.innerText = "END";
                    this.elBtnStep.disabled = true;
                    return;
                }

                const valA = this.arrayA[this.i];
                const valB = this.arrayB[this.j];
                const cellA = this.getCell('A', this.i);
                const cellB = this.getCell('B', this.j);

                // Ensure pointers are perfectly aligned before action
                this.updatePointers();

                switch (this.state) {
                    case 'IDLE':
                        this.log(`Comparing A[${this.i}] (${valA}) vs B[${this.j}] (${valB})...`);
                        cellA.classList.add('active');
                        cellB.classList.add('active');
                        
                        if (valA < valB) this.elOp.innerText = '<';
                        else if (valA > valB) this.elOp.innerText = '>';
                        else this.elOp.innerText = '==';

                        this.state = 'ACTION';
                        break;

                    case 'ACTION':
                        if (valA < valB) {
                            this.log(`A < B (${valA} < ${valB}). Discarding A.`);
                            cellA.classList.remove('active');
                            cellA.classList.add('processed');
                            cellB.classList.remove('active');
                            this.state = 'MOVE_A';
                        } 
                        else if (valA > valB) {
                            this.log(`A > B (${valA} > ${valB}). Discarding B.`);
                            cellB.classList.remove('active');
                            cellB.classList.add('processed');
                            cellA.classList.remove('active');
                            this.state = 'MOVE_B';
                        } 
                        else {
                            this.log(`Match Found (${valA}). Checking Duplicates...`);
                            cellA.classList.add('match');
                            cellB.classList.add('match');

                            const lastVal = this.result.length > 0 ? this.result[this.result.length - 1] : null;

                            if (valA === lastVal) {
                                this.log(`ALERT: Duplicate ${valA} detected. Skipping.`);
                                this.elDupOverlay.classList.add('visible');
                                setTimeout(() => this.elDupOverlay.classList.remove('visible'), 600);
                                this.state = 'MOVE_BOTH';
                            } else {
                                this.log(`Unique Value ${valA}. Inserting.`);
                                this.spawnToResult(cellA, valA);
                                this.result.push(valA);
                                this.state = 'MOVE_BOTH';
                            }
                        }
                        break;

                    case 'MOVE_A':
                        this.i++;
                        this.finishStep();
                        break;

                    case 'MOVE_B':
                        this.j++;
                        this.finishStep();
                        break;

                    case 'MOVE_BOTH':
                        setTimeout(() => {
                            this.i++;
                            this.j++;
                            this.finishStep();
                        }, 800);
                        this.elBtnStep.disabled = true;
                        break;
                }
            }

            finishStep() {
                this.resetCellStates();
                this.updatePointers();
                this.elOp.innerText = '';
                this.state = 'IDLE';
                this.elBtnStep.disabled = false;
            }

            resetCellStates() {
                // Ensure past cells are processed
                for(let k=0; k<this.i; k++) this.getCell('A', k)?.classList.add('processed');
                for(let k=0; k<this.j; k++) this.getCell('B', k)?.classList.add('processed');
                
                // Clear active/match
                Array.from(this.elContainerA.children).forEach(c => c.classList.remove('active', 'match'));
                Array.from(this.elContainerB.children).forEach(c => c.classList.remove('active', 'match'));
            }

            spawnToResult(sourceEl, value) {
                const rect = sourceEl.getBoundingClientRect();
                const floater = document.createElement('div');
                floater.className = 'floater';
                floater.innerText = value;
                
                // Start position
                floater.style.top = rect.top + 'px';
                floater.style.left = rect.left + 'px';
                document.body.appendChild(floater);

                // Calculate destination dynamically
                // We append a temp invisible cell to get the exact flex position
                const tempCell = document.createElement('div');
                tempCell.className = 'cell';
                tempCell.style.visibility = 'hidden';
                tempCell.style.position = 'absolute'; // Don't disrupt flow yet? No, we need flow.
                tempCell.style.position = 'static';
                this.elContainerRes.appendChild(tempCell);
                
                const destRect = tempCell.getBoundingClientRect();
                
                // Force Layout Recalc
                floater.getBoundingClientRect();

                // Animate to destination
                floater.style.top = destRect.top + 'px';
                floater.style.left = destRect.left + 'px';

                // Cleanup
                setTimeout(() => {
                    floater.remove();
                    tempCell.remove(); // Remove temp
                    
                    // Add real cell
                    const newCell = document.createElement('div');
                    newCell.className = 'cell';
                    newCell.innerText = value;
                    this.elContainerRes.appendChild(newCell);
                }, 800);
            }
        }

        const visualizer = new DitherVisualizer();
    </script>
</body>
</html>