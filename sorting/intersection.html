<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SET_INTERSECTION // DITHERPUNK_VISUALIZER</title>
    <style>
        :root {
            --bg: #050505;
            --fg: #00FF41;
            --cell-size: 60px;
            --gap: 15px;
        }

        /* --- GLOBAL RESET & CRT BASE --- */
        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            padding: 20px;
            background-color: var(--bg);
            color: var(--fg);
            font-family: 'Courier New', 'VT323', monospace;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            text-transform: uppercase;
        }

        /* CRT Scanline Overlay */
        body::after {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(
                rgba(18, 16, 16, 0) 50%, 
                rgba(0, 0, 0, 0.25) 50%
            ), linear-gradient(
                90deg, 
                rgba(255, 0, 0, 0.06), 
                rgba(0, 255, 0, 0.02), 
                rgba(0, 0, 255, 0.06)
            );
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
            z-index: 999;
        }

        h1 {
            text-shadow: 0 0 5px var(--fg);
            margin-bottom: 20px;
            font-size: 1.5rem;
            border-bottom: 2px solid var(--fg);
            padding-bottom: 10px;
            width: 100%;
            max-width: 800px;
            text-align: center;
        }

        /* --- LAYOUT ZONES --- */
        .main-interface {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
            position: relative;
            z-index: 10;
        }

        .zone {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 10px 0;
        }

        .label {
            position: absolute;
            left: 0;
            font-weight: bold;
            font-size: 1.2rem;
        }

        /* --- ARRAYS & CELLS --- */
        .array-container {
            display: flex;
            gap: var(--gap);
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 2px solid var(--fg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            background-color: var(--bg);
            transition: all 0.2s;
            position: relative;
        }

        /* STATE: Active (Comparing) - Inverted */
        .cell.active {
            background-color: var(--fg);
            color: var(--bg);
            box-shadow: 0 0 10px var(--fg);
        }

        /* STATE: Processed - Dithered Pattern */
        .cell.processed {
            color: var(--fg);
            border-color: var(--fg);
            /* Dither Pattern: Diagonal Stripes to simulate grey */
            background-image: repeating-linear-gradient(
                45deg,
                var(--bg),
                var(--bg) 4px,
                var(--fg) 4px,
                var(--fg) 5px
            );
            opacity: 0.7;
        }

        /* STATE: Match - Blinking */
        .cell.match {
            animation: blink-invert 0.5s linear infinite;
            border: 4px double var(--fg);
        }

        @keyframes blink-invert {
            0% { background-color: var(--bg); color: var(--fg); }
            50% { background-color: var(--fg); color: var(--bg); }
            100% { background-color: var(--bg); color: var(--fg); }
        }

        /* --- POINTERS --- */
        .pointer-track {
            height: 30px;
            width: 100%; /* Matches array width dynamically via JS width setting or logic */
            position: relative;
            display: flex;
            justify-content: center;
        }

        .pointer {
            position: absolute;
            width: var(--cell-size);
            text-align: center;
            font-size: 1.5rem;
            transition: left 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            /* Initial left is calculated in JS */
        }

        /* --- COMPARISON OPERATOR --- */
        .operator-zone {
            height: 60px;
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 0 0 10px var(--fg);
        }

        /* --- RESULT AREA --- */
        .result-container {
            min-height: var(--cell-size);
            display: flex;
            gap: var(--gap);
            border: 1px dashed var(--fg);
            padding: 10px;
            min-width: 300px;
            justify-content: center;
            position: relative;
        }

        /* Ghost outline for duplicate check */
        .result-container::before {
            content: "LAST_INSERT";
            position: absolute;
            top: -15px;
            right: 0;
            font-size: 0.7rem;
            background: var(--bg);
            padding: 0 5px;
        }

        /* Floating number animation class */
        .floater {
            position: fixed;
            z-index: 50;
            border: 2px solid var(--fg);
            background: var(--fg);
            color: var(--bg);
            width: var(--cell-size);
            height: var(--cell-size);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: top 0.8s ease-in-out, left 0.8s ease-in-out;
        }

        /* X Overlay for Duplicate */
        .duplicate-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            color: var(--fg);
            background: repeating-linear-gradient(
                135deg,
                rgba(0,0,0,0.8),
                rgba(0,0,0,0.8) 10px,
                var(--fg) 10px,
                var(--fg) 11px
            );
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        .duplicate-overlay.visible {
            opacity: 1;
        }

        /* --- LOG TERMINAL --- */
        .log-terminal {
            margin-top: 20px;
            width: 100%;
            height: 150px;
            border: 2px solid var(--fg);
            background: #000;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column-reverse; /* New logs at bottom, but stick to bottom */
        }

        .log-entry {
            margin-bottom: 4px;
        }
        .log-entry::before { content: "> "; }

        /* Scrollbar styling for ditherpunk feel */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: var(--bg); border-left: 1px solid var(--fg); }
        ::-webkit-scrollbar-thumb { background: var(--fg); }

        /* --- CONTROLS --- */
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 20px;
        }

        button {
            background: var(--bg);
            color: var(--fg);
            border: 2px solid var(--fg);
            padding: 10px 20px;
            font-family: inherit;
            font-size: 1.2rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 4px 4px 0 var(--fg);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--fg);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            /* Dithered disabled state */
            background-image: repeating-linear-gradient(45deg, var(--bg), var(--bg) 2px, var(--fg) 2px, var(--fg) 3px);
        }

    </style>
</head>
<body>

    <h1>SET_INTERSECTION<span style="font-size:0.5em; vertical-align: top;">[v2.0]</span></h1>

    <div class="main-interface">
        
        <!-- Zone 1: Array A -->
        <div class="zone">
            <div class="label">A []</div>
            <div class="pointer-track" style="position: absolute; top: -25px;">
                <div id="ptr-i" class="pointer" style="left: 0;">v<br>i</div>
            </div>
            <div class="array-container" id="container-a">
                <!-- Cells generated by JS -->
            </div>
        </div>

        <!-- Comparison Zone -->
        <div class="zone operator-zone">
            <div class="label">CMP</div>
            <div id="operator-display"></div>
        </div>

        <!-- Zone 2: Array B -->
        <div class="zone">
            <div class="label">B []</div>
            <div class="array-container" id="container-b">
                <!-- Cells generated by JS -->
            </div>
            <div class="pointer-track" style="position: absolute; bottom: -25px;">
                <div id="ptr-j" class="pointer" style="left: 0;">^<br>j</div>
            </div>
        </div>

        <!-- Spacer -->
        <div style="height: 30px;"></div>

        <!-- Zone 3: Result -->
        <div class="zone">
            <div class="label">RES</div>
            <div class="result-container" id="container-res">
                <div class="duplicate-overlay" id="dup-overlay">X</div>
                <!-- Result cells go here -->
            </div>
        </div>

        <!-- Zone 4: Log -->
        <div class="log-terminal" id="logger">
            <div class="log-entry">System Initialized. Ready for input.</div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button id="btn-step" onclick="visualizer.next()">STEP EXECUTION</button>
            <button id="btn-reset" onclick="visualizer.init()">SYSTEM RESET</button>
        </div>
    </div>

    <script>
        class DitherVisualizer {
            constructor() {
                this.arrayA = [1, 3, 3, 5];
                this.arrayB = [3, 3, 5, 7];
                this.i = 0;
                this.j = 0;
                this.result = [];
                
                // Visualization constants
                this.cellSize = 60;
                this.gap = 15;
                this.baseOffset = 0; // Calculated based on centering

                // State Machine: 'IDLE' -> 'COMPARE' -> 'ACTION' -> 'MOVE'
                this.state = 'IDLE'; 
                
                // DOM Elements
                this.elContainerA = document.getElementById('container-a');
                this.elContainerB = document.getElementById('container-b');
                this.elContainerRes = document.getElementById('container-res');
                this.elPtrI = document.getElementById('ptr-i');
                this.elPtrJ = document.getElementById('ptr-j');
                this.elOp = document.getElementById('operator-display');
                this.elLog = document.getElementById('logger');
                this.elBtnStep = document.getElementById('btn-step');
                this.elDupOverlay = document.getElementById('dup-overlay');

                this.init();
            }

            log(msg) {
                const div = document.createElement('div');
                div.className = 'log-entry';
                div.innerText = msg;
                this.elLog.prepend(div);
            }

            renderArray(container, data) {
                container.innerHTML = '';
                data.forEach(val => {
                    const el = document.createElement('div');
                    el.className = 'cell';
                    el.innerText = val;
                    container.appendChild(el);
                });
            }

            updatePointers() {
                // To center pointers over cells, we need to know cell positions relative to container
                // but since we use flex gap, we can calculate strictly.
                // However, to be safe against flex centering, let's use layout math.
                
                // Reset styling first
                const cellsA = this.elContainerA.children;
                const cellsB = this.elContainerB.children;

                // Calculate Position I
                if (this.i < this.arrayA.length) {
                    const currentCell = cellsA[this.i];
                    // The pointer container is full width of zone. We need offset relative to zone start.
                    // Simplified: Since centered, we can calculate offset from first cell
                    const firstCell = cellsA[0];
                    const offset = (this.i * (this.cellSize + this.gap));
                    
                    // We need to visually center the pointer track relative to the flex container
                    // But simpler: Move pointer inside a relative container that matches array width exactly?
                    // Let's use getBoundingClientRect for absolute precision relative to viewport, 
                    // then adjust for the relative parent.
                    
                    // Quick fix: Set pointer track width to 0 and overflow visible, centered in zone.
                    // Actually, let's stick to the calculated logic assuming CSS is stable.
                    // The Pointer Track is absolute. Let's align it with the first cell.
                    
                    // Better approach: Calculate relative to start of array container.
                    this.elPtrI.style.transform = `translateX(${offset}px)`;
                    this.elPtrI.style.opacity = 1;
                } else {
                    // Out of bounds
                    this.elPtrI.style.opacity = 0;
                }

                // Calculate Position J
                if (this.j < this.arrayB.length) {
                    const offset = (this.j * (this.cellSize + this.gap));
                    this.elPtrJ.style.transform = `translateX(${offset}px)`;
                    this.elPtrJ.style.opacity = 1;
                } else {
                    this.elPtrJ.style.opacity = 0;
                }
            }

            init() {
                this.i = 0;
                this.j = 0;
                this.result = [];
                this.state = 'IDLE';
                
                this.renderArray(this.elContainerA, this.arrayA);
                this.renderArray(this.elContainerB, this.arrayB);
                this.elContainerRes.innerHTML = '<div class="duplicate-overlay" id="dup-overlay">X</div>'; // preserve overlay
                this.elDupOverlay = document.getElementById('dup-overlay');
                
                this.elOp.innerText = '';
                this.elLog.innerHTML = '';
                this.log("System Initialized. Arrays Loaded.");
                
                this.updatePointers();
                this.elBtnStep.disabled = false;
                
                // Align pointers initially
                // Hack: Wait for layout
                setTimeout(() => this.updatePointers(), 50);
            }

            getCell(arrName, index) {
                if(arrName === 'A') return this.elContainerA.children[index];
                if(arrName === 'B') return this.elContainerB.children[index];
                return null;
            }

            // The main state machine
            next() {
                if (this.i >= this.arrayA.length || this.j >= this.arrayB.length) {
                    this.log("End of Array reached. Execution Complete.");
                    this.elOp.innerText = "END";
                    this.elBtnStep.disabled = true;
                    return;
                }

                const valA = this.arrayA[this.i];
                const valB = this.arrayB[this.j];
                const cellA = this.getCell('A', this.i);
                const cellB = this.getCell('B', this.j);

                switch (this.state) {
                    case 'IDLE':
                        // Transition to COMPARE
                        this.log(`Comparing A[${this.i}] (${valA}) vs B[${this.j}] (${valB})...`);
                        
                        // Highlight Active
                        cellA.classList.add('active');
                        cellB.classList.add('active');

                        // Set Operator
                        if (valA < valB) this.elOp.innerText = '<';
                        else if (valA > valB) this.elOp.innerText = '>';
                        else this.elOp.innerText = '==';

                        this.state = 'ACTION';
                        break;

                    case 'ACTION':
                        // Handle Logic based on values
                        if (valA < valB) {
                            this.log(`A < B. Value ${valA} is smaller. Discarding.`);
                            cellA.classList.remove('active');
                            cellA.classList.add('processed');
                            cellB.classList.remove('active'); // B goes back to idle
                            this.state = 'MOVE_A';
                        } 
                        else if (valA > valB) {
                            this.log(`A > B. Value ${valB} is smaller. Discarding.`);
                            cellB.classList.remove('active');
                            cellB.classList.add('processed');
                            cellA.classList.remove('active'); // A goes back to idle
                            this.state = 'MOVE_B';
                        } 
                        else {
                            // Match
                            this.log(`Match Found (${valA}). Checking for Duplicates in Result...`);
                            cellA.classList.add('match');
                            cellB.classList.add('match');

                            // Duplicate Check Logic
                            const lastVal = this.result.length > 0 ? this.result[this.result.length - 1] : null;

                            if (valA === lastVal) {
                                this.log(`ALERT: Duplicate ${valA} detected in Result. Ignoring.`);
                                // Trigger Error Visual
                                this.elDupOverlay.classList.add('visible');
                                setTimeout(() => this.elDupOverlay.classList.remove('visible'), 600);
                                this.state = 'MOVE_BOTH';
                            } else {
                                this.log(`Unique Value ${valA}. Adding to Result.`);
                                this.spawnToResult(cellA, valA);
                                this.result.push(valA);
                                this.state = 'MOVE_BOTH';
                            }
                        }
                        break;

                    case 'MOVE_A':
                        this.i++;
                        this.resetCellStates();
                        this.updatePointers();
                        this.elOp.innerText = '';
                        this.state = 'IDLE';
                        break;

                    case 'MOVE_B':
                        this.j++;
                        this.resetCellStates();
                        this.updatePointers();
                        this.elOp.innerText = '';
                        this.state = 'IDLE';
                        break;

                    case 'MOVE_BOTH':
                        // Wait for animation if needed (duplicate blink or spawn)
                        // Simple timeout to allow visual to register
                        setTimeout(() => {
                            this.i++;
                            this.j++;
                            this.resetCellStates();
                            this.updatePointers();
                            this.elOp.innerText = '';
                            this.state = 'IDLE';
                        }, 800);
                        // Prevent clicking while waiting
                        this.elBtnStep.disabled = true;
                        setTimeout(() => this.elBtnStep.disabled = false, 850);
                        break;
                }
            }

            resetCellStates() {
                // Remove active/match classes, keep processed
                // Actually, if we moved past an index, ensure it is visually processed
                for(let k=0; k<this.i; k++) this.getCell('A', k)?.classList.add('processed');
                for(let k=0; k<this.j; k++) this.getCell('B', k)?.classList.add('processed');
                
                // Clear active/match from current (now previous)
                Array.from(this.elContainerA.children).forEach(c => {
                    c.classList.remove('active', 'match');
                });
                Array.from(this.elContainerB.children).forEach(c => {
                    c.classList.remove('active', 'match');
                });
            }

            spawnToResult(sourceEl, value) {
                // Create floater
                const rect = sourceEl.getBoundingClientRect();
                const floater = document.createElement('div');
                floater.className = 'floater';
                floater.innerText = value;
                floater.style.top = rect.top + 'px';
                floater.style.left = rect.left + 'px';
                document.body.appendChild(floater);

                // Target position (approximate end of result container)
                // We need to calculate where the NEW cell will be.
                // It will be appended to container-res.
                const resRect = this.elContainerRes.getBoundingClientRect();
                // Determine offset based on current children count (excluding overlay)
                const currentCount = this.result.length;
                const targetLeft = resRect.left + 10 + (currentCount * (this.cellSize + this.gap));
                const targetTop = resRect.top + 10; // Padding

                // Force reflow
                floater.getBoundingClientRect();

                // Animate
                floater.style.top = targetTop + 'px';
                floater.style.left = targetLeft + 'px';

                // On Finish
                setTimeout(() => {
                    floater.remove();
                    const newCell = document.createElement('div');
                    newCell.className = 'cell';
                    newCell.innerText = value;
                    this.elContainerRes.appendChild(newCell);
                }, 800);
            }
        }

        // Initialize
        const visualizer = new DitherVisualizer();
        
        // Window Resize fix for pointers
        window.addEventListener('resize', () => {
            visualizer.updatePointers();
        });

    </script>
</body>
</html>