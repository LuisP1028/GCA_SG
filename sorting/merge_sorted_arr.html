<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Protocol: Backward Merge // Ditherpunk // Responsive</title>
    <style>
        /* --- 1. CORE AESTHETICS & VARIABLES --- */
        :root {
            --c-void: #050505;
            --c-term: #33FF00;
            --c-dim: #1A5510;
            --c-ghost: #112211;
            --font-stack: 'Courier New', 'VT323', monospace;
            
            /* Responsive Sizing Logic:
               Base block size scales between 35px and 80px depending on viewport width.
            */
            --block-size: clamp(35px, 9vw, 80px); 
            --gap-size: clamp(4px, 1.5vw, 15px);
            --ui-gap: clamp(10px, 2vw, 20px);
            
            --fs-base: clamp(0.9rem, 1.5vw, 1.2rem);
            --fs-block: calc(var(--block-size) * 0.5);
            
            --border-width: clamp(1px, 0.2vw, 3px);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: clamp(10px, 3vw, 30px);
            background-color: var(--c-void);
            color: var(--c-term);
            font-family: var(--font-stack);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow-x: hidden;
            text-transform: uppercase;
        }

        /* --- CRT / DITHER TEXTURE OVERLAY --- */
        body::before {
            content: " ";
            position: fixed;
            inset: 0; /* Shorthand for top/right/bottom/left: 0 */
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 999;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        @keyframes flicker {
            0% { opacity: 0.97; }
            5% { opacity: 0.95; }
            10% { opacity: 0.9; }
            15% { opacity: 0.95; }
            100% { opacity: 0.97; }
        }
        
        .container {
            width: 100%;
            max-width: 1200px; /* Cap width on ultrawide monitors */
            position: relative;
            z-index: 1;
            animation: flicker 0.15s infinite;
            display: flex;
            flex-direction: column;
            gap: clamp(1.5rem, 4vw, 3rem);
        }

        h1 {
            text-align: center;
            font-size: clamp(1.2rem, 5vw, 2.5rem);
            text-shadow: 2px 2px 0px var(--c-dim);
            border-bottom: var(--border-width) dashed var(--c-term);
            padding-bottom: 0.5em;
            margin: 0;
            letter-spacing: 2px;
            word-break: break-word;
        }

        /* --- 2. VISUAL SETUP (THE TRACKS) --- */
        .stage {
            display: flex;
            flex-direction: column;
            gap: calc(var(--block-size) * 1.2); /* Space for pointers relative to block size */
            padding: clamp(10px, 2vw, 20px);
            border: var(--border-width) solid var(--c-term);
            background: 
                repeating-linear-gradient(
                    45deg,
                    var(--c-void),
                    var(--c-void) 2px,
                    #0a0a0a 2px,
                    #0a0a0a 4px
                );
            position: relative;
            /* Ensure container doesn't overflow on small screens */
            width: 100%;
        }

        .track-label {
            font-weight: bold;
            font-size: var(--fs-base);
            display: flex;
            justify-content: space-between;
            position: absolute;
            top: 5px;
            left: 10px;
            right: 10px;
            opacity: 0.8;
        }

        .array-row {
            display: flex;
            justify-content: center; 
            gap: var(--gap-size);
            position: relative;
            margin-top: calc(var(--fs-base) * 1.5);
            height: var(--block-size);
            width: 100%;
        }

        /* BLOCKS */
        .block {
            width: var(--block-size);
            height: var(--block-size);
            flex-shrink: 0; 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--fs-block);
            font-weight: bold;
            transition: background 0.1s, color 0.1s;
            position: relative;
            z-index: 2;
        }

        /* Solid Data Block */
        .block.filled {
            background: var(--c-term);
            color: var(--c-void);
            border: var(--border-width) solid var(--c-term);
            box-shadow: calc(var(--border-width)*2) calc(var(--border-width)*2) 0px var(--c-dim);
        }

        /* Ghost/Buffer Block */
        .block.ghost {
            background: var(--c-void);
            color: var(--c-dim);
            border: var(--border-width) dashed var(--c-dim);
            background-image: radial-gradient(var(--c-dim) 15%, transparent 16%);
            background-size: 4px 4px;
        }

        /* Highlight State */
        .block.highlight {
            background: #FFF;
            color: #000;
            border-color: #FFF;
            box-shadow: 0 0 15px #FFF;
            z-index: 10;
        }

        /* Locked State */
        .block.locked {
            background: var(--c-dim);
            color: var(--c-term);
            border: var(--border-width) solid var(--c-term);
            background-image: 
                linear-gradient(45deg, var(--c-ghost) 25%, transparent 25%), 
                linear-gradient(-45deg, var(--c-ghost) 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, var(--c-ghost) 75%), 
                linear-gradient(-45deg, transparent 75%, var(--c-ghost) 75%);
            background-size: 4px 4px;
        }

        /* Flying Block */
        .flying-block {
            position: fixed; /* Fixed relative to viewport for accurate flight */
            width: var(--block-size);
            height: var(--block-size);
            background: var(--c-term);
            color: var(--c-void);
            border: var(--border-width) solid #FFF;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: var(--fs-block);
            z-index: 50;
            box-shadow: 10px 10px 0 rgba(0,0,0,0.5);
            pointer-events: none;
            will-change: top, left;
        }

        /* --- POINTERS --- */
        .pointer {
            position: absolute;
            width: var(--block-size); /* Matches block width exactly */
            height: calc(var(--block-size) * 0.8);
            text-align: center;
            transition: left 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28), opacity 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: clamp(0.6rem, 1.2vw, 0.8rem);
            color: var(--c-term);
            z-index: 20;
            white-space: nowrap;
        }

        .pointer span {
            background: var(--c-void);
            padding: 1px 3px;
            border: 1px solid var(--c-dim);
            line-height: 1;
        }

        .pointer i {
            font-style: normal;
            font-size: 1.2em;
            font-weight: bold;
            display: block;
            line-height: 1;
            margin: 2px 0;
        }

        /* --- SAFETY ZONE --- */
        .safety-zone {
            position: absolute;
            height: calc(100% + 10px);
            top: -5px;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 5px,
                var(--c-dim) 5px,
                var(--c-dim) 10px
            );
            opacity: 0.5;
            z-index: 1;
            transition: left 0.2s, width 0.2s;
            cursor: help;
        }

        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--c-term);
            color: var(--c-void);
            padding: 5px;
            font-size: 0.7rem;
            width: max-content;
            max-width: 200px;
            text-align: center;
            display: none;
            border: 2px solid var(--c-void);
            box-shadow: 4px 4px 0 var(--c-dim);
            pointer-events: none;
            z-index: 100;
        }

        .safety-zone:hover .tooltip { display: block; }

        /* --- 3. LOG & CONTROLS --- */
        .ui-panel {
            display: grid;
            gap: var(--ui-gap);
            grid-template-columns: 1fr; /* Default mobile stack */
        }
        
        /* Tablet & Desktop: Side by Side */
        @media(min-width: 768px) {
            .ui-panel { grid-template-columns: 2fr 1fr; }
        }

        .console {
            border: var(--border-width) solid var(--c-dim);
            background: #000;
            height: clamp(100px, 20vh, 150px);
            overflow-y: auto;
            padding: 10px;
            font-size: 0.85rem;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.9);
        }

        .log-entry { margin-bottom: 4px; word-break: break-word; }
        .log-entry::before { content: "> "; color: var(--c-dim); }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: var(--c-ghost);
            padding: 10px;
            border: var(--border-width) solid var(--c-term);
            justify-content: center;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap; /* Allow wrapping on very small screens */
        }

        button {
            background: var(--c-void);
            color: var(--c-term);
            border: var(--border-width) solid var(--c-term);
            padding: 10px 12px;
            font-family: var(--font-stack);
            font-size: var(--fs-base);
            cursor: pointer;
            box-shadow: 4px 4px 0 var(--c-dim);
            flex: 1; /* Grow to fill space */
            min-width: 70px;
            touch-action: manipulation;
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--c-dim);
        }

        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.8rem;
            justify-content: center;
            margin-top: 5px;
        }
        
        input[type=range] {
            -webkit-appearance: none; 
            width: 100%; 
            background: transparent; 
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 15px;
            width: 15px;
            background: var(--c-term);
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 1px 1px 0 #000;
        }
        
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 3px;
            background: var(--c-dim);
            border: 1px solid var(--c-term);
        }

    </style>
</head>
<body>

    <div class="container">
        <h1>BACKWARD_MERGE.EXE</h1>

        <!-- Track A -->
        <div class="stage">
            <div class="track-label">
                <span>MEM_A</span> 
                <span style="opacity:0.5">[DATA+BUFFER]</span>
            </div>
            <div class="array-row" id="row-a">
                <!-- Safety Zone injected here -->
                <div id="safety-zone" class="safety-zone">
                    <div class="tooltip">PROTECTED REGION</div>
                </div>
                <!-- Pointers injected here -->
                <div id="ptr-write" class="pointer" style="top: calc(var(--block-size) * -1.1);">
                    <i>V</i>
                    <span>WRITE</span>
                </div>
                <div id="ptr-a" class="pointer" style="bottom: calc(var(--block-size) * -1.1);">
                    <span>PTR_A</span>
                    <i>^</i>
                </div>
            </div>
        </div>

        <!-- Track B -->
        <div class="stage">
            <div class="track-label">
                <span>MEM_B</span>
                <span style="opacity:0.5">[INCOMING]</span>
            </div>
            <div class="array-row" id="row-b">
                <div id="ptr-b" class="pointer" style="top: calc(var(--block-size) * -1.1);">
                    <i>V</i>
                    <span>PTR_B</span>
                </div>
            </div>
        </div>

        <!-- UI Panel -->
        <div class="ui-panel">
            <div class="console" id="console-output">
                <div class="log-entry">SYSTEM READY.</div>
                <div class="log-entry">VIEWPORT ADAPTIVE MODE: ACTIVE.</div>
            </div>

            <div class="controls">
                <div class="btn-group">
                    <button id="btn-play">PLAY</button>
                    <button id="btn-step">STEP</button>
                    <button id="btn-reset">RESET</button>
                </div>
                <div class="slider-container">
                    <span>SPD</span>
                    <input type="range" id="speed-slider" min="100" max="2000" value="1000" step="100">
                </div>
            </div>
        </div>
    </div>

    <!-- Flight Layer for physical animations -->
    <div id="flight-layer" style="position: fixed; inset: 0; pointer-events:none; z-index: 9999;"></div>

    <script>
        const config = {
            initialA: [2, 5, 8],
            bufferSize: 3,
            initialB: [3, 6, 9]
        };

        let state = {
            A: [], 
            B: [],
            ptrA: 0,
            ptrB: 0,
            writePtr: 0,
            isPlaying: false,
            isFinished: false,
            delay: 1000
        };

        // --- DOM Cache ---
        const elRowA = document.getElementById('row-a');
        const elRowB = document.getElementById('row-b');
        const ptrA = document.getElementById('ptr-a');
        const ptrB = document.getElementById('ptr-b');
        const ptrWrite = document.getElementById('ptr-write');
        const elSafetyZone = document.getElementById('safety-zone');
        const elConsole = document.getElementById('console-output');
        const flightLayer = document.getElementById('flight-layer');
        const btnPlay = document.getElementById('btn-play');
        const btnStep = document.getElementById('btn-step');

        // --- Initialization ---
        function init() {
            state.A = [...config.initialA, ...Array(config.bufferSize).fill(null)];
            state.B = [...config.initialB];
            
            state.ptrA = config.initialA.length - 1;
            state.ptrB = config.initialB.length - 1;
            state.writePtr = state.A.length - 1;
            
            state.isFinished = false;
            state.isPlaying = false;
            btnPlay.textContent = "PLAY";
            btnStep.disabled = false;
            
            renderDOM();
            // Allow DOM to settle before calculating geometry
            requestAnimationFrame(() => updatePositions());
            log("SYSTEM INITIALIZED.");
        }

        function renderDOM() {
            // Clear existing blocks (keep pointers)
            document.querySelectorAll('.block').forEach(e => e.remove());

            // Create A Blocks
            state.A.forEach((val, i) => {
                const b = createBlock(val, i, 'a');
                if(val === null) b.classList.add('ghost');
                else b.classList.add('filled');
                // Insert before the safety zone div
                elRowA.insertBefore(b, elSafetyZone);
            });

            // Create B Blocks
            state.B.forEach((val, i) => {
                const b = createBlock(val, i, 'b');
                b.classList.add('filled');
                elRowB.appendChild(b);
            });
        }

        function createBlock(val, i, type) {
            const div = document.createElement('div');
            div.className = 'block';
            div.id = `blk-${type}-${i}`;
            div.textContent = val !== null ? val : '';
            return div;
        }

        // --- Responsive Geometric Positioning ---
        function updatePositions() {
            // Update pointers based on current DOM geometry
            alignPointer(ptrA, 'a', state.ptrA);
            alignPointer(ptrWrite, 'a', state.writePtr);
            alignPointer(ptrB, 'b', state.ptrB);
            
            updateSafetyZone();
        }

        function alignPointer(ptrEl, type, index) {
            if (index < 0) {
                ptrEl.style.opacity = 0;
                return;
            }
            const target = document.getElementById(`blk-${type}-${index}`);
            if (target) {
                ptrEl.style.opacity = 1;
                // Calculations relative to the parent row container
                const parentRect = target.parentElement.getBoundingClientRect();
                const targetRect = target.getBoundingClientRect();
                
                // Align left edge
                const leftPos = targetRect.left - parentRect.left;
                ptrEl.style.left = `${leftPos}px`;
            }
        }

        function updateSafetyZone() {
            // Hide zone if conditions aren't met
            if(state.ptrA < 0 || state.writePtr <= state.ptrA + 1) {
                elSafetyZone.style.width = '0px';
                return;
            }

            const startIdx = state.ptrA + 1;
            const endIdx = state.writePtr; // Safe until write pointer

            const startEl = document.getElementById(`blk-a-${startIdx}`);
            const endEl = document.getElementById(`blk-a-${endIdx}`);
            
            if(!startEl || !endEl) {
                 elSafetyZone.style.width = '0px';
                 return;
            }

            const parentRect = elRowA.getBoundingClientRect();
            const startRect = startEl.getBoundingClientRect();
            const endRect = endEl.getBoundingClientRect();

            // Calculate zone geometry
            const left = startRect.left - parentRect.left;
            
            // The zone ends at the LEFT edge of the Write Pointer's block
            // We subtract a small gap amount for visual separation
            const width = (endRect.left - parentRect.left) - left;
            
            elSafetyZone.style.left = left + 'px';
            elSafetyZone.style.width = Math.max(0, width - 5) + 'px'; // -5 for visual gap
        }

        // --- Animation Logic ---
        const sleep = (ms) => new Promise(r => setTimeout(r, ms));

        function animateFlight(sourceEl, targetEl, val) {
            return new Promise(resolve => {
                // Get fresh coordinates immediately before animation
                const sRect = sourceEl.getBoundingClientRect();
                const tRect = targetEl.getBoundingClientRect();

                const fly = document.createElement('div');
                fly.className = 'flying-block';
                fly.textContent = val;
                
                // Set Initial Position (Fixed viewport coords)
                fly.style.left = sRect.left + 'px';
                fly.style.top = sRect.top + 'px';
                fly.style.width = sRect.width + 'px';
                fly.style.height = sRect.height + 'px';
                
                flightLayer.appendChild(fly);

                // Force browser reflow to register start position
                fly.getBoundingClientRect();

                // Start Transition
                fly.style.transition = `all ${state.delay * 0.4}ms cubic-bezier(0.45, 0, 0.55, 1)`;
                fly.style.left = tRect.left + 'px';
                fly.style.top = tRect.top + 'px';

                // Cleanup
                setTimeout(() => {
                    fly.remove();
                    resolve();
                }, state.delay * 0.4);
            });
        }

        // --- Step Logic ---
        async function step() {
            if (state.isFinished) return;
            
            // Recalculate immediately before step to ensure alignment
            updatePositions();

            // 1. Finish Condition
            if (state.ptrB < 0) {
                log("MERGE COMPLETE.");
                state.isFinished = true;
                state.isPlaying = false;
                btnPlay.textContent = "DONE";
                btnStep.disabled = true;
                return;
            }

            const blockDest = document.getElementById(`blk-a-${state.writePtr}`);

            // 2. Flush B (if A is empty)
            if (state.ptrA < 0) {
                log(`A EMPTY. MOVING B[${state.ptrB}]`);
                const blockB = document.getElementById(`blk-b-${state.ptrB}`);
                
                await animateFlight(blockB, blockDest, state.B[state.ptrB]);
                finalizeMove('b', state.ptrB, state.B[state.ptrB]);
                state.ptrB--;
                state.writePtr--;
                updatePositions();
                return;
            }

            // 3. Comparison
            const valA = state.A[state.ptrA];
            const valB = state.B[state.ptrB];
            const blockA = document.getElementById(`blk-a-${state.ptrA}`);
            const blockB = document.getElementById(`blk-b-${state.ptrB}`);

            blockA.classList.add('highlight');
            blockB.classList.add('highlight');
            log(`COMPARE: ${valA} vs ${valB}`);
            
            await sleep(state.delay * 0.4);

            if (valA > valB) {
                log(`${valA} > ${valB}. MOVE A.`);
                blockA.classList.remove('highlight');
                blockB.classList.remove('highlight');
                
                await animateFlight(blockA, blockDest, valA);
                finalizeMove('a', state.ptrA, valA);
                state.ptrA--;
            } else {
                log(`${valB} >= ${valA}. MOVE B.`);
                blockA.classList.remove('highlight');
                blockB.classList.remove('highlight');
                
                await animateFlight(blockB, blockDest, valB);
                finalizeMove('b', state.ptrB, valB);
                state.ptrB--;
            }

            state.writePtr--;
            updatePositions();
        }

        function finalizeMove(sourceType, sourceIdx, val) {
            const sourceEl = document.getElementById(`blk-${sourceType}-${sourceIdx}`);
            if(sourceType === 'a') {
                sourceEl.classList.remove('filled');
                sourceEl.classList.add('ghost');
                sourceEl.textContent = '';
                state.A[sourceIdx] = null;
            } else {
                sourceEl.style.opacity = 0.3;
                sourceEl.style.borderStyle = 'dashed';
            }

            const destEl = document.getElementById(`blk-a-${state.writePtr}`);
            state.A[state.writePtr] = val;
            destEl.textContent = val;
            destEl.classList.remove('ghost');
            destEl.classList.add('locked');
        }

        function log(msg) {
            const div = document.createElement('div');
            div.className = 'log-entry';
            div.textContent = msg;
            elConsole.appendChild(div);
            elConsole.scrollTop = elConsole.scrollHeight;
        }

        // --- Responsive Listeners ---
        
        // Handle window resizing to keep pointers aligned
        window.addEventListener('resize', () => {
            updatePositions();
        });

        // Handle device orientation changes (mobile)
        window.addEventListener('orientationchange', () => {
            setTimeout(updatePositions, 100);
        });

        btnPlay.addEventListener('click', async () => {
            if (state.isFinished) return;
            state.isPlaying = !state.isPlaying;
            btnPlay.textContent = state.isPlaying ? "PAUSE" : "PLAY";
            btnStep.disabled = state.isPlaying;
            
            while(state.isPlaying && !state.isFinished) {
                await step();
                if(state.isPlaying) await sleep(state.delay * 0.2); 
            }
        });

        btnStep.addEventListener('click', () => step());

        document.getElementById('btn-reset').addEventListener('click', () => {
            state.isPlaying = false;
            elConsole.innerHTML = '';
            document.querySelectorAll('.block').forEach(b => {
                b.style.opacity = 1;
                b.style.borderStyle = '';
            });
            init();
        });

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            state.delay = 2100 - parseInt(e.target.value);
        });

        // Start
        init();

    </script>
</body>
</html>